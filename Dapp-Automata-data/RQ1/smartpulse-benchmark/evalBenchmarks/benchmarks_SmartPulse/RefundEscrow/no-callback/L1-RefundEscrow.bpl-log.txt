This is Ultimate 0.1.24-9993c5c-m
[2020-05-30 20:31:52,638 INFO  L170        SettingsManager]: Resetting all preferences to default values...
[2020-05-30 20:31:52,639 INFO  L174        SettingsManager]: Resetting UltimateCore preferences to default values
[2020-05-30 20:31:52,649 INFO  L177        SettingsManager]: Ultimate Commandline Interface provides no preferences, ignoring...
[2020-05-30 20:31:52,650 INFO  L174        SettingsManager]: Resetting Boogie Preprocessor preferences to default values
[2020-05-30 20:31:52,651 INFO  L174        SettingsManager]: Resetting Boogie Procedure Inliner preferences to default values
[2020-05-30 20:31:52,652 INFO  L174        SettingsManager]: Resetting Abstract Interpretation preferences to default values
[2020-05-30 20:31:52,654 INFO  L174        SettingsManager]: Resetting LassoRanker preferences to default values
[2020-05-30 20:31:52,656 INFO  L174        SettingsManager]: Resetting Reaching Definitions preferences to default values
[2020-05-30 20:31:52,657 INFO  L174        SettingsManager]: Resetting SyntaxChecker preferences to default values
[2020-05-30 20:31:52,658 INFO  L177        SettingsManager]: BÃ¼chi Program Product provides no preferences, ignoring...
[2020-05-30 20:31:52,658 INFO  L174        SettingsManager]: Resetting LTL2Aut preferences to default values
[2020-05-30 20:31:52,659 INFO  L174        SettingsManager]: Resetting PEA to Boogie preferences to default values
[2020-05-30 20:31:52,661 INFO  L174        SettingsManager]: Resetting BlockEncodingV2 preferences to default values
[2020-05-30 20:31:52,662 INFO  L174        SettingsManager]: Resetting ChcToBoogie preferences to default values
[2020-05-30 20:31:52,663 INFO  L174        SettingsManager]: Resetting AutomataScriptInterpreter preferences to default values
[2020-05-30 20:31:52,664 INFO  L174        SettingsManager]: Resetting BuchiAutomizer preferences to default values
[2020-05-30 20:31:52,665 INFO  L174        SettingsManager]: Resetting CACSL2BoogieTranslator preferences to default values
[2020-05-30 20:31:52,667 INFO  L174        SettingsManager]: Resetting CodeCheck preferences to default values
[2020-05-30 20:31:52,668 INFO  L174        SettingsManager]: Resetting InvariantSynthesis preferences to default values
[2020-05-30 20:31:52,669 INFO  L174        SettingsManager]: Resetting RCFGBuilder preferences to default values
[2020-05-30 20:31:52,670 INFO  L174        SettingsManager]: Resetting TraceAbstraction preferences to default values
[2020-05-30 20:31:52,673 INFO  L177        SettingsManager]: TraceAbstractionConcurrent provides no preferences, ignoring...
[2020-05-30 20:31:52,673 INFO  L177        SettingsManager]: TraceAbstractionWithAFAs provides no preferences, ignoring...
[2020-05-30 20:31:52,673 INFO  L174        SettingsManager]: Resetting TreeAutomizer preferences to default values
[2020-05-30 20:31:52,674 INFO  L174        SettingsManager]: Resetting IcfgToChc preferences to default values
[2020-05-30 20:31:52,674 INFO  L174        SettingsManager]: Resetting IcfgTransformer preferences to default values
[2020-05-30 20:31:52,676 INFO  L177        SettingsManager]: ReqToTest provides no preferences, ignoring...
[2020-05-30 20:31:52,676 INFO  L174        SettingsManager]: Resetting UtopiaLiveness preferences to default values
[2020-05-30 20:31:52,676 INFO  L174        SettingsManager]: Resetting UtopiaLTL2Aut preferences to default values
[2020-05-30 20:31:52,676 INFO  L174        SettingsManager]: Resetting UtopiaSpecLang preferences to default values
[2020-05-30 20:31:52,677 INFO  L174        SettingsManager]: Resetting Boogie Printer preferences to default values
[2020-05-30 20:31:52,678 INFO  L174        SettingsManager]: Resetting ChcSmtPrinter preferences to default values
[2020-05-30 20:31:52,679 INFO  L174        SettingsManager]: Resetting ReqPrinter preferences to default values
[2020-05-30 20:31:52,680 INFO  L174        SettingsManager]: Resetting Witness Printer preferences to default values
[2020-05-30 20:31:52,681 INFO  L177        SettingsManager]: Boogie PL CUP Parser provides no preferences, ignoring...
[2020-05-30 20:31:52,681 INFO  L174        SettingsManager]: Resetting CDTParser preferences to default values
[2020-05-30 20:31:52,682 INFO  L177        SettingsManager]: AutomataScriptParser provides no preferences, ignoring...
[2020-05-30 20:31:52,682 INFO  L177        SettingsManager]: ReqParser provides no preferences, ignoring...
[2020-05-30 20:31:52,683 INFO  L174        SettingsManager]: Resetting SmtParser preferences to default values
[2020-05-30 20:31:52,684 INFO  L174        SettingsManager]: Resetting Witness Parser preferences to default values
[2020-05-30 20:31:52,685 INFO  L181        SettingsManager]: Finished resetting all preferences to default values...
[2020-05-30 20:31:52,685 INFO  L98         SettingsManager]: Beginning loading settings from /Users/jon/Documents/Research/masterUltimate/SmartPulse/settings.epf
[2020-05-30 20:31:52,695 INFO  L110        SettingsManager]: Loading preferences was successful
[2020-05-30 20:31:52,695 INFO  L112        SettingsManager]: Preferences different from defaults after loading the file:
[2020-05-30 20:31:52,696 INFO  L131        SettingsManager]: Preferences of LTL2Aut differ from their defaults:
[2020-05-30 20:31:52,696 INFO  L133        SettingsManager]:  * Read property from file=true
[2020-05-30 20:31:52,696 INFO  L133        SettingsManager]:  * Path to LTL*BA executable (LTL2BA, LTL3BA)=/Users/jon/Documents/Research/devUltimate/ltl2ba
[2020-05-30 20:31:52,697 INFO  L131        SettingsManager]: Preferences of BlockEncodingV2 differ from their defaults:
[2020-05-30 20:31:52,697 INFO  L133        SettingsManager]:  * Maximize final states=false
[2020-05-30 20:31:52,697 INFO  L133        SettingsManager]:  * Minimize states even if more edges are added than removed.=true
[2020-05-30 20:31:52,697 INFO  L133        SettingsManager]:  * Minimize states using LBE with the strategy=NONE
[2020-05-30 20:31:52,697 INFO  L131        SettingsManager]: Preferences of BuchiAutomizer differ from their defaults:
[2020-05-30 20:31:52,697 INFO  L133        SettingsManager]:  * Compute Interpolants along a Counterexample=Craig_TreeInterpolation
[2020-05-30 20:31:52,697 INFO  L133        SettingsManager]:  * Use old map elimination=false
[2020-05-30 20:31:52,697 INFO  L133        SettingsManager]:  * Try twofold refinement=false
[2020-05-30 20:31:52,697 INFO  L131        SettingsManager]: Preferences of CACSL2BoogieTranslator differ from their defaults:
[2020-05-30 20:31:52,698 INFO  L133        SettingsManager]:  * Check unreachability of error function in SV-COMP mode=false
[2020-05-30 20:31:52,698 INFO  L133        SettingsManager]:  * Overapproximate operations on floating types=true
[2020-05-30 20:31:52,698 INFO  L133        SettingsManager]:  * Check division by zero=IGNORE
[2020-05-30 20:31:52,698 INFO  L133        SettingsManager]:  * Pointer to allocated memory at dereference=ASSUME
[2020-05-30 20:31:52,698 INFO  L133        SettingsManager]:  * If two pointers are subtracted or compared they have the same base address=ASSUME
[2020-05-30 20:31:52,698 INFO  L133        SettingsManager]:  * Check array bounds for arrays that are off heap=ASSUME
[2020-05-30 20:31:52,698 INFO  L133        SettingsManager]:  * Check if freed pointer was valid=false
[2020-05-30 20:31:52,698 INFO  L133        SettingsManager]:  * Use constant arrays=true
[2020-05-30 20:31:52,698 INFO  L133        SettingsManager]:  * Pointer base address is valid at dereference=ASSUME
[2020-05-30 20:31:52,698 INFO  L131        SettingsManager]: Preferences of RCFGBuilder differ from their defaults:
[2020-05-30 20:31:52,699 INFO  L133        SettingsManager]:  * Size of a code block=SingleStatement
[2020-05-30 20:31:52,699 INFO  L133        SettingsManager]:  * SMT solver=Internal_SMTInterpol
[2020-05-30 20:31:52,719 INFO  L81    nceAwareModelManager]: Repository-Root is: /var/folders/t6/mxckf6w17qb907fknyrxnkyc0000gp/T
[2020-05-30 20:31:52,730 INFO  L259   ainManager$Toolchain]: [Toolchain 1]: Applicable parser(s) successfully (re)initialized
[2020-05-30 20:31:52,732 INFO  L215   ainManager$Toolchain]: [Toolchain 1]: Toolchain selected.
[2020-05-30 20:31:52,732 INFO  L271        PluginConnector]: Initializing Boogie PL CUP Parser...
[2020-05-30 20:31:52,733 INFO  L276        PluginConnector]: Boogie PL CUP Parser initialized
[2020-05-30 20:31:52,734 INFO  L430   ainManager$Toolchain]: [Toolchain 1]: Parsing single file: /Users/jon/Documents/Research/masterUltimate/benchmarks/evalBenchmarks/benchmarks/RefundEscrow/no-callback/L1-RefundEscrow.bpl
[2020-05-30 20:31:52,734 INFO  L111           BoogieParser]: Parsing: '/Users/jon/Documents/Research/masterUltimate/benchmarks/evalBenchmarks/benchmarks/RefundEscrow/no-callback/L1-RefundEscrow.bpl'
[2020-05-30 20:31:52,786 INFO  L297   ainManager$Toolchain]: ####################### [Toolchain 1] #######################
[2020-05-30 20:31:52,787 INFO  L131        ToolchainWalker]: Walking toolchain with 8 elements.
[2020-05-30 20:31:52,788 INFO  L113        PluginConnector]: ------------------------Boogie Preprocessor----------------------------
[2020-05-30 20:31:52,788 INFO  L271        PluginConnector]: Initializing Boogie Preprocessor...
[2020-05-30 20:31:52,788 INFO  L276        PluginConnector]: Boogie Preprocessor initialized
[2020-05-30 20:31:52,802 INFO  L185        PluginConnector]: Executing the observer EnsureBoogieModelObserver from plugin Boogie Preprocessor for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:31:52" (1/1) ...
[2020-05-30 20:31:52,803 INFO  L185        PluginConnector]: Executing the observer TypeChecker from plugin Boogie Preprocessor for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:31:52" (1/1) ...
[2020-05-30 20:31:52,826 INFO  L185        PluginConnector]: Executing the observer ConstExpander from plugin Boogie Preprocessor for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:31:52" (1/1) ...
[2020-05-30 20:31:52,826 INFO  L185        PluginConnector]: Executing the observer StructExpander from plugin Boogie Preprocessor for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:31:52" (1/1) ...
[2020-05-30 20:31:52,838 INFO  L185        PluginConnector]: Executing the observer UnstructureCode from plugin Boogie Preprocessor for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:31:52" (1/1) ...
[2020-05-30 20:31:52,844 INFO  L185        PluginConnector]: Executing the observer FunctionInliner from plugin Boogie Preprocessor for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:31:52" (1/1) ...
[2020-05-30 20:31:52,849 INFO  L185        PluginConnector]: Executing the observer BoogieSymbolTableConstructor from plugin Boogie Preprocessor for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:31:52" (1/1) ...
[2020-05-30 20:31:52,856 INFO  L132        PluginConnector]: ------------------------ END Boogie Preprocessor----------------------------
[2020-05-30 20:31:52,856 INFO  L113        PluginConnector]: ------------------------UtopiaSpecLang----------------------------
[2020-05-30 20:31:52,856 INFO  L271        PluginConnector]: Initializing UtopiaSpecLang...
[2020-05-30 20:31:52,858 INFO  L276        PluginConnector]: UtopiaSpecLang initialized
[2020-05-30 20:31:52,860 INFO  L185        PluginConnector]: Executing the observer UtopiaSpecLangObserver from plugin UtopiaSpecLang for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:31:52" (1/1) ...
[2020-05-30 20:31:52,872 INFO  L975   opiaSpecLangObserver]: Parsing LTLPlus Formula to AstNode: []((finished(RefundEscrow.enableRefunds)) ==> (<>(finished(send(from, to, amt), (to == user && amt == fsum(RefundEscrow.deposit(payee), 2, payee == user))))))
[2020-05-30 20:31:52,878 INFO  L979   opiaSpecLangObserver]: Successfully lexed: []((finished(RefundEscrow.enableRefunds)) ==> (<>(finished(send(from, to, amt), (to == user && amt == fsum(RefundEscrow.deposit(payee), 2, payee == user))))))
[2020-05-30 20:31:52,883 INFO  L981   opiaSpecLangObserver]: Successfully parsed: []((finished(RefundEscrow.enableRefunds)) ==> (<>(finished(send(from, to, amt), (to == user && amt == fsum(RefundEscrow.deposit(payee), 2, payee == user))))))
[2020-05-30 20:31:52,886 INFO  L599   opiaSpecLangObserver]: Parsed refundee_s327==user to BinaryExpression[COMPEQ,IdentifierExpression[refundee_s327,<IMPLEMENTATION_INPARAM,deposit_RefundEscrow>],IdentifierExpression[user,GLOBAL]]
[2020-05-30 20:31:52,889 INFO  L599   opiaSpecLangObserver]: Parsed ( to==user && amount==fsum_deposit_RefundEscrow_2_0 ) to BinaryExpression[LOGICAND,BinaryExpression[COMPEQ,IdentifierExpression[to,<IMPLEMENTATION_INPARAM,send__success>],IdentifierExpression[user,GLOBAL]],BinaryExpression[COMPEQ,IdentifierExpression[amount,<IMPLEMENTATION_INPARAM,send__success>],IdentifierExpression[fsum_deposit_RefundEscrow_2_0,GLOBAL]]]
[2020-05-30 20:31:52,889 INFO  L968   opiaSpecLangObserver]: Compiling: []((finished(RefundEscrow.enableRefunds)) ==> (<>(finished(send(from, to, amt), (to == user && amt == fsum(RefundEscrow.deposit(payee), 2, payee == user))))))
[2020-05-30 20:31:52,890 INFO  L970   opiaSpecLangObserver]: Compiled to ( []( AP(success_enableRefunds_RefundEscrow0) ==> ( <>AP(success_send__success0) ) ) )
[2020-05-30 20:31:52,890 INFO  L975   opiaSpecLangObserver]: Parsing LTLPlus Formula to AstNode: (<>(finished(RefundEscrow.deposit(payee), (payee == user)))) && (<>(finished(ConditionalEscrow.withdraw(payee), (payee == user))))
[2020-05-30 20:31:52,890 INFO  L979   opiaSpecLangObserver]: Successfully lexed: (<>(finished(RefundEscrow.deposit(payee), (payee == user)))) && (<>(finished(ConditionalEscrow.withdraw(payee), (payee == user))))
[2020-05-30 20:31:52,890 INFO  L981   opiaSpecLangObserver]: Successfully parsed: (<>(finished(RefundEscrow.deposit(payee), (payee == user)))) && (<>(finished(ConditionalEscrow.withdraw(payee), (payee == user))))
[2020-05-30 20:31:52,892 INFO  L599   opiaSpecLangObserver]: Parsed payee_s255==user to BinaryExpression[COMPEQ,IdentifierExpression[payee_s255,<IMPLEMENTATION_INPARAM,withdraw_ConditionalEscrow>],IdentifierExpression[user,GLOBAL]]
[2020-05-30 20:31:52,893 INFO  L599   opiaSpecLangObserver]: Parsed refundee_s327==user to BinaryExpression[COMPEQ,IdentifierExpression[refundee_s327,<IMPLEMENTATION_INPARAM,deposit_RefundEscrow>],IdentifierExpression[user,GLOBAL]]
[2020-05-30 20:31:52,894 INFO  L968   opiaSpecLangObserver]: Compiling: (<>(finished(RefundEscrow.deposit(payee), (payee == user)))) && (<>(finished(ConditionalEscrow.withdraw(payee), (payee == user))))
[2020-05-30 20:31:52,894 INFO  L970   opiaSpecLangObserver]: Compiled to ( ( <>AP(success_deposit_RefundEscrow0) ) && ( <>AP(success_withdraw_ConditionalEscrow0) ) )
Executed UtopiaSpecLang
[2020-05-30 20:31:52,899 INFO  L202        PluginConnector]: Adding new model Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:31:52 PropertyContainer
[2020-05-30 20:31:52,899 INFO  L132        PluginConnector]: ------------------------ END UtopiaSpecLang----------------------------
[2020-05-30 20:31:52,900 INFO  L113        PluginConnector]: ------------------------Boogie Printer----------------------------
[2020-05-30 20:31:52,900 INFO  L271        PluginConnector]: Initializing Boogie Printer...
[2020-05-30 20:31:52,900 INFO  L276        PluginConnector]: Boogie Printer initialized
[2020-05-30 20:31:52,900 INFO  L185        PluginConnector]: Executing the observer BoogiePrinterObserver from plugin Boogie Printer for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:31:52" (1/2) ...
[2020-05-30 20:31:52,901 INFO  L116   oogiePrinterObserver]: File already exists and will be overwritten: /var/folders/t6/mxckf6w17qb907fknyrxnkyc0000gp/T/boogiePrinter.bpl
[2020-05-30 20:31:52,901 INFO  L120   oogiePrinterObserver]: Writing to file /var/folders/t6/mxckf6w17qb907fknyrxnkyc0000gp/T/boogiePrinter.bpl
[2020-05-30 20:31:52,909 INFO  L185        PluginConnector]: Executing the observer BoogiePrinterObserver from plugin Boogie Printer for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:31:52" (2/2) ...
[2020-05-30 20:31:52,909 INFO  L132        PluginConnector]: ------------------------ END Boogie Printer----------------------------
[2020-05-30 20:31:52,910 INFO  L113        PluginConnector]: ------------------------RCFGBuilder----------------------------
[2020-05-30 20:31:52,910 INFO  L271        PluginConnector]: Initializing RCFGBuilder...
[2020-05-30 20:31:52,910 INFO  L276        PluginConnector]: RCFGBuilder initialized
[2020-05-30 20:31:52,911 INFO  L185        PluginConnector]: Executing the observer RCFGBuilderObserver from plugin RCFGBuilder for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:31:52" (1/2) ...
[2020-05-30 20:31:52,954 INFO  L130     BoogieDeclarations]: Found specification of procedure FreshRefGenerator__success
[2020-05-30 20:31:52,954 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath_NoBaseCtor__success
[2020-05-30 20:31:52,955 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath
[2020-05-30 20:31:52,955 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath
[2020-05-30 20:31:52,955 INFO  L130     BoogieDeclarations]: Found specification of procedure sub_SafeMath__success
[2020-05-30 20:31:52,955 INFO  L130     BoogieDeclarations]: Found specification of procedure add_SafeMath__success
[2020-05-30 20:31:52,955 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary_NoBaseCtor__success
[2020-05-30 20:31:52,955 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary
[2020-05-30 20:31:52,956 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary
[2020-05-30 20:31:52,956 INFO  L130     BoogieDeclarations]: Found specification of procedure primary_Secondary
[2020-05-30 20:31:52,956 INFO  L138     BoogieDeclarations]: Found implementation of procedure primary_Secondary
[2020-05-30 20:31:52,956 INFO  L130     BoogieDeclarations]: Found specification of procedure transferPrimary_Secondary
[2020-05-30 20:31:52,956 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferPrimary_Secondary
[2020-05-30 20:31:52,956 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow_NoBaseCtor__success
[2020-05-30 20:31:52,956 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow
[2020-05-30 20:31:52,956 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow
[2020-05-30 20:31:52,956 INFO  L130     BoogieDeclarations]: Found specification of procedure depositsOf_Escrow
[2020-05-30 20:31:52,957 INFO  L138     BoogieDeclarations]: Found implementation of procedure depositsOf_Escrow
[2020-05-30 20:31:52,957 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow
[2020-05-30 20:31:52,957 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow
[2020-05-30 20:31:52,957 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow_Escrow__success
[2020-05-30 20:31:52,957 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow
[2020-05-30 20:31:52,957 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow
[2020-05-30 20:31:52,957 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow_Escrow__success
[2020-05-30 20:31:52,957 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success
[2020-05-30 20:31:52,957 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow
[2020-05-30 20:31:52,957 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow
[2020-05-30 20:31:52,957 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawalAllowed_ConditionalEscrow
[2020-05-30 20:31:52,957 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_ConditionalEscrow
[2020-05-30 20:31:52,957 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_ConditionalEscrow
[2020-05-30 20:31:52,957 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow_NoBaseCtor__success
[2020-05-30 20:31:52,958 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow
[2020-05-30 20:31:52,958 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow
[2020-05-30 20:31:52,958 INFO  L130     BoogieDeclarations]: Found specification of procedure state_RefundEscrow
[2020-05-30 20:31:52,958 INFO  L138     BoogieDeclarations]: Found implementation of procedure state_RefundEscrow
[2020-05-30 20:31:52,958 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiary_RefundEscrow
[2020-05-30 20:31:52,958 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiary_RefundEscrow
[2020-05-30 20:31:52,958 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_RefundEscrow
[2020-05-30 20:31:52,958 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_RefundEscrow
[2020-05-30 20:31:52,958 INFO  L130     BoogieDeclarations]: Found specification of procedure close_RefundEscrow
[2020-05-30 20:31:52,958 INFO  L138     BoogieDeclarations]: Found implementation of procedure close_RefundEscrow
[2020-05-30 20:31:52,958 INFO  L130     BoogieDeclarations]: Found specification of procedure enableRefunds_RefundEscrow
[2020-05-30 20:31:52,958 INFO  L138     BoogieDeclarations]: Found implementation of procedure enableRefunds_RefundEscrow
[2020-05-30 20:31:52,959 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiaryWithdraw_RefundEscrow
[2020-05-30 20:31:52,959 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiaryWithdraw_RefundEscrow
[2020-05-30 20:31:52,959 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawalAllowed_RefundEscrow
[2020-05-30 20:31:52,959 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdrawalAllowed_RefundEscrow
[2020-05-30 20:31:52,959 INFO  L130     BoogieDeclarations]: Found specification of procedure FallbackDispatch__success
[2020-05-30 20:31:52,959 INFO  L130     BoogieDeclarations]: Found specification of procedure Fallback_UnknownType__success
[2020-05-30 20:31:52,959 INFO  L130     BoogieDeclarations]: Found specification of procedure send__success
[2020-05-30 20:31:52,959 INFO  L130     BoogieDeclarations]: Found specification of procedure onlyPrimary_pre__success
[2020-05-30 20:31:52,959 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_SafeMath
[2020-05-30 20:31:52,959 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_SafeMath
[2020-05-30 20:31:52,959 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_Secondary
[2020-05-30 20:31:52,959 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_Secondary
[2020-05-30 20:31:52,959 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_Escrow
[2020-05-30 20:31:52,959 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_Escrow
[2020-05-30 20:31:52,960 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_ConditionalEscrow
[2020-05-30 20:31:52,960 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_ConditionalEscrow
[2020-05-30 20:31:52,960 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_RefundEscrow
[2020-05-30 20:31:52,960 INFO  L130     BoogieDeclarations]: Found specification of procedure main
[2020-05-30 20:31:52,960 INFO  L130     BoogieDeclarations]: Found specification of procedure FreshRefGenerator__fail
[2020-05-30 20:31:52,960 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath_NoBaseCtor__fail
[2020-05-30 20:31:52,960 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath__success
[2020-05-30 20:31:52,960 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath__fail
[2020-05-30 20:31:52,960 INFO  L130     BoogieDeclarations]: Found specification of procedure sub_SafeMath__fail
[2020-05-30 20:31:52,960 INFO  L130     BoogieDeclarations]: Found specification of procedure add_SafeMath__fail
[2020-05-30 20:31:52,960 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary_NoBaseCtor__fail
[2020-05-30 20:31:52,960 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary__success
[2020-05-30 20:31:52,960 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary__fail
[2020-05-30 20:31:52,961 INFO  L130     BoogieDeclarations]: Found specification of procedure primary_Secondary__success
[2020-05-30 20:31:52,961 INFO  L130     BoogieDeclarations]: Found specification of procedure primary_Secondary__fail
[2020-05-30 20:31:52,961 INFO  L130     BoogieDeclarations]: Found specification of procedure transferPrimary_Secondary__success
[2020-05-30 20:31:52,961 INFO  L130     BoogieDeclarations]: Found specification of procedure transferPrimary_Secondary__fail
[2020-05-30 20:31:52,961 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow_NoBaseCtor__fail
[2020-05-30 20:31:52,961 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow__success
[2020-05-30 20:31:52,961 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow__fail
[2020-05-30 20:31:52,961 INFO  L130     BoogieDeclarations]: Found specification of procedure depositsOf_Escrow__success
[2020-05-30 20:31:52,961 INFO  L130     BoogieDeclarations]: Found specification of procedure depositsOf_Escrow__fail
[2020-05-30 20:31:52,961 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow__success
[2020-05-30 20:31:52,961 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow__fail
[2020-05-30 20:31:52,961 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow_Escrow__fail
[2020-05-30 20:31:52,961 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow__success
[2020-05-30 20:31:52,962 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow__fail
[2020-05-30 20:31:52,962 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow_Escrow__fail
[2020-05-30 20:31:52,962 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow_NoBaseCtor__fail
[2020-05-30 20:31:52,962 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow__success
[2020-05-30 20:31:52,962 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow__fail
[2020-05-30 20:31:52,962 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_ConditionalEscrow__success
[2020-05-30 20:31:52,962 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_ConditionalEscrow__fail
[2020-05-30 20:31:52,962 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow_NoBaseCtor__fail
[2020-05-30 20:31:52,962 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow__success
[2020-05-30 20:31:52,962 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow__fail
[2020-05-30 20:31:52,962 INFO  L130     BoogieDeclarations]: Found specification of procedure state_RefundEscrow__success
[2020-05-30 20:31:52,962 INFO  L130     BoogieDeclarations]: Found specification of procedure state_RefundEscrow__fail
[2020-05-30 20:31:52,962 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiary_RefundEscrow__success
[2020-05-30 20:31:52,963 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiary_RefundEscrow__fail
[2020-05-30 20:31:52,963 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_RefundEscrow__success
[2020-05-30 20:31:52,963 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_RefundEscrow__fail
[2020-05-30 20:31:52,963 INFO  L130     BoogieDeclarations]: Found specification of procedure close_RefundEscrow__success
[2020-05-30 20:31:52,963 INFO  L130     BoogieDeclarations]: Found specification of procedure close_RefundEscrow__fail
[2020-05-30 20:31:52,963 INFO  L130     BoogieDeclarations]: Found specification of procedure enableRefunds_RefundEscrow__success
[2020-05-30 20:31:52,963 INFO  L130     BoogieDeclarations]: Found specification of procedure enableRefunds_RefundEscrow__fail
[2020-05-30 20:31:52,963 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiaryWithdraw_RefundEscrow__success
[2020-05-30 20:31:52,963 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiaryWithdraw_RefundEscrow__fail
[2020-05-30 20:31:52,963 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawalAllowed_RefundEscrow__success
[2020-05-30 20:31:52,963 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawalAllowed_RefundEscrow__fail
[2020-05-30 20:31:52,963 INFO  L130     BoogieDeclarations]: Found specification of procedure FallbackDispatch__fail
[2020-05-30 20:31:52,964 INFO  L130     BoogieDeclarations]: Found specification of procedure Fallback_UnknownType__fail
[2020-05-30 20:31:52,964 INFO  L130     BoogieDeclarations]: Found specification of procedure send__fail
[2020-05-30 20:31:52,964 INFO  L130     BoogieDeclarations]: Found specification of procedure onlyPrimary_pre__fail
[2020-05-30 20:31:52,964 INFO  L138     BoogieDeclarations]: Found implementation of procedure FreshRefGenerator__fail
[2020-05-30 20:31:52,964 INFO  L138     BoogieDeclarations]: Found implementation of procedure FreshRefGenerator__success
[2020-05-30 20:31:52,964 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath_NoBaseCtor__fail
[2020-05-30 20:31:52,964 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath_NoBaseCtor__success
[2020-05-30 20:31:52,964 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath__fail
[2020-05-30 20:31:52,964 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath__success
[2020-05-30 20:31:52,964 INFO  L138     BoogieDeclarations]: Found implementation of procedure sub_SafeMath__fail
[2020-05-30 20:31:52,964 INFO  L138     BoogieDeclarations]: Found implementation of procedure sub_SafeMath__success
[2020-05-30 20:31:52,964 INFO  L138     BoogieDeclarations]: Found implementation of procedure add_SafeMath__fail
[2020-05-30 20:31:52,964 INFO  L138     BoogieDeclarations]: Found implementation of procedure add_SafeMath__success
[2020-05-30 20:31:52,965 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary_NoBaseCtor__fail
[2020-05-30 20:31:52,965 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary_NoBaseCtor__success
[2020-05-30 20:31:52,965 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary__fail
[2020-05-30 20:31:52,965 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary__success
[2020-05-30 20:31:52,965 INFO  L138     BoogieDeclarations]: Found implementation of procedure primary_Secondary__fail
[2020-05-30 20:31:52,965 INFO  L138     BoogieDeclarations]: Found implementation of procedure primary_Secondary__success
[2020-05-30 20:31:52,965 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferPrimary_Secondary__fail
[2020-05-30 20:31:52,965 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferPrimary_Secondary__success
[2020-05-30 20:31:52,965 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow_NoBaseCtor__fail
[2020-05-30 20:31:52,965 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow_NoBaseCtor__success
[2020-05-30 20:31:52,965 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow__fail
[2020-05-30 20:31:52,965 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow__success
[2020-05-30 20:31:52,965 INFO  L138     BoogieDeclarations]: Found implementation of procedure depositsOf_Escrow__fail
[2020-05-30 20:31:52,966 INFO  L138     BoogieDeclarations]: Found implementation of procedure depositsOf_Escrow__success
[2020-05-30 20:31:52,966 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow__fail
[2020-05-30 20:31:52,966 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow__success
[2020-05-30 20:31:52,966 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow_Escrow__fail
[2020-05-30 20:31:52,966 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow_Escrow__success
[2020-05-30 20:31:52,966 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow__fail
[2020-05-30 20:31:52,966 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow__success
[2020-05-30 20:31:52,966 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow_Escrow__fail
[2020-05-30 20:31:52,966 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow_Escrow__success
[2020-05-30 20:31:52,966 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow_NoBaseCtor__fail
[2020-05-30 20:31:52,966 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success
[2020-05-30 20:31:52,966 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow__fail
[2020-05-30 20:31:52,967 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow__success
[2020-05-30 20:31:52,967 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_ConditionalEscrow__fail
[2020-05-30 20:31:52,967 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_ConditionalEscrow__success
[2020-05-30 20:31:52,967 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow_NoBaseCtor__fail
[2020-05-30 20:31:52,967 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow_NoBaseCtor__success
[2020-05-30 20:31:52,967 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow__fail
[2020-05-30 20:31:52,967 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow__success
[2020-05-30 20:31:52,967 INFO  L138     BoogieDeclarations]: Found implementation of procedure state_RefundEscrow__fail
[2020-05-30 20:31:52,967 INFO  L138     BoogieDeclarations]: Found implementation of procedure state_RefundEscrow__success
[2020-05-30 20:31:52,967 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiary_RefundEscrow__fail
[2020-05-30 20:31:52,967 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiary_RefundEscrow__success
[2020-05-30 20:31:52,967 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_RefundEscrow__fail
[2020-05-30 20:31:52,967 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_RefundEscrow__success
[2020-05-30 20:31:52,967 INFO  L138     BoogieDeclarations]: Found implementation of procedure close_RefundEscrow__fail
[2020-05-30 20:31:52,968 INFO  L138     BoogieDeclarations]: Found implementation of procedure close_RefundEscrow__success
[2020-05-30 20:31:52,968 INFO  L138     BoogieDeclarations]: Found implementation of procedure enableRefunds_RefundEscrow__fail
[2020-05-30 20:31:52,968 INFO  L138     BoogieDeclarations]: Found implementation of procedure enableRefunds_RefundEscrow__success
[2020-05-30 20:31:52,968 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiaryWithdraw_RefundEscrow__fail
[2020-05-30 20:31:52,968 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiaryWithdraw_RefundEscrow__success
[2020-05-30 20:31:52,968 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdrawalAllowed_RefundEscrow__fail
[2020-05-30 20:31:52,968 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdrawalAllowed_RefundEscrow__success
[2020-05-30 20:31:52,968 INFO  L138     BoogieDeclarations]: Found implementation of procedure FallbackDispatch__fail
[2020-05-30 20:31:52,968 INFO  L138     BoogieDeclarations]: Found implementation of procedure FallbackDispatch__success
[2020-05-30 20:31:52,968 INFO  L138     BoogieDeclarations]: Found implementation of procedure Fallback_UnknownType__fail
[2020-05-30 20:31:52,968 INFO  L138     BoogieDeclarations]: Found implementation of procedure Fallback_UnknownType__success
[2020-05-30 20:31:52,968 INFO  L138     BoogieDeclarations]: Found implementation of procedure send__fail
[2020-05-30 20:31:52,968 INFO  L138     BoogieDeclarations]: Found implementation of procedure send__success
[2020-05-30 20:31:52,968 INFO  L138     BoogieDeclarations]: Found implementation of procedure onlyPrimary_pre__fail
[2020-05-30 20:31:52,969 INFO  L138     BoogieDeclarations]: Found implementation of procedure onlyPrimary_pre__success
[2020-05-30 20:31:52,969 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_SafeMath
[2020-05-30 20:31:52,969 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_SafeMath
[2020-05-30 20:31:52,969 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_Secondary
[2020-05-30 20:31:52,969 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_Secondary
[2020-05-30 20:31:52,969 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_Escrow
[2020-05-30 20:31:52,969 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_Escrow
[2020-05-30 20:31:52,969 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_ConditionalEscrow
[2020-05-30 20:31:52,969 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_ConditionalEscrow
[2020-05-30 20:31:52,969 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_RefundEscrow
[2020-05-30 20:31:52,969 INFO  L138     BoogieDeclarations]: Found implementation of procedure main
[2020-05-30 20:31:52,969 INFO  L130     BoogieDeclarations]: Found specification of procedure ULTIMATE.start
[2020-05-30 20:31:52,969 INFO  L138     BoogieDeclarations]: Found implementation of procedure ULTIMATE.start
[2020-05-30 20:31:53,076 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 20:31:53,091 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 20:31:53,105 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 20:31:53,277 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 20:31:53,278 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 20:31:53,364 INFO  L281             CfgBuilder]: Using the 1 location(s) as analysis (start of procedure ULTIMATE.start)
[2020-05-30 20:31:53,365 INFO  L286             CfgBuilder]: Removed 5 assue(true) statements.
[2020-05-30 20:31:53,366 INFO  L202        PluginConnector]: Adding new model L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 08:31:53 BoogieIcfgContainer
[2020-05-30 20:31:53,366 INFO  L185        PluginConnector]: Executing the observer RCFGBuilderObserver from plugin RCFGBuilder for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:31:52" (2/2) ...
[2020-05-30 20:31:53,366 INFO  L85     RCFGBuilderObserver]: No WrapperNode. Let Ultimate process with next node
[2020-05-30 20:31:53,366 INFO  L205        PluginConnector]: Invalid model from RCFGBuilder for observer de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder.RCFGBuilderObserver@28e98e0f and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 08:31:53, skipping insertion in model container
[2020-05-30 20:31:53,366 INFO  L132        PluginConnector]: ------------------------ END RCFGBuilder----------------------------
[2020-05-30 20:31:53,367 INFO  L113        PluginConnector]: ------------------------UtopiaLTL2Aut----------------------------
[2020-05-30 20:31:53,367 INFO  L271        PluginConnector]: Initializing UtopiaLTL2Aut...
[2020-05-30 20:31:53,368 INFO  L276        PluginConnector]: UtopiaLTL2Aut initialized
[2020-05-30 20:31:53,368 INFO  L185        PluginConnector]: Executing the observer UtopiaLTL2AutObserver from plugin UtopiaLTL2Aut for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:31:52" (1/3) ...
[2020-05-30 20:31:53,368 INFO  L205        PluginConnector]: Invalid model from UtopiaLTL2Aut for observer edu.utexas.cs.utopia.ltl2aut.UtopiaLTL2AutObserver@4d48c617 and model type Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 08:31:53, skipping insertion in model container
[2020-05-30 20:31:53,368 INFO  L185        PluginConnector]: Executing the observer UtopiaLTL2AutObserver from plugin UtopiaLTL2Aut for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:31:52" (2/3) ...
No working directory specified, using /Users/jon/Documents/Research/devUltimate/ltl2ba
Starting monitored process 1 with /Users/jon/Documents/Research/devUltimate/ltl2ba -f  ( ( <>a ) && ( <>b ) ) && ! ( ( [] ( c -> ( <>d ) ) ) )  (exit command is null, workingDir is null)
[2020-05-30 20:31:53,407 INFO  L202        PluginConnector]: Adding new model Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 08:31:53 NWAContainer
[2020-05-30 20:31:53,407 INFO  L132        PluginConnector]: ------------------------ END UtopiaLTL2Aut----------------------------
[2020-05-30 20:31:53,407 INFO  L113        PluginConnector]: ------------------------BÃ¼chi Program Product----------------------------
[2020-05-30 20:31:53,407 INFO  L271        PluginConnector]: Initializing BÃ¼chi Program Product...
[2020-05-30 20:31:53,407 INFO  L276        PluginConnector]: BÃ¼chi Program Product initialized
[2020-05-30 20:31:53,408 INFO  L185        PluginConnector]: Executing the observer BuchiProductObserver from plugin BÃ¼chi Program Product for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 08:31:53" (3/4) ...
[2020-05-30 20:31:53,409 INFO  L205        PluginConnector]: Invalid model from BÃ¼chi Program Product for observer de.uni_freiburg.informatik.ultimate.buchiprogramproduct.BuchiProductObserver@7c40b73 and model type LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 08:31:53, skipping insertion in model container
[2020-05-30 20:31:53,409 INFO  L185        PluginConnector]: Executing the observer BuchiProductObserver from plugin BÃ¼chi Program Product for "Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 08:31:53" (4/4) ...
[2020-05-30 20:31:53,412 INFO  L104   BuchiProductObserver]: Initial property automaton 8 locations, 27 edges
[2020-05-30 20:31:53,415 INFO  L110   BuchiProductObserver]: Initial RCFG 1271 locations, 1642 edges
[2020-05-30 20:31:53,415 INFO  L93    BuchiProductObserver]: Beginning generation of product automaton
[2020-05-30 20:31:53,424 INFO  L136       ProductGenerator]: The program has no step specification, so we assume maximum atomicity
[2020-05-30 20:31:57,867 INFO  L97    BuchiProductObserver]: Finished generation of product automaton successfully
[2020-05-30 20:31:57,884 INFO  L110   BuchiProductObserver]: BuchiProgram size 12247 locations, 48204 edges
[2020-05-30 20:31:57,884 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 08:31:57 BoogieIcfgContainer
[2020-05-30 20:31:57,884 INFO  L132        PluginConnector]: ------------------------ END BÃ¼chi Program Product----------------------------
[2020-05-30 20:31:57,884 INFO  L113        PluginConnector]: ------------------------BlockEncodingV2----------------------------
[2020-05-30 20:31:57,884 INFO  L271        PluginConnector]: Initializing BlockEncodingV2...
[2020-05-30 20:31:57,886 INFO  L276        PluginConnector]: BlockEncodingV2 initialized
[2020-05-30 20:31:57,886 INFO  L185        PluginConnector]: Executing the observer BlockEncodingObserver from plugin BlockEncodingV2 for "LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 08:31:57" (1/1) ...
[2020-05-30 20:31:58,085 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,085 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,085 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,085 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,085 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,086 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,086 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,086 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,086 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,086 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,086 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,086 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,091 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,091 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,091 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,091 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,091 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,092 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,093 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,093 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,094 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,094 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,094 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,094 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,096 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,096 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,096 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,096 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,096 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,097 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,099 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,099 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,100 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,100 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,100 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,100 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,103 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:31:58,103 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:31:58,103 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:31:58,104 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:31:58,104 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:31:58,104 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:31:58,104 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:31:58,104 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:31:58,104 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:31:58,104 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:31:58,104 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:31:58,105 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:31:58,105 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:31:58,105 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:31:58,105 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:31:58,105 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:31:58,105 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:31:58,106 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:31:58,109 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:31:58,109 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:31:58,109 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:31:58,109 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:31:58,109 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:31:58,109 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:31:58,115 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,116 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,116 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,116 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,116 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,116 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:31:58,143 INFO  L313           BlockEncoder]: Initial Icfg 12247 locations, 48204 edges
[2020-05-30 20:31:58,143 INFO  L258           BlockEncoder]: Using Remove infeasible edges
[2020-05-30 20:31:58,144 INFO  L270           BlockEncoder]: Using Minimize states even if more edges are added than removed.=true
[2020-05-30 20:31:58,144 INFO  L296           BlockEncoder]: Using Remove sink states
[2020-05-30 20:31:58,144 INFO  L171           BlockEncoder]: Using Apply optimizations until nothing changes=true
[2020-05-30 20:31:58,174 INFO  L70    emoveInfeasibleEdges]: Removed 764 edges and 52 locations because of local infeasibility
[2020-05-30 20:31:58,193 INFO  L70        RemoveSinkStates]: Removed 288 edges and 84 locations by removing sink states
[2020-05-30 20:31:58,229 INFO  L70    emoveInfeasibleEdges]: Removed 0 edges and 0 locations because of local infeasibility
[2020-05-30 20:31:58,240 INFO  L70        RemoveSinkStates]: Removed 0 edges and 0 locations by removing sink states
[2020-05-30 20:31:58,251 INFO  L237           BlockEncoder]: Using Create parallel compositions if possible
[2020-05-30 20:31:58,252 INFO  L66        ParallelComposer]: Creating parallel compositions
[2020-05-30 20:31:58,264 INFO  L313           BlockEncoder]: Encoded RCFG 12023 locations, 46874 edges
[2020-05-30 20:31:58,264 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.blockencoding CFG 30.05 08:31:58 BasicIcfg
[2020-05-30 20:31:58,264 INFO  L132        PluginConnector]: ------------------------ END BlockEncodingV2----------------------------
[2020-05-30 20:31:58,265 INFO  L113        PluginConnector]: ------------------------BuchiAutomizer----------------------------
[2020-05-30 20:31:58,265 INFO  L271        PluginConnector]: Initializing BuchiAutomizer...
[2020-05-30 20:31:58,267 INFO  L276        PluginConnector]: BuchiAutomizer initialized
[2020-05-30 20:31:58,267 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:31:58,267 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:31:52" (1/6) ...
[2020-05-30 20:31:58,268 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@2a77d859 and model type L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 30.05 08:31:58, skipping insertion in model container
[2020-05-30 20:31:58,268 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:31:58,268 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:31:52" (2/6) ...
[2020-05-30 20:31:58,269 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@2a77d859 and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 30.05 08:31:58, skipping insertion in model container
[2020-05-30 20:31:58,269 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:31:58,269 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 08:31:53" (3/6) ...
[2020-05-30 20:31:58,269 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@2a77d859 and model type L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer CFG 30.05 08:31:58, skipping insertion in model container
[2020-05-30 20:31:58,269 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:31:58,269 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 08:31:53" (4/6) ...
[2020-05-30 20:31:58,269 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@2a77d859 and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 30.05 08:31:58, skipping insertion in model container
[2020-05-30 20:31:58,269 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:31:58,269 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 08:31:57" (5/6) ...
[2020-05-30 20:31:58,270 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@2a77d859 and model type LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer OTHER 30.05 08:31:58, skipping insertion in model container
[2020-05-30 20:31:58,270 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:31:58,270 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.blockencoding CFG 30.05 08:31:58" (6/6) ...
[2020-05-30 20:31:58,271 INFO  L404   chiAutomizerObserver]: Analyzing ICFG L1-RefundEscrow.bpl_BEv2
[2020-05-30 20:31:58,303 INFO  L133   ementStrategyFactory]: Using default assertion order modulation
[2020-05-30 20:31:58,303 INFO  L377         BuchiCegarLoop]: Interprodecural is true
[2020-05-30 20:31:58,303 INFO  L378         BuchiCegarLoop]: Hoare is false
[2020-05-30 20:31:58,303 INFO  L379         BuchiCegarLoop]: Compute interpolants for Craig_TreeInterpolation
[2020-05-30 20:31:58,303 INFO  L380         BuchiCegarLoop]: Backedges is STRAIGHT_LINE
[2020-05-30 20:31:58,303 INFO  L381         BuchiCegarLoop]: Determinization is PREDICATE_ABSTRACTION
[2020-05-30 20:31:58,303 INFO  L382         BuchiCegarLoop]: Difference is false
[2020-05-30 20:31:58,304 INFO  L383         BuchiCegarLoop]: Minimize is MINIMIZE_SEVPA
[2020-05-30 20:31:58,304 INFO  L386         BuchiCegarLoop]: ======== Iteration 0==of CEGAR loop == BuchiCegarLoop========
[2020-05-30 20:31:58,434 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 12023 states.
[2020-05-30 20:31:59,345 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:31:59,345 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:31:59,345 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:31:59,362 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:31:59,362 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:31:59,362 INFO  L445         BuchiCegarLoop]: ======== Iteration 1============
[2020-05-30 20:31:59,362 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 12023 states.
[2020-05-30 20:31:59,432 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:31:59,432 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:31:59,432 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:31:59,434 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:31:59,434 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_withdraw_ConditionalEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_enableRefunds_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc user;
[L3111]              assume null == 0;
[L3112]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3112]  RET         call this := FreshRefGenerator__success();
[L3113]              assume now >= 0;
[L3114]              assume DType[this] == RefundEscrow;
[L3115]              gas := gas - 53000;
[L3116]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND TRUE   revert
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3116]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]              assume !revert && gas >= 0;

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND TRUE   choice == 11
[L3003]              gas := gas - 21000;
[L3004]  COND FALSE  !(gas >= 0)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:31:59,520 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:31:59,520 INFO  L82        PathProgramCache]: Analyzing trace with hash -1645629286, now seen corresponding path program 1 times
[2020-05-30 20:31:59,524 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:31:59,542 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:31:59,583 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 20:31:59,585 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:31:59,586 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:31:59,589 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:31:59,600 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:31:59,601 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:31:59,602 INFO  L87              Difference]: Start difference. First operand 12023 states. Second operand 3 states.
[2020-05-30 20:32:00,381 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:32:00,381 INFO  L93              Difference]: Finished difference Result 7995 states and 18843 transitions.
[2020-05-30 20:32:00,381 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:32:00,383 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 7995 states and 18843 transitions.
[2020-05-30 20:32:00,442 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:32:00,524 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 7995 states to 7995 states and 18843 transitions.
[2020-05-30 20:32:00,525 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 8
[2020-05-30 20:32:00,531 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 894
[2020-05-30 20:32:00,532 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 7995 states and 18843 transitions.
[2020-05-30 20:32:00,559 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:32:00,559 INFO  L728         BuchiCegarLoop]: Abstraction has 7995 states and 18843 transitions.
[2020-05-30 20:32:00,583 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 7995 states and 18843 transitions.
[2020-05-30 20:32:00,704 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 7995 to 7995.
[2020-05-30 20:32:00,704 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 7995 states.
[2020-05-30 20:32:00,729 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 7995 states to 7995 states and 18843 transitions.
[2020-05-30 20:32:00,730 INFO  L751         BuchiCegarLoop]: Abstraction has 7995 states and 18843 transitions.
[2020-05-30 20:32:00,731 INFO  L631         BuchiCegarLoop]: Abstraction has 7995 states and 18843 transitions.
[2020-05-30 20:32:00,731 INFO  L445         BuchiCegarLoop]: ======== Iteration 2============
[2020-05-30 20:32:00,731 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 7995 states and 18843 transitions.
[2020-05-30 20:32:00,751 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:32:00,751 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:32:00,751 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:32:00,754 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:32:00,754 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_withdraw_ConditionalEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_enableRefunds_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc user;
[L3111]              assume null == 0;
[L3112]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3112]  RET         call this := FreshRefGenerator__success();
[L3113]              assume now >= 0;
[L3114]              assume DType[this] == RefundEscrow;
[L3115]              gas := gas - 53000;
[L3116]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND TRUE   revert
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3116]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]              assume !revert && gas >= 0;
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND TRUE   choice == 2
[L3084]              gas := gas - 21000;
[L3085]  COND TRUE   gas >= 0
[L3087]              assume msgvalue_MSG == 0;
[L3088]  CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]               havoc __exception;
[L713]               revert := false;
[L714]   COND FALSE  !(__exception)
[L733]   CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]              gas := gas - 2208;
[L2601]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]  COND TRUE   revert
[L733]   RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_enableRefunds_RefundEscrow0 := true;
[L7]                 success_enableRefunds_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3088]  RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]  RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND TRUE   choice == 2
[L3084]              gas := gas - 21000;
[L3085]  COND TRUE   gas >= 0
[L3087]              assume msgvalue_MSG == 0;
[L3088]  CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]               havoc __exception;
[L713]               revert := false;
[L714]   COND FALSE  !(__exception)
[L733]   CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]              gas := gas - 2208;
[L2601]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]  COND TRUE   revert
[L733]   RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_enableRefunds_RefundEscrow0 := true;
[L7]                 success_enableRefunds_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3088]  RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:32:00,758 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:32:00,759 INFO  L82        PathProgramCache]: Analyzing trace with hash 1774152547, now seen corresponding path program 1 times
[2020-05-30 20:32:00,759 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:32:00,766 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:32:00,778 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 20:32:00,778 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:32:00,778 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:32:00,780 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:32:00,780 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:32:00,780 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:32:00,780 INFO  L87              Difference]: Start difference. First operand 7995 states and 18843 transitions. cyclomatic complexity: 10856 Second operand 3 states.
[2020-05-30 20:32:01,180 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:32:01,180 INFO  L93              Difference]: Finished difference Result 7581 states and 12331 transitions.
[2020-05-30 20:32:01,180 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:32:01,180 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 7581 states and 12331 transitions.
[2020-05-30 20:32:01,218 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:32:01,263 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 7581 states to 7581 states and 12331 transitions.
[2020-05-30 20:32:01,264 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 894
[2020-05-30 20:32:01,265 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 894
[2020-05-30 20:32:01,265 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 7581 states and 12331 transitions.
[2020-05-30 20:32:01,278 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:32:01,278 INFO  L728         BuchiCegarLoop]: Abstraction has 7581 states and 12331 transitions.
[2020-05-30 20:32:01,288 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 7581 states and 12331 transitions.
[2020-05-30 20:32:01,361 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 7581 to 7581.
[2020-05-30 20:32:01,361 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 7581 states.
[2020-05-30 20:32:01,382 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 7581 states to 7581 states and 12331 transitions.
[2020-05-30 20:32:01,382 INFO  L751         BuchiCegarLoop]: Abstraction has 7581 states and 12331 transitions.
[2020-05-30 20:32:01,382 INFO  L631         BuchiCegarLoop]: Abstraction has 7581 states and 12331 transitions.
[2020-05-30 20:32:01,383 INFO  L445         BuchiCegarLoop]: ======== Iteration 3============
[2020-05-30 20:32:01,383 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 7581 states and 12331 transitions.
[2020-05-30 20:32:01,395 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:32:01,395 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:32:01,395 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:32:01,398 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:32:01,398 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_withdraw_ConditionalEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_enableRefunds_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc user;
[L3111]              assume null == 0;
[L3112]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3112]  RET         call this := FreshRefGenerator__success();
[L3113]              assume now >= 0;
[L3114]              assume DType[this] == RefundEscrow;
[L3115]              gas := gas - 53000;
[L3116]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND TRUE   revert
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND TRUE   revert
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3116]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]              assume !revert && gas >= 0;
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND TRUE   choice == 8
[L3030]              gas := gas - 21000;
[L3031]  COND TRUE   gas >= 0
[L3033]              assume msgvalue_MSG >= 0;
[L3034]  CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]               havoc __exception;
[L639]               revert := false;
[L640]   COND FALSE  !(__exception)
[L659]   CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]              assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]              Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]              Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]              gas := gas - 317;
[L2191]  COND TRUE   !(_state_RefundEscrow[this] == 0)
[L2193]              revert := true;
[L659]   RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume refundee_s327 == user;
[L7]                 success_deposit_RefundEscrow0 := true;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L7]                 assume !(refundee_s327 == user);
[L3034]  RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]  RET         call CorralChoice_RefundEscrow(this);
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND TRUE   choice == 2
[L3084]              gas := gas - 21000;
[L3085]  COND TRUE   gas >= 0
[L3087]              assume msgvalue_MSG == 0;
[L3088]  CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]               havoc __exception;
[L713]               revert := false;
[L714]   COND FALSE  !(__exception)
[L733]   CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]              gas := gas - 2208;
[L2601]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]  COND TRUE   revert
[L733]   RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_enableRefunds_RefundEscrow0 := true;
[L7]                 success_enableRefunds_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3088]  RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]  RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND TRUE   choice == 8
[L3030]              gas := gas - 21000;
[L3031]  COND TRUE   gas >= 0
[L3033]              assume msgvalue_MSG >= 0;
[L3034]  CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]               havoc __exception;
[L639]               revert := false;
[L640]   COND FALSE  !(__exception)
[L659]   CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]              assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]              Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]              Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]              gas := gas - 317;
[L2191]  COND TRUE   !(_state_RefundEscrow[this] == 0)
[L2193]              revert := true;
[L659]   RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume refundee_s327 == user;
[L7]                 success_deposit_RefundEscrow0 := true;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L7]                 assume !(refundee_s327 == user);
[L3034]  RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:32:01,402 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:32:01,403 INFO  L82        PathProgramCache]: Analyzing trace with hash 798777844, now seen corresponding path program 1 times
[2020-05-30 20:32:01,403 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:32:01,411 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:32:01,465 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 20:32:01,465 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:32:01,465 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-05-30 20:32:01,466 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:32:01,466 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-05-30 20:32:01,466 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=5, Invalid=7, Unknown=0, NotChecked=0, Total=12
[2020-05-30 20:32:01,466 INFO  L87              Difference]: Start difference. First operand 7581 states and 12331 transitions. cyclomatic complexity: 4758 Second operand 4 states.
[2020-05-30 20:32:02,367 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:32:02,367 INFO  L93              Difference]: Finished difference Result 7374 states and 8374 transitions.
[2020-05-30 20:32:02,367 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 4 states. 
[2020-05-30 20:32:02,367 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 7374 states and 8374 transitions.
[2020-05-30 20:32:02,381 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:32:02,403 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 7374 states to 7374 states and 8374 transitions.
[2020-05-30 20:32:02,404 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 894
[2020-05-30 20:32:02,404 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 894
[2020-05-30 20:32:02,404 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 7374 states and 8374 transitions.
[2020-05-30 20:32:02,412 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:32:02,412 INFO  L728         BuchiCegarLoop]: Abstraction has 7374 states and 8374 transitions.
[2020-05-30 20:32:02,421 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 7374 states and 8374 transitions.
[2020-05-30 20:32:02,486 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 7374 to 7374.
[2020-05-30 20:32:02,486 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 7374 states.
[2020-05-30 20:32:02,496 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 7374 states to 7374 states and 8374 transitions.
[2020-05-30 20:32:02,497 INFO  L751         BuchiCegarLoop]: Abstraction has 7374 states and 8374 transitions.
[2020-05-30 20:32:02,497 INFO  L631         BuchiCegarLoop]: Abstraction has 7374 states and 8374 transitions.
[2020-05-30 20:32:02,497 INFO  L445         BuchiCegarLoop]: ======== Iteration 4============
[2020-05-30 20:32:02,497 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 7374 states and 8374 transitions.
[2020-05-30 20:32:02,508 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:32:02,508 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:32:02,508 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:32:02,511 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:32:02,511 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_withdraw_ConditionalEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_enableRefunds_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc user;
[L3111]              assume null == 0;
[L3112]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3112]  RET         call this := FreshRefGenerator__success();
[L3113]              assume now >= 0;
[L3114]              assume DType[this] == RefundEscrow;
[L3115]              gas := gas - 53000;
[L3116]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND TRUE   revert
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND TRUE   revert
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3116]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]              assume !revert && gas >= 0;
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND TRUE   choice == 8
[L3030]              gas := gas - 21000;
[L3031]  COND TRUE   gas >= 0
[L3033]              assume msgvalue_MSG >= 0;
[L3034]  CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]               havoc __exception;
[L639]               revert := false;
[L640]   COND FALSE  !(__exception)
[L659]   CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]              assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]              Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]              Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]              gas := gas - 317;
[L2191]  COND TRUE   !(_state_RefundEscrow[this] == 0)
[L2193]              revert := true;
[L659]   RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume refundee_s327 == user;
[L7]                 success_deposit_RefundEscrow0 := true;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L7]                 assume !(refundee_s327 == user);
[L3034]  RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]  RET         call CorralChoice_RefundEscrow(this);
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND TRUE   choice == 7
[L3039]              gas := gas - 21000;
[L3040]  COND TRUE   gas >= 0
[L3042]              assume msgvalue_MSG == 0;
[L3043]  CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]               havoc __exception;
[L482]               revert := false;
[L483]   COND FALSE  !(__exception)
[L502]   CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]              gas := gas - 27;
[L1966]  COND FALSE  !(DType[this] == RefundEscrow)
[L1974]  COND TRUE   DType[this] == ConditionalEscrow
[L1983]  COND TRUE   !__var_6
[L1985]              revert := true;
[L502]   RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume payee_s255 == user;
[L7]                 success_withdraw_ConditionalEscrow0 := true;
[L7]                 success_withdraw_ConditionalEscrow0 := false;
[L7]                 revert := revert_hold;
[L3043]  RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]  RET         call CorralChoice_RefundEscrow(this);
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND TRUE   choice == 2
[L3084]              gas := gas - 21000;
[L3085]  COND TRUE   gas >= 0
[L3087]              assume msgvalue_MSG == 0;
[L3088]  CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]               havoc __exception;
[L713]               revert := false;
[L714]   COND FALSE  !(__exception)
[L733]   CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]              gas := gas - 2208;
[L2601]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]  COND TRUE   revert
[L733]   RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_enableRefunds_RefundEscrow0 := true;
[L7]                 success_enableRefunds_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3088]  RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]  RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND TRUE   choice == 7
[L3039]              gas := gas - 21000;
[L3040]  COND TRUE   gas >= 0
[L3042]              assume msgvalue_MSG == 0;
[L3043]  CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]               havoc __exception;
[L482]               revert := false;
[L483]   COND FALSE  !(__exception)
[L502]   CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]              gas := gas - 27;
[L1966]  COND FALSE  !(DType[this] == RefundEscrow)
[L1974]  COND TRUE   DType[this] == ConditionalEscrow
[L1983]  COND TRUE   !__var_6
[L1985]              revert := true;
[L502]   RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume payee_s255 == user;
[L7]                 success_withdraw_ConditionalEscrow0 := true;
[L7]                 success_withdraw_ConditionalEscrow0 := false;
[L7]                 revert := revert_hold;
[L3043]  RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:32:02,515 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:32:02,516 INFO  L82        PathProgramCache]: Analyzing trace with hash -547523244, now seen corresponding path program 1 times
[2020-05-30 20:32:02,516 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:32:02,523 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:32:02,557 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 20:32:02,558 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:32:02,558 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:32:02,558 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:32:02,558 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:32:02,559 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:32:02,559 INFO  L87              Difference]: Start difference. First operand 7374 states and 8374 transitions. cyclomatic complexity: 1008 Second operand 3 states.
[2020-05-30 20:32:02,692 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:32:02,693 INFO  L93              Difference]: Finished difference Result 9582 states and 10970 transitions.
[2020-05-30 20:32:02,693 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:32:02,693 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9582 states and 10970 transitions.
[2020-05-30 20:32:02,713 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:32:02,742 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9582 states to 8972 states and 10180 transitions.
[2020-05-30 20:32:02,742 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1094
[2020-05-30 20:32:02,742 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1094
[2020-05-30 20:32:02,742 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 8972 states and 10180 transitions.
[2020-05-30 20:32:02,749 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:32:02,749 INFO  L728         BuchiCegarLoop]: Abstraction has 8972 states and 10180 transitions.
[2020-05-30 20:32:02,759 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 8972 states and 10180 transitions.
[2020-05-30 20:32:02,838 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 8972 to 8265.
[2020-05-30 20:32:02,839 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8265 states.
[2020-05-30 20:32:02,849 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8265 states to 8265 states and 9298 transitions.
[2020-05-30 20:32:02,849 INFO  L751         BuchiCegarLoop]: Abstraction has 8265 states and 9298 transitions.
[2020-05-30 20:32:02,849 INFO  L631         BuchiCegarLoop]: Abstraction has 8265 states and 9298 transitions.
[2020-05-30 20:32:02,849 INFO  L445         BuchiCegarLoop]: ======== Iteration 5============
[2020-05-30 20:32:02,849 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8265 states and 9298 transitions.
[2020-05-30 20:32:02,863 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:32:02,863 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:32:02,863 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:32:02,868 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:32:02,868 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND TRUE   __exception
[L531]                     __tmp__Balance := Balance;
[L532]                     __tmp__DType := DType;
[L533]                     __tmp__Alloc := Alloc;
[L534]                     __tmp__balance_ADDR := balance_ADDR;
[L535]                     __tmp__M_Ref_int__deposits0 := M_Ref_int__deposits0;
[L536]                     __tmp__sum__deposits0 := sum__deposits0;
[L537]                     __tmp__Length := Length;
[L538]                     __tmp__now := now;
[L539]                     __tmp___primary_Secondary := _primary_Secondary;
[L540]                     __tmp___deposits_Escrow := _deposits_Escrow;
[L541]                     __tmp___state_RefundEscrow := _state_RefundEscrow;
[L542]                     __tmp___beneficiary_RefundEscrow := _beneficiary_RefundEscrow;
[L543]         CALL        call RefundEscrow_RefundEscrow__fail(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2058]        CALL        call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1355]        CALL        call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1334]                    assume msgsender_MSG != null;
[L1335]                    __tmp__Balance[this] := 0;
[L1336]                    __tmp___primary_Secondary[this] := null;
[L1337]                    __tmp___primary_Secondary[this] := msgsender_MSG;
[L1355]        RET         call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1356]        COND FALSE  !(revert)
[L2058]        RET         call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L2059]        COND FALSE  !(revert)
[L2064]        CALL        call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L1484]        CALL        call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1355]        CALL        call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1334]                    assume msgsender_MSG != null;
[L1335]                    __tmp__Balance[this] := 0;
[L1336]                    __tmp___primary_Secondary[this] := null;
[L1337]                    __tmp___primary_Secondary[this] := msgsender_MSG;
[L1355]        RET         call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1356]        COND FALSE  !(revert)
[L1484]        RET         call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1485]        COND FALSE  !(revert)
[L1490]        CALL        call Escrow_Escrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1448]                    assume msgsender_MSG != null;
[L1449]                    __tmp__Balance[this] := 0;
[L1450]        CALL        call __var_2 := FreshRefGenerator__fail();
[L1168]                    havoc newRef;
[L1169]                    assume __tmp__Alloc[newRef] == false;
[L1170]                    __tmp__Alloc[newRef] := true;
[L1171]                    assume newRef != null;
[L1450]        RET         call __var_2 := FreshRefGenerator__fail();
[L1451]        COND FALSE  !(revert)
[L1456]                    __tmp___deposits_Escrow[this] := __var_2;
[L1457]                    __tmp__M_Ref_int__deposits0[__tmp___deposits_Escrow[this]] := zeroRefIntArr();
[L1458]                    __tmp__sum__deposits0[__tmp___deposits_Escrow[this]] := 0;
[L1490]        RET         call Escrow_Escrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1491]        COND FALSE  !(revert)
[L2064]        RET         call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L2065]        COND FALSE  !(revert)
[L2070]        CALL        call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L1864]        CALL        call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1355]        CALL        call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1334]                    assume msgsender_MSG != null;
[L1335]                    __tmp__Balance[this] := 0;
[L1336]                    __tmp___primary_Secondary[this] := null;
[L1337]                    __tmp___primary_Secondary[this] := msgsender_MSG;
[L1355]        RET         call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1356]        COND FALSE  !(revert)
[L1864]        RET         call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1865]        COND FALSE  !(revert)
[L1870]        CALL        call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L1484]        CALL        call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1355]        CALL        call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1334]                    assume msgsender_MSG != null;
[L1335]                    __tmp__Balance[this] := 0;
[L1336]                    __tmp___primary_Secondary[this] := null;
[L1337]                    __tmp___primary_Secondary[this] := msgsender_MSG;
[L1355]        RET         call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1356]        COND FALSE  !(revert)
[L1484]        RET         call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1485]        COND FALSE  !(revert)
[L1490]        CALL        call Escrow_Escrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1448]                    assume msgsender_MSG != null;
[L1449]                    __tmp__Balance[this] := 0;
[L1450]        CALL        call __var_2 := FreshRefGenerator__fail();
[L1168]                    havoc newRef;
[L1169]                    assume __tmp__Alloc[newRef] == false;
[L1170]                    __tmp__Alloc[newRef] := true;
[L1171]                    assume newRef != null;
[L1450]        RET         call __var_2 := FreshRefGenerator__fail();
[L1451]        COND FALSE  !(revert)
[L1456]                    __tmp___deposits_Escrow[this] := __var_2;
[L1457]                    __tmp__M_Ref_int__deposits0[__tmp___deposits_Escrow[this]] := zeroRefIntArr();
[L1458]                    __tmp__sum__deposits0[__tmp___deposits_Escrow[this]] := 0;
[L1490]        RET         call Escrow_Escrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1491]        COND FALSE  !(revert)
[L1870]        RET         call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L1871]        COND FALSE  !(revert)
[L1876]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1848]                    assume msgsender_MSG != null;
[L1849]                    __tmp__Balance[this] := 0;
[L1876]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1877]        COND FALSE  !(revert)
[L2070]        RET         call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L2071]        COND FALSE  !(revert)
[L2076]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2018]                    assume msgsender_MSG != null;
[L2019]                    __tmp__Balance[this] := 0;
[L2020]                    __tmp___beneficiary_RefundEscrow[this] := null;
[L2021]                    __var_7 := null;
[L2022]        COND FALSE  !(!(beneficiary_s294 != null))
[L2028]                    __tmp___beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2029]                    __tmp___state_RefundEscrow[this] := 0;
[L2076]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2077]        COND FALSE  !(revert)
[L543]         RET         call RefundEscrow_RefundEscrow__fail(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L544]                     assume revert || gas < 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume !(refundee_s327 == user);
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND FALSE  !(DType[this] == RefundEscrow)
[L1974]        COND TRUE   DType[this] == ConditionalEscrow
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND FALSE  !(Balance[from] >= amount)
[L2577]                    success := false;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume !(refundee_s327 == user);
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:32:02,875 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:32:02,876 INFO  L82        PathProgramCache]: Analyzing trace with hash -932007026, now seen corresponding path program 1 times
[2020-05-30 20:32:02,877 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:32:02,896 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:32:02,973 INFO  L134       CoverageAnalysis]: Checked inductivity of 99 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 99 trivial. 0 not checked.
[2020-05-30 20:32:02,974 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:32:02,974 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-05-30 20:32:02,974 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:32:02,974 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-05-30 20:32:02,974 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=6, Invalid=6, Unknown=0, NotChecked=0, Total=12
[2020-05-30 20:32:02,975 INFO  L87              Difference]: Start difference. First operand 8265 states and 9298 transitions. cyclomatic complexity: 1041 Second operand 4 states.
[2020-05-30 20:32:04,892 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:32:04,892 INFO  L93              Difference]: Finished difference Result 9804 states and 11276 transitions.
[2020-05-30 20:32:04,892 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 4 states. 
[2020-05-30 20:32:04,892 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9804 states and 11276 transitions.
[2020-05-30 20:32:04,908 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 8
[2020-05-30 20:32:04,936 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9804 states to 9700 states and 11169 transitions.
[2020-05-30 20:32:04,936 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1205
[2020-05-30 20:32:04,937 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1205
[2020-05-30 20:32:04,937 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9700 states and 11169 transitions.
[2020-05-30 20:32:04,944 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:32:04,944 INFO  L728         BuchiCegarLoop]: Abstraction has 9700 states and 11169 transitions.
[2020-05-30 20:32:04,952 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9700 states and 11169 transitions.
[2020-05-30 20:32:05,023 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9700 to 7924.
[2020-05-30 20:32:05,023 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 7924 states.
[2020-05-30 20:32:05,031 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 7924 states to 7924 states and 8856 transitions.
[2020-05-30 20:32:05,031 INFO  L751         BuchiCegarLoop]: Abstraction has 7924 states and 8856 transitions.
[2020-05-30 20:32:05,031 INFO  L631         BuchiCegarLoop]: Abstraction has 7924 states and 8856 transitions.
[2020-05-30 20:32:05,032 INFO  L445         BuchiCegarLoop]: ======== Iteration 6============
[2020-05-30 20:32:05,032 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 7924 states and 8856 transitions.
[2020-05-30 20:32:05,041 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:32:05,041 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:32:05,041 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:32:05,044 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:32:05,044 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume !(refundee_s327 == user);
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND FALSE  !(DType[this] == RefundEscrow)
[L1974]        COND TRUE   DType[this] == ConditionalEscrow
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND FALSE  !(DType[this] == RefundEscrow)
[L1998]        COND TRUE   DType[this] == ConditionalEscrow
[L2000]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND FALSE  !(Balance[from] >= amount)
[L2577]                    success := false;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L2000]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2001]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume !(refundee_s327 == user);
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:32:05,050 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:32:05,051 INFO  L82        PathProgramCache]: Analyzing trace with hash -1513440734, now seen corresponding path program 1 times
[2020-05-30 20:32:05,051 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:32:05,071 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:32:05,145 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:32:05,146 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:32:05,146 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:32:05,146 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:32:05,146 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:32:05,147 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:32:05,147 INFO  L87              Difference]: Start difference. First operand 7924 states and 8856 transitions. cyclomatic complexity: 940 Second operand 3 states.
[2020-05-30 20:32:05,222 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:32:05,222 INFO  L93              Difference]: Finished difference Result 7956 states and 8888 transitions.
[2020-05-30 20:32:05,222 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:32:05,222 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 7956 states and 8888 transitions.
[2020-05-30 20:32:05,237 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:32:05,258 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 7956 states to 7956 states and 8888 transitions.
[2020-05-30 20:32:05,258 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 988
[2020-05-30 20:32:05,258 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 988
[2020-05-30 20:32:05,258 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 7956 states and 8888 transitions.
[2020-05-30 20:32:05,263 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:32:05,263 INFO  L728         BuchiCegarLoop]: Abstraction has 7956 states and 8888 transitions.
[2020-05-30 20:32:05,272 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 7956 states and 8888 transitions.
[2020-05-30 20:32:05,324 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 7956 to 7948.
[2020-05-30 20:32:05,325 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 7948 states.
[2020-05-30 20:32:05,335 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 7948 states to 7948 states and 8880 transitions.
[2020-05-30 20:32:05,335 INFO  L751         BuchiCegarLoop]: Abstraction has 7948 states and 8880 transitions.
[2020-05-30 20:32:05,335 INFO  L631         BuchiCegarLoop]: Abstraction has 7948 states and 8880 transitions.
[2020-05-30 20:32:05,335 INFO  L445         BuchiCegarLoop]: ======== Iteration 7============
[2020-05-30 20:32:05,335 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 7948 states and 8880 transitions.
[2020-05-30 20:32:05,345 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:32:05,345 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:32:05,345 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:32:05,350 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:32:05,350 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND FALSE  !(DType[this] == RefundEscrow)
[L1974]        COND TRUE   DType[this] == ConditionalEscrow
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND FALSE  !(DType[this] == RefundEscrow)
[L1998]        COND TRUE   DType[this] == ConditionalEscrow
[L2000]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND FALSE  !(Balance[from] >= amount)
[L2577]                    success := false;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L2000]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2001]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:32:05,357 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:32:05,358 INFO  L82        PathProgramCache]: Analyzing trace with hash 64411252, now seen corresponding path program 1 times
[2020-05-30 20:32:05,358 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:32:05,374 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:32:05,476 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:32:05,477 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:32:05,477 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [5] imperfect sequences [] total 5
[2020-05-30 20:32:05,477 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:32:05,477 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 6 interpolants.
[2020-05-30 20:32:05,477 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=9, Invalid=21, Unknown=0, NotChecked=0, Total=30
[2020-05-30 20:32:05,478 INFO  L87              Difference]: Start difference. First operand 7948 states and 8880 transitions. cyclomatic complexity: 940 Second operand 6 states.
[2020-05-30 20:32:05,735 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:32:05,735 INFO  L93              Difference]: Finished difference Result 8092 states and 9032 transitions.
[2020-05-30 20:32:05,735 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 6 states. 
[2020-05-30 20:32:05,735 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 8092 states and 9032 transitions.
[2020-05-30 20:32:05,750 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:32:05,770 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 8092 states to 7892 states and 8800 transitions.
[2020-05-30 20:32:05,771 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 981
[2020-05-30 20:32:05,771 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 981
[2020-05-30 20:32:05,771 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 7892 states and 8800 transitions.
[2020-05-30 20:32:05,776 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:32:05,776 INFO  L728         BuchiCegarLoop]: Abstraction has 7892 states and 8800 transitions.
[2020-05-30 20:32:05,783 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 7892 states and 8800 transitions.
[2020-05-30 20:32:05,834 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 7892 to 7892.
[2020-05-30 20:32:05,834 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 7892 states.
[2020-05-30 20:32:05,843 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 7892 states to 7892 states and 8800 transitions.
[2020-05-30 20:32:05,843 INFO  L751         BuchiCegarLoop]: Abstraction has 7892 states and 8800 transitions.
[2020-05-30 20:32:05,843 INFO  L631         BuchiCegarLoop]: Abstraction has 7892 states and 8800 transitions.
[2020-05-30 20:32:05,843 INFO  L445         BuchiCegarLoop]: ======== Iteration 8============
[2020-05-30 20:32:05,843 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 7892 states and 8800 transitions.
[2020-05-30 20:32:05,852 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:32:05,852 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:32:05,852 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:32:05,854 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:32:05,854 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND FALSE  !(Balance[from] >= amount)
[L2577]                    success := false;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:32:05,861 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:32:05,861 INFO  L82        PathProgramCache]: Analyzing trace with hash -1820047491, now seen corresponding path program 1 times
[2020-05-30 20:32:05,862 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:32:05,878 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:32:05,993 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:32:05,993 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:32:05,993 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [10] imperfect sequences [] total 10
[2020-05-30 20:32:05,994 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:32:05,994 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 10 interpolants.
[2020-05-30 20:32:05,994 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=18, Invalid=72, Unknown=0, NotChecked=0, Total=90
[2020-05-30 20:32:05,994 INFO  L87              Difference]: Start difference. First operand 7892 states and 8800 transitions. cyclomatic complexity: 916 Second operand 10 states.
[2020-05-30 20:32:09,102 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:32:09,102 INFO  L93              Difference]: Finished difference Result 9440 states and 10850 transitions.
[2020-05-30 20:32:09,102 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-30 20:32:09,102 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9440 states and 10850 transitions.
[2020-05-30 20:32:09,117 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 8
[2020-05-30 20:32:09,138 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9440 states to 9384 states and 10786 transitions.
[2020-05-30 20:32:09,138 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1175
[2020-05-30 20:32:09,140 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1175
[2020-05-30 20:32:09,140 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9384 states and 10786 transitions.
[2020-05-30 20:32:09,146 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:32:09,147 INFO  L728         BuchiCegarLoop]: Abstraction has 9384 states and 10786 transitions.
[2020-05-30 20:32:09,153 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9384 states and 10786 transitions.
[2020-05-30 20:32:09,211 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9384 to 8976.
[2020-05-30 20:32:09,211 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8976 states.
[2020-05-30 20:32:09,220 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8976 states to 8976 states and 10211 transitions.
[2020-05-30 20:32:09,221 INFO  L751         BuchiCegarLoop]: Abstraction has 8976 states and 10211 transitions.
[2020-05-30 20:32:09,221 INFO  L631         BuchiCegarLoop]: Abstraction has 8976 states and 10211 transitions.
[2020-05-30 20:32:09,221 INFO  L445         BuchiCegarLoop]: ======== Iteration 9============
[2020-05-30 20:32:09,221 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8976 states and 10211 transitions.
[2020-05-30 20:32:09,230 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 8
[2020-05-30 20:32:09,230 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:32:09,230 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:32:09,232 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:32:09,232 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND TRUE   choice == 3
[L3075]                    gas := gas - 21000;
[L3076]        COND TRUE   gas >= 0
[L3078]                    assume msgvalue_MSG == 0;
[L3079]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L3079]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND FALSE  !(Balance[from] >= amount)
[L2577]                    success := false;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:32:09,236 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:32:09,237 INFO  L82        PathProgramCache]: Analyzing trace with hash -751774951, now seen corresponding path program 1 times
[2020-05-30 20:32:09,237 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:32:09,252 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:32:09,363 INFO  L134       CoverageAnalysis]: Checked inductivity of 157 backedges. 2 proven. 34 refuted. 0 times theorem prover too weak. 121 trivial. 0 not checked.
[2020-05-30 20:32:09,363 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:32:09,363 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [11] total 11
[2020-05-30 20:32:09,364 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:32:09,364 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-05-30 20:32:09,364 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=21, Invalid=89, Unknown=0, NotChecked=0, Total=110
[2020-05-30 20:32:09,364 INFO  L87              Difference]: Start difference. First operand 8976 states and 10211 transitions. cyclomatic complexity: 1243 Second operand 11 states.
[2020-05-30 20:32:11,757 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:32:11,757 INFO  L93              Difference]: Finished difference Result 8275 states and 9267 transitions.
[2020-05-30 20:32:11,757 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-30 20:32:11,757 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 8275 states and 9267 transitions.
[2020-05-30 20:32:11,769 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:32:11,777 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 8275 states to 5569 states and 6165 transitions.
[2020-05-30 20:32:11,777 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 879
[2020-05-30 20:32:11,777 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 893
[2020-05-30 20:32:11,777 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 5569 states and 6165 transitions.
[2020-05-30 20:32:11,779 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:32:11,780 INFO  L728         BuchiCegarLoop]: Abstraction has 5569 states and 6165 transitions.
[2020-05-30 20:32:11,783 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 5569 states and 6165 transitions.
[2020-05-30 20:32:11,804 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 5569 to 5547.
[2020-05-30 20:32:11,804 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 5547 states.
[2020-05-30 20:32:11,809 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 5547 states to 5547 states and 6141 transitions.
[2020-05-30 20:32:11,809 INFO  L751         BuchiCegarLoop]: Abstraction has 5547 states and 6141 transitions.
[2020-05-30 20:32:11,809 INFO  L631         BuchiCegarLoop]: Abstraction has 5547 states and 6141 transitions.
[2020-05-30 20:32:11,809 INFO  L445         BuchiCegarLoop]: ======== Iteration 10============
[2020-05-30 20:32:11,809 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 5547 states and 6141 transitions.
[2020-05-30 20:32:11,814 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:32:11,814 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:32:11,814 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:32:11,815 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:32:11,815 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND FALSE  !(Balance[from] >= amount)
[L2577]                    success := false;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND TRUE   choice == 11
[L3003]              gas := gas - 21000;
[L3004]  COND FALSE  !(gas >= 0)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:32:11,818 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:32:11,819 INFO  L82        PathProgramCache]: Analyzing trace with hash -2019179596, now seen corresponding path program 1 times
[2020-05-30 20:32:11,819 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:32:11,834 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:32:11,897 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:32:11,897 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:32:11,898 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-05-30 20:32:11,898 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:32:11,898 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-05-30 20:32:11,898 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=5, Invalid=7, Unknown=0, NotChecked=0, Total=12
[2020-05-30 20:32:11,899 INFO  L87              Difference]: Start difference. First operand 5547 states and 6141 transitions. cyclomatic complexity: 600 Second operand 4 states.
[2020-05-30 20:32:11,932 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:32:11,932 INFO  L93              Difference]: Finished difference Result 5609 states and 6207 transitions.
[2020-05-30 20:32:11,933 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 4 states. 
[2020-05-30 20:32:11,933 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 5609 states and 6207 transitions.
[2020-05-30 20:32:11,941 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:32:11,949 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 5609 states to 5597 states and 6195 transitions.
[2020-05-30 20:32:11,949 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 900
[2020-05-30 20:32:11,949 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 900
[2020-05-30 20:32:11,949 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 5597 states and 6195 transitions.
[2020-05-30 20:32:11,951 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:32:11,951 INFO  L728         BuchiCegarLoop]: Abstraction has 5597 states and 6195 transitions.
[2020-05-30 20:32:11,954 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 5597 states and 6195 transitions.
[2020-05-30 20:32:11,976 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 5597 to 5597.
[2020-05-30 20:32:11,976 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 5597 states.
[2020-05-30 20:32:11,980 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 5597 states to 5597 states and 6195 transitions.
[2020-05-30 20:32:11,981 INFO  L751         BuchiCegarLoop]: Abstraction has 5597 states and 6195 transitions.
[2020-05-30 20:32:11,981 INFO  L631         BuchiCegarLoop]: Abstraction has 5597 states and 6195 transitions.
[2020-05-30 20:32:11,981 INFO  L445         BuchiCegarLoop]: ======== Iteration 11============
[2020-05-30 20:32:11,981 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 5597 states and 6195 transitions.
[2020-05-30 20:32:11,986 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:32:11,986 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:32:11,986 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:32:11,987 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:32:11,987 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND TRUE   choice == 11
[L3003]              gas := gas - 21000;
[L3004]  COND FALSE  !(gas >= 0)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:32:11,991 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:32:11,991 INFO  L82        PathProgramCache]: Analyzing trace with hash -124354768, now seen corresponding path program 1 times
[2020-05-30 20:32:11,991 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:32:12,006 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:32:12,123 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:32:12,123 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:32:12,123 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [16] imperfect sequences [] total 16
[2020-05-30 20:32:12,124 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:32:12,124 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 16 interpolants.
[2020-05-30 20:32:12,124 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=76, Invalid=164, Unknown=0, NotChecked=0, Total=240
[2020-05-30 20:32:12,124 INFO  L87              Difference]: Start difference. First operand 5597 states and 6195 transitions. cyclomatic complexity: 604 Second operand 16 states.
[2020-05-30 20:32:14,106 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:32:14,106 INFO  L93              Difference]: Finished difference Result 6675 states and 7318 transitions.
[2020-05-30 20:32:14,106 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 19 states. 
[2020-05-30 20:32:14,106 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 6675 states and 7318 transitions.
[2020-05-30 20:32:14,118 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 8
[2020-05-30 20:32:14,128 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 6675 states to 6345 states and 6916 transitions.
[2020-05-30 20:32:14,128 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1035
[2020-05-30 20:32:14,129 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1035
[2020-05-30 20:32:14,129 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 6345 states and 6916 transitions.
[2020-05-30 20:32:14,131 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:32:14,131 INFO  L728         BuchiCegarLoop]: Abstraction has 6345 states and 6916 transitions.
[2020-05-30 20:32:14,135 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 6345 states and 6916 transitions.
[2020-05-30 20:32:14,156 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 6345 to 5403.
[2020-05-30 20:32:14,157 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 5403 states.
[2020-05-30 20:32:14,161 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 5403 states to 5403 states and 5835 transitions.
[2020-05-30 20:32:14,161 INFO  L751         BuchiCegarLoop]: Abstraction has 5403 states and 5835 transitions.
[2020-05-30 20:32:14,161 INFO  L631         BuchiCegarLoop]: Abstraction has 5403 states and 5835 transitions.
[2020-05-30 20:32:14,161 INFO  L445         BuchiCegarLoop]: ======== Iteration 12============
[2020-05-30 20:32:14,161 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 5403 states and 5835 transitions.
[2020-05-30 20:32:14,166 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:32:14,166 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:32:14,166 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:32:14,167 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:32:14,168 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND FALSE  !(choice == 1)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:32:14,171 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:32:14,171 INFO  L82        PathProgramCache]: Analyzing trace with hash 1518520228, now seen corresponding path program 1 times
[2020-05-30 20:32:14,172 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:32:14,192 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:32:14,662 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:32:14,662 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:32:14,662 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [45] imperfect sequences [] total 45
[2020-05-30 20:32:14,663 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:32:14,663 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 46 interpolants.
[2020-05-30 20:32:14,663 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=140, Invalid=1930, Unknown=0, NotChecked=0, Total=2070
[2020-05-30 20:32:14,663 INFO  L87              Difference]: Start difference. First operand 5403 states and 5835 transitions. cyclomatic complexity: 438 Second operand 46 states.
[2020-05-30 20:32:36,029 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:32:36,030 INFO  L93              Difference]: Finished difference Result 11546 states and 12652 transitions.
[2020-05-30 20:32:36,030 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 80 states. 
[2020-05-30 20:32:36,030 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 11546 states and 12652 transitions.
[2020-05-30 20:32:36,051 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 8
[2020-05-30 20:32:36,073 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 11546 states to 11546 states and 12652 transitions.
[2020-05-30 20:32:36,073 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1788
[2020-05-30 20:32:36,074 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1788
[2020-05-30 20:32:36,074 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 11546 states and 12652 transitions.
[2020-05-30 20:32:36,080 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:32:36,080 INFO  L728         BuchiCegarLoop]: Abstraction has 11546 states and 12652 transitions.
[2020-05-30 20:32:36,085 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 11546 states and 12652 transitions.
[2020-05-30 20:32:36,146 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 11546 to 11239.
[2020-05-30 20:32:36,147 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 11239 states.
[2020-05-30 20:32:36,157 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 11239 states to 11239 states and 12218 transitions.
[2020-05-30 20:32:36,157 INFO  L751         BuchiCegarLoop]: Abstraction has 11239 states and 12218 transitions.
[2020-05-30 20:32:36,157 INFO  L631         BuchiCegarLoop]: Abstraction has 11239 states and 12218 transitions.
[2020-05-30 20:32:36,157 INFO  L445         BuchiCegarLoop]: ======== Iteration 13============
[2020-05-30 20:32:36,157 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 11239 states and 12218 transitions.
[2020-05-30 20:32:36,168 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 6
[2020-05-30 20:32:36,168 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:32:36,168 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:32:36,170 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:32:36,170 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND FALSE  !(choice == 1)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:32:36,173 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:32:36,173 INFO  L82        PathProgramCache]: Analyzing trace with hash -1490313897, now seen corresponding path program 1 times
[2020-05-30 20:32:36,174 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:32:36,195 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:32:36,590 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 7 proven. 0 refuted. 0 times theorem prover too weak. 110 trivial. 0 not checked.
[2020-05-30 20:32:36,590 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:32:36,590 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [46] imperfect sequences [] total 46
[2020-05-30 20:32:36,591 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:32:36,591 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 47 interpolants.
[2020-05-30 20:32:36,592 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=144, Invalid=2018, Unknown=0, NotChecked=0, Total=2162
[2020-05-30 20:32:36,592 INFO  L87              Difference]: Start difference. First operand 11239 states and 12218 transitions. cyclomatic complexity: 993 Second operand 47 states.
[2020-05-30 20:32:49,458 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:32:49,458 INFO  L93              Difference]: Finished difference Result 13751 states and 15055 transitions.
[2020-05-30 20:32:49,458 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 78 states. 
[2020-05-30 20:32:49,459 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 13751 states and 15055 transitions.
[2020-05-30 20:32:49,479 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 6
[2020-05-30 20:32:49,504 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 13751 states to 13751 states and 15055 transitions.
[2020-05-30 20:32:49,504 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1794
[2020-05-30 20:32:49,505 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1794
[2020-05-30 20:32:49,505 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 13751 states and 15055 transitions.
[2020-05-30 20:32:49,510 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:32:49,510 INFO  L728         BuchiCegarLoop]: Abstraction has 13751 states and 15055 transitions.
[2020-05-30 20:32:49,515 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 13751 states and 15055 transitions.
[2020-05-30 20:32:49,590 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 13751 to 13281.
[2020-05-30 20:32:49,590 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 13281 states.
[2020-05-30 20:32:49,602 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 13281 states to 13281 states and 14479 transitions.
[2020-05-30 20:32:49,602 INFO  L751         BuchiCegarLoop]: Abstraction has 13281 states and 14479 transitions.
[2020-05-30 20:32:49,602 INFO  L631         BuchiCegarLoop]: Abstraction has 13281 states and 14479 transitions.
[2020-05-30 20:32:49,602 INFO  L445         BuchiCegarLoop]: ======== Iteration 14============
[2020-05-30 20:32:49,602 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 13281 states and 14479 transitions.
[2020-05-30 20:32:49,614 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 6
[2020-05-30 20:32:49,614 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:32:49,615 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:32:49,616 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:32:49,616 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND FALSE  !(choice == 1)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:32:49,619 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:32:49,619 INFO  L82        PathProgramCache]: Analyzing trace with hash 354393286, now seen corresponding path program 1 times
[2020-05-30 20:32:49,620 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:32:49,632 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:32:49,712 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:32:49,712 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:32:49,712 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [12] imperfect sequences [] total 12
[2020-05-30 20:32:49,712 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:32:49,713 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 12 interpolants.
[2020-05-30 20:32:49,713 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=23, Invalid=109, Unknown=0, NotChecked=0, Total=132
[2020-05-30 20:32:49,713 INFO  L87              Difference]: Start difference. First operand 13281 states and 14479 transitions. cyclomatic complexity: 1220 Second operand 12 states.
[2020-05-30 20:32:52,153 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:32:52,153 INFO  L93              Difference]: Finished difference Result 14665 states and 16253 transitions.
[2020-05-30 20:32:52,153 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 12 states. 
[2020-05-30 20:32:52,153 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 14665 states and 16253 transitions.
[2020-05-30 20:32:52,188 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 6
[2020-05-30 20:32:52,269 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 14665 states to 14665 states and 16253 transitions.
[2020-05-30 20:32:52,269 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1760
[2020-05-30 20:32:52,269 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1760
[2020-05-30 20:32:52,270 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 14665 states and 16253 transitions.
[2020-05-30 20:32:52,276 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:32:52,277 INFO  L728         BuchiCegarLoop]: Abstraction has 14665 states and 16253 transitions.
[2020-05-30 20:32:52,282 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 14665 states and 16253 transitions.
[2020-05-30 20:32:52,358 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 14665 to 14568.
[2020-05-30 20:32:52,358 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 14568 states.
[2020-05-30 20:32:52,375 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 14568 states to 14568 states and 16140 transitions.
[2020-05-30 20:32:52,375 INFO  L751         BuchiCegarLoop]: Abstraction has 14568 states and 16140 transitions.
[2020-05-30 20:32:52,375 INFO  L631         BuchiCegarLoop]: Abstraction has 14568 states and 16140 transitions.
[2020-05-30 20:32:52,375 INFO  L445         BuchiCegarLoop]: ======== Iteration 15============
[2020-05-30 20:32:52,375 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 14568 states and 16140 transitions.
[2020-05-30 20:32:52,390 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 6
[2020-05-30 20:32:52,390 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:32:52,390 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:32:52,391 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:32:52,391 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND TRUE   choice == 3
[L3075]                    gas := gas - 21000;
[L3076]        COND TRUE   gas >= 0
[L3078]                    assume msgvalue_MSG == 0;
[L3079]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L3079]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND FALSE  !(choice == 1)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:32:52,405 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:32:52,405 INFO  L82        PathProgramCache]: Analyzing trace with hash -942572420, now seen corresponding path program 1 times
[2020-05-30 20:32:52,405 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:32:52,417 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:32:52,505 INFO  L134       CoverageAnalysis]: Checked inductivity of 158 backedges. 37 proven. 0 refuted. 0 times theorem prover too weak. 121 trivial. 0 not checked.
[2020-05-30 20:32:52,505 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:32:52,505 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [12] imperfect sequences [] total 12
[2020-05-30 20:32:52,505 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:32:52,505 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 12 interpolants.
[2020-05-30 20:32:52,505 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=22, Invalid=110, Unknown=0, NotChecked=0, Total=132
[2020-05-30 20:32:52,506 INFO  L87              Difference]: Start difference. First operand 14568 states and 16140 transitions. cyclomatic complexity: 1598 Second operand 12 states.
[2020-05-30 20:32:54,597 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:32:54,597 INFO  L93              Difference]: Finished difference Result 16081 states and 17970 transitions.
[2020-05-30 20:32:54,597 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 15 states. 
[2020-05-30 20:32:54,597 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 16081 states and 17970 transitions.
[2020-05-30 20:32:54,633 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 6
[2020-05-30 20:32:54,671 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 16081 states to 15373 states and 17201 transitions.
[2020-05-30 20:32:54,672 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1760
[2020-05-30 20:32:54,672 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1760
[2020-05-30 20:32:54,672 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 15373 states and 17201 transitions.
[2020-05-30 20:32:54,682 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:32:54,682 INFO  L728         BuchiCegarLoop]: Abstraction has 15373 states and 17201 transitions.
[2020-05-30 20:32:54,688 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 15373 states and 17201 transitions.
[2020-05-30 20:32:54,779 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 15373 to 15325.
[2020-05-30 20:32:54,779 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 15325 states.
[2020-05-30 20:32:54,800 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 15325 states to 15325 states and 17145 transitions.
[2020-05-30 20:32:54,800 INFO  L751         BuchiCegarLoop]: Abstraction has 15325 states and 17145 transitions.
[2020-05-30 20:32:54,800 INFO  L631         BuchiCegarLoop]: Abstraction has 15325 states and 17145 transitions.
[2020-05-30 20:32:54,800 INFO  L445         BuchiCegarLoop]: ======== Iteration 16============
[2020-05-30 20:32:54,800 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 15325 states and 17145 transitions.
[2020-05-30 20:32:54,817 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 6
[2020-05-30 20:32:54,817 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:32:54,818 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:32:54,819 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:32:54,819 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == user && amount == fsum_deposit_RefundEscrow_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND FALSE  !(choice == 1)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:32:54,822 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:32:54,823 INFO  L82        PathProgramCache]: Analyzing trace with hash -1048755727, now seen corresponding path program 1 times
[2020-05-30 20:32:54,823 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:32:54,835 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:32:54,913 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:32:54,913 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:32:54,913 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [12] imperfect sequences [] total 12
[2020-05-30 20:32:54,914 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:32:54,914 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 12 interpolants.
[2020-05-30 20:32:54,914 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=23, Invalid=109, Unknown=0, NotChecked=0, Total=132
[2020-05-30 20:32:54,914 INFO  L87              Difference]: Start difference. First operand 15325 states and 17145 transitions. cyclomatic complexity: 1871 Second operand 12 states.
[2020-05-30 20:32:55,941 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:32:55,941 INFO  L93              Difference]: Finished difference Result 9461 states and 10480 transitions.
[2020-05-30 20:32:55,941 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 12 states. 
[2020-05-30 20:32:55,942 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9461 states and 10480 transitions.
[2020-05-30 20:32:55,957 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:32:55,971 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9461 states to 9322 states and 10334 transitions.
[2020-05-30 20:32:55,971 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1716
[2020-05-30 20:32:55,972 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1716
[2020-05-30 20:32:55,972 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9322 states and 10334 transitions.
[2020-05-30 20:32:55,976 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:32:55,976 INFO  L728         BuchiCegarLoop]: Abstraction has 9322 states and 10334 transitions.
[2020-05-30 20:32:55,979 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9322 states and 10334 transitions.
[2020-05-30 20:32:56,017 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9322 to 9178.
[2020-05-30 20:32:56,017 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 9178 states.
[2020-05-30 20:32:56,026 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 9178 states to 9178 states and 10175 transitions.
[2020-05-30 20:32:56,026 INFO  L751         BuchiCegarLoop]: Abstraction has 9178 states and 10175 transitions.
[2020-05-30 20:32:56,026 INFO  L631         BuchiCegarLoop]: Abstraction has 9178 states and 10175 transitions.
[2020-05-30 20:32:56,026 INFO  L445         BuchiCegarLoop]: ======== Iteration 17============
[2020-05-30 20:32:56,026 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 9178 states and 10175 transitions.
[2020-05-30 20:32:56,034 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:32:56,034 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:32:56,034 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:32:56,035 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:32:56,035 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND FALSE  !(choice == 2)
[L3091]        COND TRUE   choice == 1
[L3093]                    gas := gas - 21000;
[L3094]        COND TRUE   gas >= 0
[L3096]                    assume msgvalue_MSG == 0;
[L3097]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L3097]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND FALSE  !(choice == 1)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:32:56,039 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:32:56,039 INFO  L82        PathProgramCache]: Analyzing trace with hash 1622658678, now seen corresponding path program 1 times
[2020-05-30 20:32:56,039 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:32:56,052 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:32:56,148 INFO  L134       CoverageAnalysis]: Checked inductivity of 150 backedges. 1 proven. 32 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:32:56,148 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:32:56,148 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [10] total 10
[2020-05-30 20:32:56,149 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:32:56,149 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 10 interpolants.
[2020-05-30 20:32:56,149 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=18, Invalid=72, Unknown=0, NotChecked=0, Total=90
[2020-05-30 20:32:56,149 INFO  L87              Difference]: Start difference. First operand 9178 states and 10175 transitions. cyclomatic complexity: 1023 Second operand 10 states.
[2020-05-30 20:32:57,222 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:32:57,222 INFO  L93              Difference]: Finished difference Result 8970 states and 9901 transitions.
[2020-05-30 20:32:57,222 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 10 states. 
[2020-05-30 20:32:57,222 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 8970 states and 9901 transitions.
[2020-05-30 20:32:57,237 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:32:57,252 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 8970 states to 8949 states and 9879 transitions.
[2020-05-30 20:32:57,252 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1670
[2020-05-30 20:32:57,253 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1670
[2020-05-30 20:32:57,253 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 8949 states and 9879 transitions.
[2020-05-30 20:32:57,256 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:32:57,256 INFO  L728         BuchiCegarLoop]: Abstraction has 8949 states and 9879 transitions.
[2020-05-30 20:32:57,259 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 8949 states and 9879 transitions.
[2020-05-30 20:32:57,292 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 8949 to 8891.
[2020-05-30 20:32:57,292 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8891 states.
[2020-05-30 20:32:57,301 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8891 states to 8891 states and 9810 transitions.
[2020-05-30 20:32:57,301 INFO  L751         BuchiCegarLoop]: Abstraction has 8891 states and 9810 transitions.
[2020-05-30 20:32:57,301 INFO  L631         BuchiCegarLoop]: Abstraction has 8891 states and 9810 transitions.
[2020-05-30 20:32:57,301 INFO  L445         BuchiCegarLoop]: ======== Iteration 18============
[2020-05-30 20:32:57,301 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8891 states and 9810 transitions.
[2020-05-30 20:32:57,310 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:32:57,310 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:32:57,310 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:32:57,311 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:32:57,311 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(refundee_s327 == user);
[L7]                       revert := revert_hold;
[L7]                       assume !(refundee_s327 == user);
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:32:57,315 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:32:57,315 INFO  L82        PathProgramCache]: Analyzing trace with hash -702982259, now seen corresponding path program 1 times
[2020-05-30 20:32:57,315 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:32:57,334 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:32:57,580 INFO  L134       CoverageAnalysis]: Checked inductivity of 221 backedges. 36 proven. 0 refuted. 0 times theorem prover too weak. 185 trivial. 0 not checked.
[2020-05-30 20:32:57,580 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:32:57,580 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [29] imperfect sequences [] total 29
[2020-05-30 20:32:57,581 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:32:57,581 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 30 interpolants.
[2020-05-30 20:32:57,581 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=74, Invalid=796, Unknown=0, NotChecked=0, Total=870
[2020-05-30 20:32:57,581 INFO  L87              Difference]: Start difference. First operand 8891 states and 9810 transitions. cyclomatic complexity: 943 Second operand 30 states.
[2020-05-30 20:33:06,770 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:33:06,770 INFO  L93              Difference]: Finished difference Result 9094 states and 10079 transitions.
[2020-05-30 20:33:06,770 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 50 states. 
[2020-05-30 20:33:06,770 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9094 states and 10079 transitions.
[2020-05-30 20:33:06,788 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:33:06,806 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9094 states to 9094 states and 10079 transitions.
[2020-05-30 20:33:06,807 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1714
[2020-05-30 20:33:06,807 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1714
[2020-05-30 20:33:06,807 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9094 states and 10079 transitions.
[2020-05-30 20:33:06,811 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:33:06,811 INFO  L728         BuchiCegarLoop]: Abstraction has 9094 states and 10079 transitions.
[2020-05-30 20:33:06,814 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9094 states and 10079 transitions.
[2020-05-30 20:33:06,855 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9094 to 8972.
[2020-05-30 20:33:06,855 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8972 states.
[2020-05-30 20:33:06,864 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8972 states to 8972 states and 9923 transitions.
[2020-05-30 20:33:06,864 INFO  L751         BuchiCegarLoop]: Abstraction has 8972 states and 9923 transitions.
[2020-05-30 20:33:06,864 INFO  L631         BuchiCegarLoop]: Abstraction has 8972 states and 9923 transitions.
[2020-05-30 20:33:06,864 INFO  L445         BuchiCegarLoop]: ======== Iteration 19============
[2020-05-30 20:33:06,864 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8972 states and 9923 transitions.
[2020-05-30 20:33:06,873 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:33:06,873 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:33:06,873 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:33:06,874 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:33:06,874 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(payee_s255 == user);
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:33:06,878 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:33:06,878 INFO  L82        PathProgramCache]: Analyzing trace with hash 1932176133, now seen corresponding path program 1 times
[2020-05-30 20:33:06,879 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:33:06,898 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:33:07,438 INFO  L134       CoverageAnalysis]: Checked inductivity of 238 backedges. 4 proven. 39 refuted. 0 times theorem prover too weak. 195 trivial. 0 not checked.
[2020-05-30 20:33:07,438 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:33:07,438 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [50] total 50
[2020-05-30 20:33:07,439 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:33:07,439 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 51 interpolants.
[2020-05-30 20:33:07,440 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=190, Invalid=2360, Unknown=0, NotChecked=0, Total=2550
[2020-05-30 20:33:07,440 INFO  L87              Difference]: Start difference. First operand 8972 states and 9923 transitions. cyclomatic complexity: 978 Second operand 51 states.
[2020-05-30 20:33:22,807 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:33:22,807 INFO  L93              Difference]: Finished difference Result 9282 states and 10374 transitions.
[2020-05-30 20:33:22,808 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 80 states. 
[2020-05-30 20:33:22,808 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9282 states and 10374 transitions.
[2020-05-30 20:33:22,823 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:33:22,838 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9282 states to 9282 states and 10374 transitions.
[2020-05-30 20:33:22,838 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1750
[2020-05-30 20:33:22,839 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1750
[2020-05-30 20:33:22,839 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9282 states and 10374 transitions.
[2020-05-30 20:33:22,843 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:33:22,843 INFO  L728         BuchiCegarLoop]: Abstraction has 9282 states and 10374 transitions.
[2020-05-30 20:33:22,846 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9282 states and 10374 transitions.
[2020-05-30 20:33:22,889 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9282 to 9022.
[2020-05-30 20:33:22,889 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 9022 states.
[2020-05-30 20:33:22,898 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 9022 states to 9022 states and 10007 transitions.
[2020-05-30 20:33:22,898 INFO  L751         BuchiCegarLoop]: Abstraction has 9022 states and 10007 transitions.
[2020-05-30 20:33:22,898 INFO  L631         BuchiCegarLoop]: Abstraction has 9022 states and 10007 transitions.
[2020-05-30 20:33:22,898 INFO  L445         BuchiCegarLoop]: ======== Iteration 20============
[2020-05-30 20:33:22,898 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 9022 states and 10007 transitions.
[2020-05-30 20:33:22,906 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:33:22,906 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:33:22,906 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:33:22,907 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:33:22,907 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(payee_s255 == user);
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND FALSE  !(choice == 1)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:33:22,911 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:33:22,911 INFO  L82        PathProgramCache]: Analyzing trace with hash -535329962, now seen corresponding path program 1 times
[2020-05-30 20:33:22,911 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:33:22,936 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:33:23,674 INFO  L134       CoverageAnalysis]: Checked inductivity of 237 backedges. 11 proven. 36 refuted. 0 times theorem prover too weak. 190 trivial. 0 not checked.
[2020-05-30 20:33:23,674 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:33:23,674 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [56] total 56
[2020-05-30 20:33:23,675 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:33:23,675 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 57 interpolants.
[2020-05-30 20:33:23,675 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=190, Invalid=3002, Unknown=0, NotChecked=0, Total=3192
[2020-05-30 20:33:23,676 INFO  L87              Difference]: Start difference. First operand 9022 states and 10007 transitions. cyclomatic complexity: 1016 Second operand 57 states.
[2020-05-30 20:33:37,173 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:33:37,174 INFO  L93              Difference]: Finished difference Result 10869 states and 12295 transitions.
[2020-05-30 20:33:37,174 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 98 states. 
[2020-05-30 20:33:37,174 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 10869 states and 12295 transitions.
[2020-05-30 20:33:37,189 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:33:37,210 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 10869 states to 10765 states and 12173 transitions.
[2020-05-30 20:33:37,210 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1752
[2020-05-30 20:33:37,211 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1752
[2020-05-30 20:33:37,211 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 10765 states and 12173 transitions.
[2020-05-30 20:33:37,215 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:33:37,216 INFO  L728         BuchiCegarLoop]: Abstraction has 10765 states and 12173 transitions.
[2020-05-30 20:33:37,219 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 10765 states and 12173 transitions.
[2020-05-30 20:33:37,269 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 10765 to 10002.
[2020-05-30 20:33:37,269 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 10002 states.
[2020-05-30 20:33:37,280 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 10002 states to 10002 states and 11224 transitions.
[2020-05-30 20:33:37,280 INFO  L751         BuchiCegarLoop]: Abstraction has 10002 states and 11224 transitions.
[2020-05-30 20:33:37,280 INFO  L631         BuchiCegarLoop]: Abstraction has 10002 states and 11224 transitions.
[2020-05-30 20:33:37,280 INFO  L445         BuchiCegarLoop]: ======== Iteration 21============
[2020-05-30 20:33:37,280 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 10002 states and 11224 transitions.
[2020-05-30 20:33:37,290 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:33:37,290 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:33:37,290 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:33:37,291 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:33:37,291 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(refundee_s327 == user);
[L7]                       revert := revert_hold;
[L7]                       assume !(refundee_s327 == user);
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:33:37,295 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:33:37,295 INFO  L82        PathProgramCache]: Analyzing trace with hash 1843737038, now seen corresponding path program 1 times
[2020-05-30 20:33:37,295 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:33:37,325 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:33:37,702 INFO  L134       CoverageAnalysis]: Checked inductivity of 221 backedges. 21 proven. 22 refuted. 0 times theorem prover too weak. 178 trivial. 0 not checked.
[2020-05-30 20:33:37,702 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:33:37,702 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [38] total 38
[2020-05-30 20:33:37,702 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:33:37,702 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 39 interpolants.
[2020-05-30 20:33:37,703 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=103, Invalid=1379, Unknown=0, NotChecked=0, Total=1482
[2020-05-30 20:33:37,703 INFO  L87              Difference]: Start difference. First operand 10002 states and 11224 transitions. cyclomatic complexity: 1257 Second operand 39 states.
[2020-05-30 20:33:44,793 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:33:44,793 INFO  L93              Difference]: Finished difference Result 10105 states and 11446 transitions.
[2020-05-30 20:33:44,793 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 52 states. 
[2020-05-30 20:33:44,793 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 10105 states and 11446 transitions.
[2020-05-30 20:33:44,815 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:33:44,839 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 10105 states to 10105 states and 11446 transitions.
[2020-05-30 20:33:44,839 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1704
[2020-05-30 20:33:44,839 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1704
[2020-05-30 20:33:44,839 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 10105 states and 11446 transitions.
[2020-05-30 20:33:44,844 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:33:44,844 INFO  L728         BuchiCegarLoop]: Abstraction has 10105 states and 11446 transitions.
[2020-05-30 20:33:44,848 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 10105 states and 11446 transitions.
[2020-05-30 20:33:44,894 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 10105 to 10004.
[2020-05-30 20:33:44,894 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 10004 states.
[2020-05-30 20:33:44,906 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 10004 states to 10004 states and 11243 transitions.
[2020-05-30 20:33:44,906 INFO  L751         BuchiCegarLoop]: Abstraction has 10004 states and 11243 transitions.
[2020-05-30 20:33:44,906 INFO  L631         BuchiCegarLoop]: Abstraction has 10004 states and 11243 transitions.
[2020-05-30 20:33:44,906 INFO  L445         BuchiCegarLoop]: ======== Iteration 22============
[2020-05-30 20:33:44,906 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 10004 states and 11243 transitions.
[2020-05-30 20:33:44,916 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:33:44,916 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:33:44,916 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:33:44,917 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:33:44,917 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(payee_s255 == user);
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND FALSE  !(choice == 1)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:33:44,920 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:33:44,920 INFO  L82        PathProgramCache]: Analyzing trace with hash -965076430, now seen corresponding path program 2 times
[2020-05-30 20:33:44,921 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:33:44,940 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:33:45,456 INFO  L134       CoverageAnalysis]: Checked inductivity of 237 backedges. 11 proven. 98 refuted. 0 times theorem prover too weak. 128 trivial. 0 not checked.
[2020-05-30 20:33:45,456 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:33:45,456 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [54] total 54
[2020-05-30 20:33:45,456 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:33:45,457 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 55 interpolants.
[2020-05-30 20:33:45,457 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=223, Invalid=2747, Unknown=0, NotChecked=0, Total=2970
[2020-05-30 20:33:45,457 INFO  L87              Difference]: Start difference. First operand 10004 states and 11243 transitions. cyclomatic complexity: 1279 Second operand 55 states.
[2020-05-30 20:33:59,600 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:33:59,600 INFO  L93              Difference]: Finished difference Result 10245 states and 11575 transitions.
[2020-05-30 20:33:59,600 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 94 states. 
[2020-05-30 20:33:59,601 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 10245 states and 11575 transitions.
[2020-05-30 20:33:59,621 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:33:59,642 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 10245 states to 10245 states and 11575 transitions.
[2020-05-30 20:33:59,642 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1754
[2020-05-30 20:33:59,642 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1754
[2020-05-30 20:33:59,643 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 10245 states and 11575 transitions.
[2020-05-30 20:33:59,648 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:33:59,648 INFO  L728         BuchiCegarLoop]: Abstraction has 10245 states and 11575 transitions.
[2020-05-30 20:33:59,651 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 10245 states and 11575 transitions.
[2020-05-30 20:33:59,746 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 10245 to 10008.
[2020-05-30 20:33:59,746 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 10008 states.
[2020-05-30 20:33:59,757 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 10008 states to 10008 states and 11259 transitions.
[2020-05-30 20:33:59,757 INFO  L751         BuchiCegarLoop]: Abstraction has 10008 states and 11259 transitions.
[2020-05-30 20:33:59,757 INFO  L631         BuchiCegarLoop]: Abstraction has 10008 states and 11259 transitions.
[2020-05-30 20:33:59,757 INFO  L445         BuchiCegarLoop]: ======== Iteration 23============
[2020-05-30 20:33:59,757 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 10008 states and 11259 transitions.
[2020-05-30 20:33:59,767 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:33:59,767 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:33:59,767 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:33:59,769 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:33:59,769 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(payee_s255 == user);
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:33:59,773 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:33:59,774 INFO  L82        PathProgramCache]: Analyzing trace with hash 374785545, now seen corresponding path program 1 times
[2020-05-30 20:33:59,774 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:33:59,802 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:34:00,272 INFO  L134       CoverageAnalysis]: Checked inductivity of 249 backedges. 14 proven. 25 refuted. 0 times theorem prover too weak. 210 trivial. 0 not checked.
[2020-05-30 20:34:00,272 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:34:00,273 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [51] total 51
[2020-05-30 20:34:00,273 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:34:00,273 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 52 interpolants.
[2020-05-30 20:34:00,274 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=204, Invalid=2448, Unknown=0, NotChecked=0, Total=2652
[2020-05-30 20:34:00,274 INFO  L87              Difference]: Start difference. First operand 10008 states and 11259 transitions. cyclomatic complexity: 1293 Second operand 52 states.
[2020-05-30 20:34:10,719 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:34:10,719 INFO  L93              Difference]: Finished difference Result 10201 states and 11555 transitions.
[2020-05-30 20:34:10,719 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 73 states. 
[2020-05-30 20:34:10,719 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 10201 states and 11555 transitions.
[2020-05-30 20:34:10,742 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:34:10,811 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 10201 states to 9935 states and 11179 transitions.
[2020-05-30 20:34:10,811 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1738
[2020-05-30 20:34:10,812 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1738
[2020-05-30 20:34:10,812 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9935 states and 11179 transitions.
[2020-05-30 20:34:10,817 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:34:10,817 INFO  L728         BuchiCegarLoop]: Abstraction has 9935 states and 11179 transitions.
[2020-05-30 20:34:10,821 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9935 states and 11179 transitions.
[2020-05-30 20:34:10,866 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9935 to 9720.
[2020-05-30 20:34:10,866 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 9720 states.
[2020-05-30 20:34:10,876 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 9720 states to 9720 states and 10908 transitions.
[2020-05-30 20:34:10,877 INFO  L751         BuchiCegarLoop]: Abstraction has 9720 states and 10908 transitions.
[2020-05-30 20:34:10,877 INFO  L631         BuchiCegarLoop]: Abstraction has 9720 states and 10908 transitions.
[2020-05-30 20:34:10,877 INFO  L445         BuchiCegarLoop]: ======== Iteration 24============
[2020-05-30 20:34:10,877 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 9720 states and 10908 transitions.
[2020-05-30 20:34:10,886 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:34:10,886 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:34:10,886 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:34:10,887 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:34:10,887 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(refundee_s327 == user);
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND FALSE  !(choice == 1)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:34:10,903 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:34:10,903 INFO  L82        PathProgramCache]: Analyzing trace with hash -2004110879, now seen corresponding path program 1 times
[2020-05-30 20:34:10,904 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:34:10,915 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:34:10,992 INFO  L134       CoverageAnalysis]: Checked inductivity of 221 backedges. 1 proven. 0 refuted. 0 times theorem prover too weak. 220 trivial. 0 not checked.
[2020-05-30 20:34:10,992 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:34:10,992 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:34:10,992 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:34:10,993 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:34:10,993 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:34:10,993 INFO  L87              Difference]: Start difference. First operand 9720 states and 10908 transitions. cyclomatic complexity: 1228 Second operand 3 states.
[2020-05-30 20:34:11,016 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:34:11,016 INFO  L93              Difference]: Finished difference Result 9720 states and 10903 transitions.
[2020-05-30 20:34:11,016 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:34:11,016 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9720 states and 10903 transitions.
[2020-05-30 20:34:11,031 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:34:11,049 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9720 states to 9720 states and 10903 transitions.
[2020-05-30 20:34:11,049 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1694
[2020-05-30 20:34:11,050 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1694
[2020-05-30 20:34:11,050 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9720 states and 10903 transitions.
[2020-05-30 20:34:11,054 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:34:11,054 INFO  L728         BuchiCegarLoop]: Abstraction has 9720 states and 10903 transitions.
[2020-05-30 20:34:11,058 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9720 states and 10903 transitions.
[2020-05-30 20:34:11,100 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9720 to 9720.
[2020-05-30 20:34:11,101 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 9720 states.
[2020-05-30 20:34:11,111 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 9720 states to 9720 states and 10903 transitions.
[2020-05-30 20:34:11,111 INFO  L751         BuchiCegarLoop]: Abstraction has 9720 states and 10903 transitions.
[2020-05-30 20:34:11,111 INFO  L631         BuchiCegarLoop]: Abstraction has 9720 states and 10903 transitions.
[2020-05-30 20:34:11,111 INFO  L445         BuchiCegarLoop]: ======== Iteration 25============
[2020-05-30 20:34:11,111 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 9720 states and 10903 transitions.
[2020-05-30 20:34:11,120 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:34:11,120 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:34:11,120 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:34:11,121 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:34:11,121 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND FALSE  !(choice == 1)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:34:11,124 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:34:11,124 INFO  L82        PathProgramCache]: Analyzing trace with hash -708452546, now seen corresponding path program 1 times
[2020-05-30 20:34:11,125 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:34:11,143 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:34:11,503 INFO  L134       CoverageAnalysis]: Checked inductivity of 222 backedges. 62 proven. 33 refuted. 0 times theorem prover too weak. 127 trivial. 0 not checked.
[2020-05-30 20:34:11,504 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:34:11,504 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [44] total 44
[2020-05-30 20:34:11,504 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:34:11,504 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 45 interpolants.
[2020-05-30 20:34:11,504 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=112, Invalid=1868, Unknown=0, NotChecked=0, Total=1980
[2020-05-30 20:34:11,505 INFO  L87              Difference]: Start difference. First operand 9720 states and 10903 transitions. cyclomatic complexity: 1223 Second operand 45 states.
[2020-05-30 20:34:32,660 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:34:32,660 INFO  L93              Difference]: Finished difference Result 11104 states and 12718 transitions.
[2020-05-30 20:34:32,660 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 61 states. 
[2020-05-30 20:34:32,660 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 11104 states and 12718 transitions.
[2020-05-30 20:34:32,679 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:34:32,701 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 11104 states to 11104 states and 12716 transitions.
[2020-05-30 20:34:32,701 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1714
[2020-05-30 20:34:32,701 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1714
[2020-05-30 20:34:32,702 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 11104 states and 12716 transitions.
[2020-05-30 20:34:32,707 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:34:32,707 INFO  L728         BuchiCegarLoop]: Abstraction has 11104 states and 12716 transitions.
[2020-05-30 20:34:32,710 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 11104 states and 12716 transitions.
[2020-05-30 20:34:32,762 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 11104 to 10829.
[2020-05-30 20:34:32,762 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 10829 states.
[2020-05-30 20:34:32,776 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 10829 states to 10829 states and 12348 transitions.
[2020-05-30 20:34:32,776 INFO  L751         BuchiCegarLoop]: Abstraction has 10829 states and 12348 transitions.
[2020-05-30 20:34:32,776 INFO  L631         BuchiCegarLoop]: Abstraction has 10829 states and 12348 transitions.
[2020-05-30 20:34:32,776 INFO  L445         BuchiCegarLoop]: ======== Iteration 26============
[2020-05-30 20:34:32,776 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 10829 states and 12348 transitions.
[2020-05-30 20:34:32,786 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:34:32,786 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:34:32,786 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:34:32,787 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:34:32,787 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:34:32,791 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:34:32,791 INFO  L82        PathProgramCache]: Analyzing trace with hash 717332861, now seen corresponding path program 1 times
[2020-05-30 20:34:32,791 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:34:32,815 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:34:33,365 INFO  L134       CoverageAnalysis]: Checked inductivity of 222 backedges. 64 proven. 16 refuted. 0 times theorem prover too weak. 142 trivial. 0 not checked.
[2020-05-30 20:34:33,366 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:34:33,366 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [54] total 54
[2020-05-30 20:34:33,366 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:34:33,366 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 55 interpolants.
[2020-05-30 20:34:33,367 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=166, Invalid=2804, Unknown=0, NotChecked=0, Total=2970
[2020-05-30 20:34:33,367 INFO  L87              Difference]: Start difference. First operand 10829 states and 12348 transitions. cyclomatic complexity: 1569 Second operand 55 states.
[2020-05-30 20:34:47,828 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:34:47,828 INFO  L93              Difference]: Finished difference Result 11127 states and 12837 transitions.
[2020-05-30 20:34:47,828 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 69 states. 
[2020-05-30 20:34:47,829 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 11127 states and 12837 transitions.
[2020-05-30 20:34:47,854 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:34:47,882 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 11127 states to 11127 states and 12837 transitions.
[2020-05-30 20:34:47,882 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1738
[2020-05-30 20:34:47,882 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1738
[2020-05-30 20:34:47,882 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 11127 states and 12837 transitions.
[2020-05-30 20:34:47,888 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:34:47,888 INFO  L728         BuchiCegarLoop]: Abstraction has 11127 states and 12837 transitions.
[2020-05-30 20:34:47,892 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 11127 states and 12837 transitions.
[2020-05-30 20:34:47,947 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 11127 to 10891.
[2020-05-30 20:34:47,948 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 10891 states.
[2020-05-30 20:34:47,963 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 10891 states to 10891 states and 12489 transitions.
[2020-05-30 20:34:47,963 INFO  L751         BuchiCegarLoop]: Abstraction has 10891 states and 12489 transitions.
[2020-05-30 20:34:47,963 INFO  L631         BuchiCegarLoop]: Abstraction has 10891 states and 12489 transitions.
[2020-05-30 20:34:47,963 INFO  L445         BuchiCegarLoop]: ======== Iteration 27============
[2020-05-30 20:34:47,963 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 10891 states and 12489 transitions.
[2020-05-30 20:34:47,974 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:34:47,974 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:34:47,974 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:34:47,975 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:34:47,975 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(refundee_s327 == user);
[L7]                       revert := revert_hold;
[L7]                       assume !(refundee_s327 == user);
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(payee_s255 == user);
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND FALSE  !(choice == 1)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:34:47,979 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:34:47,979 INFO  L82        PathProgramCache]: Analyzing trace with hash -1375894656, now seen corresponding path program 1 times
[2020-05-30 20:34:47,979 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:34:48,002 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:34:48,580 INFO  L134       CoverageAnalysis]: Checked inductivity of 353 backedges. 28 proven. 47 refuted. 0 times theorem prover too weak. 278 trivial. 0 not checked.
[2020-05-30 20:34:48,580 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:34:48,580 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [42] total 42
[2020-05-30 20:34:48,580 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:34:48,581 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 43 interpolants.
[2020-05-30 20:34:48,581 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=127, Invalid=1679, Unknown=0, NotChecked=0, Total=1806
[2020-05-30 20:34:48,581 INFO  L87              Difference]: Start difference. First operand 10891 states and 12489 transitions. cyclomatic complexity: 1658 Second operand 43 states.
[2020-05-30 20:34:56,955 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:34:56,956 INFO  L93              Difference]: Finished difference Result 10979 states and 12644 transitions.
[2020-05-30 20:34:56,956 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 51 states. 
[2020-05-30 20:34:56,956 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 10979 states and 12644 transitions.
[2020-05-30 20:34:56,980 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:34:57,006 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 10979 states to 10969 states and 12614 transitions.
[2020-05-30 20:34:57,006 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1704
[2020-05-30 20:34:57,007 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1704
[2020-05-30 20:34:57,007 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 10969 states and 12614 transitions.
[2020-05-30 20:34:57,013 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:34:57,013 INFO  L728         BuchiCegarLoop]: Abstraction has 10969 states and 12614 transitions.
[2020-05-30 20:34:57,016 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 10969 states and 12614 transitions.
[2020-05-30 20:34:57,060 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 10969 to 10870.
[2020-05-30 20:34:57,060 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 10870 states.
[2020-05-30 20:34:57,074 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 10870 states to 10870 states and 12420 transitions.
[2020-05-30 20:34:57,074 INFO  L751         BuchiCegarLoop]: Abstraction has 10870 states and 12420 transitions.
[2020-05-30 20:34:57,074 INFO  L631         BuchiCegarLoop]: Abstraction has 10870 states and 12420 transitions.
[2020-05-30 20:34:57,074 INFO  L445         BuchiCegarLoop]: ======== Iteration 28============
[2020-05-30 20:34:57,074 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 10870 states and 12420 transitions.
[2020-05-30 20:34:57,084 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:34:57,084 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:34:57,084 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:34:57,085 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:34:57,086 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(refundee_s327 == user);
[L7]                       revert := revert_hold;
[L7]                       assume !(refundee_s327 == user);
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND FALSE  !(choice == 1)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:34:57,089 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:34:57,089 INFO  L82        PathProgramCache]: Analyzing trace with hash 96199156, now seen corresponding path program 1 times
[2020-05-30 20:34:57,089 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:34:57,131 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:34:57,714 INFO  L134       CoverageAnalysis]: Checked inductivity of 438 backedges. 28 proven. 89 refuted. 0 times theorem prover too weak. 321 trivial. 0 not checked.
[2020-05-30 20:34:57,714 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:34:57,714 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [47] total 47
[2020-05-30 20:34:57,714 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:34:57,715 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 48 interpolants.
[2020-05-30 20:34:57,715 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=122, Invalid=2134, Unknown=0, NotChecked=0, Total=2256
[2020-05-30 20:34:57,715 INFO  L87              Difference]: Start difference. First operand 10870 states and 12420 transitions. cyclomatic complexity: 1605 Second operand 48 states.
[2020-05-30 20:35:08,269 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:35:08,269 INFO  L93              Difference]: Finished difference Result 10937 states and 12493 transitions.
[2020-05-30 20:35:08,269 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 51 states. 
[2020-05-30 20:35:08,269 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 10937 states and 12493 transitions.
[2020-05-30 20:35:08,291 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:35:08,313 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 10937 states to 10937 states and 12491 transitions.
[2020-05-30 20:35:08,313 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1704
[2020-05-30 20:35:08,313 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1704
[2020-05-30 20:35:08,313 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 10937 states and 12491 transitions.
[2020-05-30 20:35:08,319 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:35:08,319 INFO  L728         BuchiCegarLoop]: Abstraction has 10937 states and 12491 transitions.
[2020-05-30 20:35:08,322 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 10937 states and 12491 transitions.
[2020-05-30 20:35:08,372 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 10937 to 10743.
[2020-05-30 20:35:08,372 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 10743 states.
[2020-05-30 20:35:08,386 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 10743 states to 10743 states and 12207 transitions.
[2020-05-30 20:35:08,386 INFO  L751         BuchiCegarLoop]: Abstraction has 10743 states and 12207 transitions.
[2020-05-30 20:35:08,386 INFO  L631         BuchiCegarLoop]: Abstraction has 10743 states and 12207 transitions.
[2020-05-30 20:35:08,386 INFO  L445         BuchiCegarLoop]: ======== Iteration 29============
[2020-05-30 20:35:08,386 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 10743 states and 12207 transitions.
[2020-05-30 20:35:08,396 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:35:08,396 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:35:08,396 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:35:08,397 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:35:08,397 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(payee_s255 == user);
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND FALSE  !(choice == 1)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:35:08,401 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:35:08,401 INFO  L82        PathProgramCache]: Analyzing trace with hash 1880484267, now seen corresponding path program 1 times
[2020-05-30 20:35:08,401 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:35:08,425 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:35:08,921 INFO  L134       CoverageAnalysis]: Checked inductivity of 343 backedges. 78 proven. 57 refuted. 0 times theorem prover too weak. 208 trivial. 0 not checked.
[2020-05-30 20:35:08,922 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:35:08,922 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [48] total 48
[2020-05-30 20:35:08,922 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:35:08,922 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 49 interpolants.
[2020-05-30 20:35:08,922 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=150, Invalid=2202, Unknown=0, NotChecked=0, Total=2352
[2020-05-30 20:35:08,923 INFO  L87              Difference]: Start difference. First operand 10743 states and 12207 transitions. cyclomatic complexity: 1509 Second operand 49 states.
[2020-05-30 20:35:29,236 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:35:29,236 INFO  L93              Difference]: Finished difference Result 11297 states and 12843 transitions.
[2020-05-30 20:35:29,236 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 66 states. 
[2020-05-30 20:35:29,236 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 11297 states and 12843 transitions.
[2020-05-30 20:35:29,258 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:35:29,280 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 11297 states to 11297 states and 12841 transitions.
[2020-05-30 20:35:29,280 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1710
[2020-05-30 20:35:29,281 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1710
[2020-05-30 20:35:29,281 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 11297 states and 12841 transitions.
[2020-05-30 20:35:29,286 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:35:29,286 INFO  L728         BuchiCegarLoop]: Abstraction has 11297 states and 12841 transitions.
[2020-05-30 20:35:29,290 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 11297 states and 12841 transitions.
[2020-05-30 20:35:29,338 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 11297 to 11101.
[2020-05-30 20:35:29,338 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 11101 states.
[2020-05-30 20:35:29,352 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 11101 states to 11101 states and 12607 transitions.
[2020-05-30 20:35:29,353 INFO  L751         BuchiCegarLoop]: Abstraction has 11101 states and 12607 transitions.
[2020-05-30 20:35:29,353 INFO  L631         BuchiCegarLoop]: Abstraction has 11101 states and 12607 transitions.
[2020-05-30 20:35:29,353 INFO  L445         BuchiCegarLoop]: ======== Iteration 30============
[2020-05-30 20:35:29,353 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 11101 states and 12607 transitions.
[2020-05-30 20:35:29,363 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:35:29,363 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:35:29,363 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:35:29,364 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:35:29,364 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(payee_s255 == user);
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND FALSE  !(choice == 1)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:35:29,368 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:35:29,368 INFO  L82        PathProgramCache]: Analyzing trace with hash -532093905, now seen corresponding path program 1 times
[2020-05-30 20:35:29,369 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:35:29,398 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:35:30,138 INFO  L134       CoverageAnalysis]: Checked inductivity of 354 backedges. 71 proven. 41 refuted. 0 times theorem prover too weak. 242 trivial. 0 not checked.
[2020-05-30 20:35:30,138 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:35:30,138 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [59] total 59
[2020-05-30 20:35:30,138 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:35:30,139 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 60 interpolants.
[2020-05-30 20:35:30,139 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=224, Invalid=3316, Unknown=0, NotChecked=0, Total=3540
[2020-05-30 20:35:30,139 INFO  L87              Difference]: Start difference. First operand 11101 states and 12607 transitions. cyclomatic complexity: 1552 Second operand 60 states.
[2020-05-30 20:35:45,324 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:35:45,324 INFO  L93              Difference]: Finished difference Result 11413 states and 13113 transitions.
[2020-05-30 20:35:45,324 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 71 states. 
[2020-05-30 20:35:45,324 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 11413 states and 13113 transitions.
[2020-05-30 20:35:45,395 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:35:45,420 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 11413 states to 11405 states and 13084 transitions.
[2020-05-30 20:35:45,420 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1738
[2020-05-30 20:35:45,420 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1738
[2020-05-30 20:35:45,420 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 11405 states and 13084 transitions.
[2020-05-30 20:35:45,426 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:35:45,427 INFO  L728         BuchiCegarLoop]: Abstraction has 11405 states and 13084 transitions.
[2020-05-30 20:35:45,430 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 11405 states and 13084 transitions.
[2020-05-30 20:35:45,481 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 11405 to 11163.
[2020-05-30 20:35:45,481 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 11163 states.
[2020-05-30 20:35:45,496 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 11163 states to 11163 states and 12739 transitions.
[2020-05-30 20:35:45,496 INFO  L751         BuchiCegarLoop]: Abstraction has 11163 states and 12739 transitions.
[2020-05-30 20:35:45,496 INFO  L631         BuchiCegarLoop]: Abstraction has 11163 states and 12739 transitions.
[2020-05-30 20:35:45,496 INFO  L445         BuchiCegarLoop]: ======== Iteration 31============
[2020-05-30 20:35:45,496 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 11163 states and 12739 transitions.
[2020-05-30 20:35:45,506 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:35:45,506 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:35:45,506 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:35:45,508 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:35:45,508 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(refundee_s327 == user);
[L7]                       revert := revert_hold;
[L7]                       assume !(refundee_s327 == user);
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(payee_s255 == user);
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:35:45,523 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:35:45,523 INFO  L82        PathProgramCache]: Analyzing trace with hash 1342459302, now seen corresponding path program 1 times
[2020-05-30 20:35:45,523 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:35:45,571 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:35:46,248 INFO  L134       CoverageAnalysis]: Checked inductivity of 570 backedges. 35 proven. 114 refuted. 0 times theorem prover too weak. 421 trivial. 0 not checked.
[2020-05-30 20:35:46,248 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:35:46,248 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [51] total 51
[2020-05-30 20:35:46,248 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:35:46,248 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 52 interpolants.
[2020-05-30 20:35:46,249 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=150, Invalid=2502, Unknown=0, NotChecked=0, Total=2652
[2020-05-30 20:35:46,249 INFO  L87              Difference]: Start difference. First operand 11163 states and 12739 transitions. cyclomatic complexity: 1632 Second operand 52 states.
[2020-05-30 20:35:54,902 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:35:54,902 INFO  L93              Difference]: Finished difference Result 9540 states and 10979 transitions.
[2020-05-30 20:35:54,902 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 52 states. 
[2020-05-30 20:35:54,902 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9540 states and 10979 transitions.
[2020-05-30 20:35:54,922 INFO  L131   ngComponentsAnalysis]: Automaton has 0 accepting balls. 0
[2020-05-30 20:35:54,922 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9540 states to 0 states and 0 transitions.
[2020-05-30 20:35:54,923 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 0
[2020-05-30 20:35:54,923 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 0
[2020-05-30 20:35:54,923 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 0 states and 0 transitions.
[2020-05-30 20:35:54,923 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:35:54,923 INFO  L728         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-05-30 20:35:54,923 INFO  L751         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-05-30 20:35:54,923 INFO  L631         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-05-30 20:35:54,923 INFO  L445         BuchiCegarLoop]: ======== Iteration 32============
[2020-05-30 20:35:54,923 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 0 states and 0 transitions.
[2020-05-30 20:35:54,923 INFO  L131   ngComponentsAnalysis]: Automaton has 0 accepting balls. 0
[2020-05-30 20:35:54,923 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is true
[2020-05-30 20:35:54,927 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer CFG 30.05 08:35:54 BasicIcfg
[2020-05-30 20:35:54,927 INFO  L132        PluginConnector]: ------------------------ END BuchiAutomizer----------------------------
[2020-05-30 20:35:54,927 INFO  L168              Benchmark]: Toolchain (without parser) took 242133.99 ms. Allocated memory was 514.9 MB in the beginning and 4.2 GB in the end (delta: 3.7 GB). Free memory was 458.8 MB in the beginning and 1.2 GB in the end (delta: -707.4 MB). Peak memory consumption was 2.9 GB. Max. memory is 15.3 GB.
[2020-05-30 20:35:54,929 INFO  L168              Benchmark]: Boogie PL CUP Parser took 0.12 ms. Allocated memory is still 514.9 MB. Free memory is still 468.3 MB. There was no memory consumed. Max. memory is 15.3 GB.
[2020-05-30 20:35:54,929 INFO  L168              Benchmark]: Boogie Preprocessor took 68.35 ms. Allocated memory is still 514.9 MB. Free memory was 458.8 MB in the beginning and 452.1 MB in the end (delta: 6.7 MB). Peak memory consumption was 6.7 MB. Max. memory is 15.3 GB.
[2020-05-30 20:35:54,930 INFO  L168              Benchmark]: UtopiaSpecLang took 43.22 ms. Allocated memory is still 514.9 MB. Free memory was 452.1 MB in the beginning and 446.7 MB in the end (delta: 5.4 MB). Peak memory consumption was 5.4 MB. Max. memory is 15.3 GB.
[2020-05-30 20:35:54,930 INFO  L168              Benchmark]: Boogie Printer took 10.00 ms. Allocated memory is still 514.9 MB. Free memory was 446.7 MB in the beginning and 445.3 MB in the end (delta: 1.4 MB). Peak memory consumption was 1.4 MB. Max. memory is 15.3 GB.
[2020-05-30 20:35:54,930 INFO  L168              Benchmark]: RCFGBuilder took 456.65 ms. Allocated memory is still 514.9 MB. Free memory was 445.3 MB in the beginning and 375.1 MB in the end (delta: 70.2 MB). Peak memory consumption was 70.2 MB. Max. memory is 15.3 GB.
[2020-05-30 20:35:54,931 INFO  L168              Benchmark]: UtopiaLTL2Aut took 40.18 ms. Allocated memory is still 514.9 MB. Free memory was 375.1 MB in the beginning and 370.6 MB in the end (delta: 4.5 MB). Peak memory consumption was 4.5 MB. Max. memory is 15.3 GB.
[2020-05-30 20:35:54,931 INFO  L168              Benchmark]: BÃ¼chi Program Product took 4477.11 ms. Allocated memory was 514.9 MB in the beginning and 1.3 GB in the end (delta: 788.0 MB). Free memory was 370.6 MB in the beginning and 585.5 MB in the end (delta: -214.9 MB). Peak memory consumption was 680.0 MB. Max. memory is 15.3 GB.
[2020-05-30 20:35:54,931 INFO  L168              Benchmark]: BlockEncodingV2 took 379.93 ms. Allocated memory is still 1.3 GB. Free memory was 585.5 MB in the beginning and 317.9 MB in the end (delta: 267.6 MB). Peak memory consumption was 267.6 MB. Max. memory is 15.3 GB.
[2020-05-30 20:35:54,932 INFO  L168              Benchmark]: BuchiAutomizer took 236655.82 ms. Allocated memory was 1.3 GB in the beginning and 4.2 GB in the end (delta: 2.9 GB). Free memory was 317.9 MB in the beginning and 1.2 GB in the end (delta: -848.3 MB). Peak memory consumption was 2.0 GB. Max. memory is 15.3 GB.
[2020-05-30 20:35:54,936 INFO  L337   ainManager$Toolchain]: #######################  End [Toolchain 1] #######################
 --- Results ---
 * Results from de.uni_freiburg.informatik.ultimate.plugins.blockencoding:
  - StatisticsResult: Initial Icfg
    12247 locations, 48204 edges
  - StatisticsResult: Encoded RCFG
    12023 locations, 46874 edges
 * Results from de.uni_freiburg.informatik.ultimate.core:
  - StatisticsResult: Toolchain Benchmarks
    Benchmark results are:
 * Boogie PL CUP Parser took 0.12 ms. Allocated memory is still 514.9 MB. Free memory is still 468.3 MB. There was no memory consumed. Max. memory is 15.3 GB.
 * Boogie Preprocessor took 68.35 ms. Allocated memory is still 514.9 MB. Free memory was 458.8 MB in the beginning and 452.1 MB in the end (delta: 6.7 MB). Peak memory consumption was 6.7 MB. Max. memory is 15.3 GB.
 * UtopiaSpecLang took 43.22 ms. Allocated memory is still 514.9 MB. Free memory was 452.1 MB in the beginning and 446.7 MB in the end (delta: 5.4 MB). Peak memory consumption was 5.4 MB. Max. memory is 15.3 GB.
 * Boogie Printer took 10.00 ms. Allocated memory is still 514.9 MB. Free memory was 446.7 MB in the beginning and 445.3 MB in the end (delta: 1.4 MB). Peak memory consumption was 1.4 MB. Max. memory is 15.3 GB.
 * RCFGBuilder took 456.65 ms. Allocated memory is still 514.9 MB. Free memory was 445.3 MB in the beginning and 375.1 MB in the end (delta: 70.2 MB). Peak memory consumption was 70.2 MB. Max. memory is 15.3 GB.
 * UtopiaLTL2Aut took 40.18 ms. Allocated memory is still 514.9 MB. Free memory was 375.1 MB in the beginning and 370.6 MB in the end (delta: 4.5 MB). Peak memory consumption was 4.5 MB. Max. memory is 15.3 GB.
 * BÃ¼chi Program Product took 4477.11 ms. Allocated memory was 514.9 MB in the beginning and 1.3 GB in the end (delta: 788.0 MB). Free memory was 370.6 MB in the beginning and 585.5 MB in the end (delta: -214.9 MB). Peak memory consumption was 680.0 MB. Max. memory is 15.3 GB.
 * BlockEncodingV2 took 379.93 ms. Allocated memory is still 1.3 GB. Free memory was 585.5 MB in the beginning and 317.9 MB in the end (delta: 267.6 MB). Peak memory consumption was 267.6 MB. Max. memory is 15.3 GB.
 * BuchiAutomizer took 236655.82 ms. Allocated memory was 1.3 GB in the beginning and 4.2 GB in the end (delta: 2.9 GB). Free memory was 317.9 MB in the beginning and 1.2 GB in the end (delta: -848.3 MB). Peak memory consumption was 2.0 GB. Max. memory is 15.3 GB.
 * Results from de.uni_freiburg.informatik.ultimate.buchiprogramproduct:
  - StatisticsResult: Initial property automaton
    8 locations, 27 edges
  - StatisticsResult: Initial RCFG
    1271 locations, 1642 edges
  - StatisticsResult: BuchiProgram size
    12247 locations, 48204 edges
 * Results from de.uni_freiburg.informatik.ultimate.plugins.generator.traceabstraction:
  - StatisticsResult: Constructed decomposition of program
    Your program was decomposed into 31 terminating modules (31 trivial, 0 deterministic, 0 nondeterministic). 31 modules have a trivial ranking function, the largest among these consists of 60 locations.
  - StatisticsResult: Timing statistics
    BÃ¼chiAutomizer plugin needed 236.6s and 32 iterations.  TraceHistogramMax:4. Analysis of lassos took 9.8s. Construction of modules took 170.2s. BÃ¼chi inclusion checks took 51.0s. Highest rank in rank-based complementation 0. Minimization of det autom 31. Minimization of nondet autom 0. Automata minimization 2.1s AutomataMinimizationTime, 30 MinimizatonAttempts, 7927 StatesRemovedByMinimization, 24 NontrivialMinimizations. Non-live state removal took 1.5s Buchi closure took 0.0s. Biggest automaton had 15325 states and ocurred in iteration 15.	Nontrivial modules had stage [0, 0, 0, 0, 0].	InterpolantCoveringCapabilityFinite: 0/0	InterpolantCoveringCapabilityBuchi: 0/0	HoareTripleCheckerStatistics: 188512 SDtfs, 341342 SDslu, 504988 SDs, 0 SdLazy, 2306579 SolverSat, 66794 SolverUnsat, 0 SolverUnknown, 0 SolverNotchecked, 170.2s Time	LassoAnalysisResults: nont0 unkn0 SFLI0 SFLT0 conc0 concLT0 SILN0 SILU31 SILI0 SILT0 lasso0 LassoPreprocessingBenchmarks: LassoTerminationAnalysisBenchmarks: not availableLassoTerminationAnalysisBenchmarks: LassoNonterminationAnalysisSatFixpoint: 0	LassoNonterminationAnalysisSatUnbounded: 0	LassoNonterminationAnalysisUnsat: 0	LassoNonterminationAnalysisUnknown: 0	LassoNonterminationAnalysisTime: 0.0s	
  - AllSpecificationsHoldResult: All specifications hold
    Buchi Automizer proved that the LTL property ( ( <>(success_deposit_RefundEscrow0) ) && ( <>(success_withdraw_(success_enableRefunds_RefundEscrow0)onditionalEscrow0) ) )&& ! ( ( []( (success_enableRefunds_RefundEscrow0) ==> ( <>(success_send__success0) ) ) )) holds
RESULT: Ultimate proved your program to be correct!
Received shutdown request...
