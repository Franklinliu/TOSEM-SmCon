This is Ultimate 0.1.24-9993c5c-m
[2020-05-30 20:28:31,211 INFO  L170        SettingsManager]: Resetting all preferences to default values...
[2020-05-30 20:28:31,212 INFO  L174        SettingsManager]: Resetting UltimateCore preferences to default values
[2020-05-30 20:28:31,221 INFO  L177        SettingsManager]: Ultimate Commandline Interface provides no preferences, ignoring...
[2020-05-30 20:28:31,222 INFO  L174        SettingsManager]: Resetting Boogie Preprocessor preferences to default values
[2020-05-30 20:28:31,223 INFO  L174        SettingsManager]: Resetting Boogie Procedure Inliner preferences to default values
[2020-05-30 20:28:31,224 INFO  L174        SettingsManager]: Resetting Abstract Interpretation preferences to default values
[2020-05-30 20:28:31,226 INFO  L174        SettingsManager]: Resetting LassoRanker preferences to default values
[2020-05-30 20:28:31,228 INFO  L174        SettingsManager]: Resetting Reaching Definitions preferences to default values
[2020-05-30 20:28:31,229 INFO  L174        SettingsManager]: Resetting SyntaxChecker preferences to default values
[2020-05-30 20:28:31,230 INFO  L177        SettingsManager]: BÃ¼chi Program Product provides no preferences, ignoring...
[2020-05-30 20:28:31,230 INFO  L174        SettingsManager]: Resetting LTL2Aut preferences to default values
[2020-05-30 20:28:31,231 INFO  L174        SettingsManager]: Resetting PEA to Boogie preferences to default values
[2020-05-30 20:28:31,232 INFO  L174        SettingsManager]: Resetting BlockEncodingV2 preferences to default values
[2020-05-30 20:28:31,234 INFO  L174        SettingsManager]: Resetting ChcToBoogie preferences to default values
[2020-05-30 20:28:31,235 INFO  L174        SettingsManager]: Resetting AutomataScriptInterpreter preferences to default values
[2020-05-30 20:28:31,235 INFO  L174        SettingsManager]: Resetting BuchiAutomizer preferences to default values
[2020-05-30 20:28:31,237 INFO  L174        SettingsManager]: Resetting CACSL2BoogieTranslator preferences to default values
[2020-05-30 20:28:31,238 INFO  L174        SettingsManager]: Resetting CodeCheck preferences to default values
[2020-05-30 20:28:31,240 INFO  L174        SettingsManager]: Resetting InvariantSynthesis preferences to default values
[2020-05-30 20:28:31,241 INFO  L174        SettingsManager]: Resetting RCFGBuilder preferences to default values
[2020-05-30 20:28:31,241 INFO  L174        SettingsManager]: Resetting TraceAbstraction preferences to default values
[2020-05-30 20:28:31,243 INFO  L177        SettingsManager]: TraceAbstractionConcurrent provides no preferences, ignoring...
[2020-05-30 20:28:31,243 INFO  L177        SettingsManager]: TraceAbstractionWithAFAs provides no preferences, ignoring...
[2020-05-30 20:28:31,243 INFO  L174        SettingsManager]: Resetting TreeAutomizer preferences to default values
[2020-05-30 20:28:31,244 INFO  L174        SettingsManager]: Resetting IcfgToChc preferences to default values
[2020-05-30 20:28:31,245 INFO  L174        SettingsManager]: Resetting IcfgTransformer preferences to default values
[2020-05-30 20:28:31,246 INFO  L177        SettingsManager]: ReqToTest provides no preferences, ignoring...
[2020-05-30 20:28:31,246 INFO  L174        SettingsManager]: Resetting UtopiaLiveness preferences to default values
[2020-05-30 20:28:31,246 INFO  L174        SettingsManager]: Resetting UtopiaLTL2Aut preferences to default values
[2020-05-30 20:28:31,246 INFO  L174        SettingsManager]: Resetting UtopiaSpecLang preferences to default values
[2020-05-30 20:28:31,247 INFO  L174        SettingsManager]: Resetting Boogie Printer preferences to default values
[2020-05-30 20:28:31,248 INFO  L174        SettingsManager]: Resetting ChcSmtPrinter preferences to default values
[2020-05-30 20:28:31,249 INFO  L174        SettingsManager]: Resetting ReqPrinter preferences to default values
[2020-05-30 20:28:31,250 INFO  L174        SettingsManager]: Resetting Witness Printer preferences to default values
[2020-05-30 20:28:31,251 INFO  L177        SettingsManager]: Boogie PL CUP Parser provides no preferences, ignoring...
[2020-05-30 20:28:31,251 INFO  L174        SettingsManager]: Resetting CDTParser preferences to default values
[2020-05-30 20:28:31,252 INFO  L177        SettingsManager]: AutomataScriptParser provides no preferences, ignoring...
[2020-05-30 20:28:31,252 INFO  L177        SettingsManager]: ReqParser provides no preferences, ignoring...
[2020-05-30 20:28:31,252 INFO  L174        SettingsManager]: Resetting SmtParser preferences to default values
[2020-05-30 20:28:31,253 INFO  L174        SettingsManager]: Resetting Witness Parser preferences to default values
[2020-05-30 20:28:31,254 INFO  L181        SettingsManager]: Finished resetting all preferences to default values...
[2020-05-30 20:28:31,254 INFO  L98         SettingsManager]: Beginning loading settings from /Users/jon/Documents/Research/masterUltimate/SmartPulse/settings.epf
[2020-05-30 20:28:31,263 INFO  L110        SettingsManager]: Loading preferences was successful
[2020-05-30 20:28:31,263 INFO  L112        SettingsManager]: Preferences different from defaults after loading the file:
[2020-05-30 20:28:31,264 INFO  L131        SettingsManager]: Preferences of LTL2Aut differ from their defaults:
[2020-05-30 20:28:31,264 INFO  L133        SettingsManager]:  * Read property from file=true
[2020-05-30 20:28:31,264 INFO  L133        SettingsManager]:  * Path to LTL*BA executable (LTL2BA, LTL3BA)=/Users/jon/Documents/Research/devUltimate/ltl2ba
[2020-05-30 20:28:31,264 INFO  L131        SettingsManager]: Preferences of BlockEncodingV2 differ from their defaults:
[2020-05-30 20:28:31,264 INFO  L133        SettingsManager]:  * Maximize final states=false
[2020-05-30 20:28:31,265 INFO  L133        SettingsManager]:  * Minimize states even if more edges are added than removed.=true
[2020-05-30 20:28:31,265 INFO  L133        SettingsManager]:  * Minimize states using LBE with the strategy=NONE
[2020-05-30 20:28:31,265 INFO  L131        SettingsManager]: Preferences of BuchiAutomizer differ from their defaults:
[2020-05-30 20:28:31,265 INFO  L133        SettingsManager]:  * Compute Interpolants along a Counterexample=Craig_TreeInterpolation
[2020-05-30 20:28:31,265 INFO  L133        SettingsManager]:  * Use old map elimination=false
[2020-05-30 20:28:31,265 INFO  L133        SettingsManager]:  * Try twofold refinement=false
[2020-05-30 20:28:31,265 INFO  L131        SettingsManager]: Preferences of CACSL2BoogieTranslator differ from their defaults:
[2020-05-30 20:28:31,265 INFO  L133        SettingsManager]:  * Check unreachability of error function in SV-COMP mode=false
[2020-05-30 20:28:31,265 INFO  L133        SettingsManager]:  * Overapproximate operations on floating types=true
[2020-05-30 20:28:31,266 INFO  L133        SettingsManager]:  * Check division by zero=IGNORE
[2020-05-30 20:28:31,266 INFO  L133        SettingsManager]:  * Pointer to allocated memory at dereference=ASSUME
[2020-05-30 20:28:31,266 INFO  L133        SettingsManager]:  * If two pointers are subtracted or compared they have the same base address=ASSUME
[2020-05-30 20:28:31,266 INFO  L133        SettingsManager]:  * Check array bounds for arrays that are off heap=ASSUME
[2020-05-30 20:28:31,266 INFO  L133        SettingsManager]:  * Check if freed pointer was valid=false
[2020-05-30 20:28:31,266 INFO  L133        SettingsManager]:  * Use constant arrays=true
[2020-05-30 20:28:31,266 INFO  L133        SettingsManager]:  * Pointer base address is valid at dereference=ASSUME
[2020-05-30 20:28:31,266 INFO  L131        SettingsManager]: Preferences of RCFGBuilder differ from their defaults:
[2020-05-30 20:28:31,266 INFO  L133        SettingsManager]:  * Size of a code block=SingleStatement
[2020-05-30 20:28:31,266 INFO  L133        SettingsManager]:  * SMT solver=Internal_SMTInterpol
[2020-05-30 20:28:31,285 INFO  L81    nceAwareModelManager]: Repository-Root is: /var/folders/t6/mxckf6w17qb907fknyrxnkyc0000gp/T
[2020-05-30 20:28:31,296 INFO  L259   ainManager$Toolchain]: [Toolchain 1]: Applicable parser(s) successfully (re)initialized
[2020-05-30 20:28:31,298 INFO  L215   ainManager$Toolchain]: [Toolchain 1]: Toolchain selected.
[2020-05-30 20:28:31,299 INFO  L271        PluginConnector]: Initializing Boogie PL CUP Parser...
[2020-05-30 20:28:31,299 INFO  L276        PluginConnector]: Boogie PL CUP Parser initialized
[2020-05-30 20:28:31,300 INFO  L430   ainManager$Toolchain]: [Toolchain 1]: Parsing single file: /Users/jon/Documents/Research/masterUltimate/benchmarks/evalBenchmarks/benchmarks/RefundEscrow/single-callback/L2-RefundEscrow.bpl
[2020-05-30 20:28:31,300 INFO  L111           BoogieParser]: Parsing: '/Users/jon/Documents/Research/masterUltimate/benchmarks/evalBenchmarks/benchmarks/RefundEscrow/single-callback/L2-RefundEscrow.bpl'
[2020-05-30 20:28:31,356 INFO  L297   ainManager$Toolchain]: ####################### [Toolchain 1] #######################
[2020-05-30 20:28:31,357 INFO  L131        ToolchainWalker]: Walking toolchain with 8 elements.
[2020-05-30 20:28:31,357 INFO  L113        PluginConnector]: ------------------------Boogie Preprocessor----------------------------
[2020-05-30 20:28:31,357 INFO  L271        PluginConnector]: Initializing Boogie Preprocessor...
[2020-05-30 20:28:31,357 INFO  L276        PluginConnector]: Boogie Preprocessor initialized
[2020-05-30 20:28:31,370 INFO  L185        PluginConnector]: Executing the observer EnsureBoogieModelObserver from plugin Boogie Preprocessor for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:28:31" (1/1) ...
[2020-05-30 20:28:31,371 INFO  L185        PluginConnector]: Executing the observer TypeChecker from plugin Boogie Preprocessor for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:28:31" (1/1) ...
[2020-05-30 20:28:31,393 INFO  L185        PluginConnector]: Executing the observer ConstExpander from plugin Boogie Preprocessor for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:28:31" (1/1) ...
[2020-05-30 20:28:31,393 INFO  L185        PluginConnector]: Executing the observer StructExpander from plugin Boogie Preprocessor for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:28:31" (1/1) ...
[2020-05-30 20:28:31,407 INFO  L185        PluginConnector]: Executing the observer UnstructureCode from plugin Boogie Preprocessor for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:28:31" (1/1) ...
[2020-05-30 20:28:31,416 INFO  L185        PluginConnector]: Executing the observer FunctionInliner from plugin Boogie Preprocessor for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:28:31" (1/1) ...
[2020-05-30 20:28:31,422 INFO  L185        PluginConnector]: Executing the observer BoogieSymbolTableConstructor from plugin Boogie Preprocessor for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:28:31" (1/1) ...
[2020-05-30 20:28:31,429 INFO  L132        PluginConnector]: ------------------------ END Boogie Preprocessor----------------------------
[2020-05-30 20:28:31,430 INFO  L113        PluginConnector]: ------------------------UtopiaSpecLang----------------------------
[2020-05-30 20:28:31,430 INFO  L271        PluginConnector]: Initializing UtopiaSpecLang...
[2020-05-30 20:28:31,432 INFO  L276        PluginConnector]: UtopiaSpecLang initialized
[2020-05-30 20:28:31,434 INFO  L185        PluginConnector]: Executing the observer UtopiaSpecLangObserver from plugin UtopiaSpecLang for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:28:31" (1/1) ...
[2020-05-30 20:28:31,446 INFO  L975   opiaSpecLangObserver]: Parsing LTLPlus Formula to AstNode: [](finished(RefundEscrow.close, (ben == RefundEscrow.beneficiary())) ==> <>(finished(send(from, to, amt), (to == ben && amt == fsum(RefundEscrow.deposit, 2)))))
[2020-05-30 20:28:31,452 INFO  L979   opiaSpecLangObserver]: Successfully lexed: [](finished(RefundEscrow.close, (ben == RefundEscrow.beneficiary())) ==> <>(finished(send(from, to, amt), (to == ben && amt == fsum(RefundEscrow.deposit, 2)))))
[2020-05-30 20:28:31,458 INFO  L981   opiaSpecLangObserver]: Successfully parsed: [](finished(RefundEscrow.close, (ben == RefundEscrow.beneficiary())) ==> <>(finished(send(from, to, amt), (to == ben && amt == fsum(RefundEscrow.deposit, 2)))))
[2020-05-30 20:28:31,461 INFO  L677   opiaSpecLangObserver]: Parsed call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msg.sender, msg.value);  to CallStatement[false,[VariableLHS[__beneficiary_RefundEscrow0,<LOCAL,close_RefundEscrow>]],beneficiary_RefundEscrow__success,[IdentifierExpression[this,<IMPLEMENTATION_INPARAM,close_RefundEscrow>],IdentifierExpression[msgsender_MSG,<IMPLEMENTATION_INPARAM,close_RefundEscrow>],IdentifierExpression[msgvalue_MSG,<IMPLEMENTATION_INPARAM,close_RefundEscrow>]]]
[2020-05-30 20:28:31,461 INFO  L658   opiaSpecLangObserver]: Parsed var __beneficiary_RefundEscrow0: int;  to VariableDeclaration[[VarList[BPL: /Users/jon/Documents/Research/masterUltimate/benchmarks/evalBenchmarks/benchmarks/RefundEscrow/single-callback/L2-RefundEscrow.bpl:7/0-7/4,[__beneficiary_RefundEscrow0],PrimitiveType[int],null]]]
[2020-05-30 20:28:31,462 INFO  L599   opiaSpecLangObserver]: Parsed ben==__beneficiary_RefundEscrow to BinaryExpression[COMPEQ,IdentifierExpression[ben,GLOBAL],IdentifierExpression[__beneficiary_RefundEscrow0,<LOCAL,close_RefundEscrow>]]
[2020-05-30 20:28:31,464 INFO  L599   opiaSpecLangObserver]: Parsed ( to==ben && amount==fsum_deposit_RefundEscrow_2_0 ) to BinaryExpression[LOGICAND,BinaryExpression[COMPEQ,IdentifierExpression[to,<IMPLEMENTATION_INPARAM,send__success>],IdentifierExpression[ben,GLOBAL]],BinaryExpression[COMPEQ,IdentifierExpression[amount,<IMPLEMENTATION_INPARAM,send__success>],IdentifierExpression[fsum_deposit_RefundEscrow_2_0,GLOBAL]]]
[2020-05-30 20:28:31,465 INFO  L968   opiaSpecLangObserver]: Compiling: [](finished(RefundEscrow.close, (ben == RefundEscrow.beneficiary())) ==> <>(finished(send(from, to, amt), (to == ben && amt == fsum(RefundEscrow.deposit, 2)))))
[2020-05-30 20:28:31,465 INFO  L970   opiaSpecLangObserver]: Compiled to ( []( AP(success_close_RefundEscrow0) ==> ( <>AP(success_send__success0) ) ) )
[2020-05-30 20:28:31,465 INFO  L975   opiaSpecLangObserver]: Parsing LTLPlus Formula to AstNode: <>(finished(RefundEscrow.deposit)) && <>(finished(RefundEscrow.beneficiaryWithdraw))
[2020-05-30 20:28:31,465 INFO  L979   opiaSpecLangObserver]: Successfully lexed: <>(finished(RefundEscrow.deposit)) && <>(finished(RefundEscrow.beneficiaryWithdraw))
[2020-05-30 20:28:31,465 INFO  L981   opiaSpecLangObserver]: Successfully parsed: <>(finished(RefundEscrow.deposit)) && <>(finished(RefundEscrow.beneficiaryWithdraw))
[2020-05-30 20:28:31,466 INFO  L968   opiaSpecLangObserver]: Compiling: <>(finished(RefundEscrow.deposit)) && <>(finished(RefundEscrow.beneficiaryWithdraw))
[2020-05-30 20:28:31,467 INFO  L970   opiaSpecLangObserver]: Compiled to ( ( <>AP(success_deposit_RefundEscrow0) ) && ( <>AP(success_beneficiaryWithdraw_RefundEscrow0) ) )
Executed UtopiaSpecLang
[2020-05-30 20:28:31,475 INFO  L202        PluginConnector]: Adding new model Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:28:31 PropertyContainer
[2020-05-30 20:28:31,475 INFO  L132        PluginConnector]: ------------------------ END UtopiaSpecLang----------------------------
[2020-05-30 20:28:31,476 INFO  L113        PluginConnector]: ------------------------Boogie Printer----------------------------
[2020-05-30 20:28:31,476 INFO  L271        PluginConnector]: Initializing Boogie Printer...
[2020-05-30 20:28:31,476 INFO  L276        PluginConnector]: Boogie Printer initialized
[2020-05-30 20:28:31,476 INFO  L185        PluginConnector]: Executing the observer BoogiePrinterObserver from plugin Boogie Printer for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:28:31" (1/2) ...
[2020-05-30 20:28:31,477 INFO  L116   oogiePrinterObserver]: File already exists and will be overwritten: /var/folders/t6/mxckf6w17qb907fknyrxnkyc0000gp/T/boogiePrinter.bpl
[2020-05-30 20:28:31,477 INFO  L120   oogiePrinterObserver]: Writing to file /var/folders/t6/mxckf6w17qb907fknyrxnkyc0000gp/T/boogiePrinter.bpl
[2020-05-30 20:28:31,487 INFO  L185        PluginConnector]: Executing the observer BoogiePrinterObserver from plugin Boogie Printer for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:28:31" (2/2) ...
[2020-05-30 20:28:31,487 INFO  L132        PluginConnector]: ------------------------ END Boogie Printer----------------------------
[2020-05-30 20:28:31,488 INFO  L113        PluginConnector]: ------------------------RCFGBuilder----------------------------
[2020-05-30 20:28:31,488 INFO  L271        PluginConnector]: Initializing RCFGBuilder...
[2020-05-30 20:28:31,488 INFO  L276        PluginConnector]: RCFGBuilder initialized
[2020-05-30 20:28:31,489 INFO  L185        PluginConnector]: Executing the observer RCFGBuilderObserver from plugin RCFGBuilder for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:28:31" (1/2) ...
[2020-05-30 20:28:31,531 INFO  L130     BoogieDeclarations]: Found specification of procedure FreshRefGenerator__success
[2020-05-30 20:28:31,531 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath_NoBaseCtor__success
[2020-05-30 20:28:31,531 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath
[2020-05-30 20:28:31,531 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath
[2020-05-30 20:28:31,531 INFO  L130     BoogieDeclarations]: Found specification of procedure sub_SafeMath__success
[2020-05-30 20:28:31,531 INFO  L130     BoogieDeclarations]: Found specification of procedure add_SafeMath__success
[2020-05-30 20:28:31,531 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary_NoBaseCtor__success
[2020-05-30 20:28:31,532 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary
[2020-05-30 20:28:31,532 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary
[2020-05-30 20:28:31,532 INFO  L130     BoogieDeclarations]: Found specification of procedure primary_Secondary
[2020-05-30 20:28:31,532 INFO  L138     BoogieDeclarations]: Found implementation of procedure primary_Secondary
[2020-05-30 20:28:31,532 INFO  L130     BoogieDeclarations]: Found specification of procedure transferPrimary_Secondary
[2020-05-30 20:28:31,532 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferPrimary_Secondary
[2020-05-30 20:28:31,533 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow_NoBaseCtor__success
[2020-05-30 20:28:31,533 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow
[2020-05-30 20:28:31,533 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow
[2020-05-30 20:28:31,533 INFO  L130     BoogieDeclarations]: Found specification of procedure depositsOf_Escrow
[2020-05-30 20:28:31,533 INFO  L138     BoogieDeclarations]: Found implementation of procedure depositsOf_Escrow
[2020-05-30 20:28:31,533 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow
[2020-05-30 20:28:31,533 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow
[2020-05-30 20:28:31,533 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow_Escrow__success
[2020-05-30 20:28:31,533 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow
[2020-05-30 20:28:31,533 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow
[2020-05-30 20:28:31,533 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow_Escrow__success
[2020-05-30 20:28:31,533 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success
[2020-05-30 20:28:31,533 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow
[2020-05-30 20:28:31,533 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow
[2020-05-30 20:28:31,534 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawalAllowed_ConditionalEscrow
[2020-05-30 20:28:31,534 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_ConditionalEscrow
[2020-05-30 20:28:31,534 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_ConditionalEscrow
[2020-05-30 20:28:31,534 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow_NoBaseCtor__success
[2020-05-30 20:28:31,534 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow
[2020-05-30 20:28:31,534 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow
[2020-05-30 20:28:31,534 INFO  L130     BoogieDeclarations]: Found specification of procedure state_RefundEscrow
[2020-05-30 20:28:31,534 INFO  L138     BoogieDeclarations]: Found implementation of procedure state_RefundEscrow
[2020-05-30 20:28:31,534 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiary_RefundEscrow
[2020-05-30 20:28:31,534 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiary_RefundEscrow
[2020-05-30 20:28:31,534 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_RefundEscrow
[2020-05-30 20:28:31,534 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_RefundEscrow
[2020-05-30 20:28:31,535 INFO  L130     BoogieDeclarations]: Found specification of procedure close_RefundEscrow
[2020-05-30 20:28:31,535 INFO  L138     BoogieDeclarations]: Found implementation of procedure close_RefundEscrow
[2020-05-30 20:28:31,535 INFO  L130     BoogieDeclarations]: Found specification of procedure enableRefunds_RefundEscrow
[2020-05-30 20:28:31,535 INFO  L138     BoogieDeclarations]: Found implementation of procedure enableRefunds_RefundEscrow
[2020-05-30 20:28:31,535 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiaryWithdraw_RefundEscrow
[2020-05-30 20:28:31,535 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiaryWithdraw_RefundEscrow
[2020-05-30 20:28:31,535 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawalAllowed_RefundEscrow
[2020-05-30 20:28:31,535 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdrawalAllowed_RefundEscrow
[2020-05-30 20:28:31,535 INFO  L130     BoogieDeclarations]: Found specification of procedure FallbackDispatch__success
[2020-05-30 20:28:31,535 INFO  L130     BoogieDeclarations]: Found specification of procedure Fallback_UnknownType__success
[2020-05-30 20:28:31,536 INFO  L130     BoogieDeclarations]: Found specification of procedure send__success
[2020-05-30 20:28:31,536 INFO  L130     BoogieDeclarations]: Found specification of procedure onlyPrimary_pre__success
[2020-05-30 20:28:31,536 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_SafeMath
[2020-05-30 20:28:31,536 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_SafeMath
[2020-05-30 20:28:31,536 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_Secondary
[2020-05-30 20:28:31,536 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_Secondary
[2020-05-30 20:28:31,536 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_Escrow
[2020-05-30 20:28:31,536 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_Escrow
[2020-05-30 20:28:31,536 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_ConditionalEscrow
[2020-05-30 20:28:31,536 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_ConditionalEscrow
[2020-05-30 20:28:31,536 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_RefundEscrow
[2020-05-30 20:28:31,536 INFO  L130     BoogieDeclarations]: Found specification of procedure main
[2020-05-30 20:28:31,536 INFO  L130     BoogieDeclarations]: Found specification of procedure FreshRefGenerator__fail
[2020-05-30 20:28:31,537 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath_NoBaseCtor__fail
[2020-05-30 20:28:31,537 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath__success
[2020-05-30 20:28:31,537 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath__fail
[2020-05-30 20:28:31,537 INFO  L130     BoogieDeclarations]: Found specification of procedure sub_SafeMath__fail
[2020-05-30 20:28:31,537 INFO  L130     BoogieDeclarations]: Found specification of procedure add_SafeMath__fail
[2020-05-30 20:28:31,537 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary_NoBaseCtor__fail
[2020-05-30 20:28:31,537 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary__success
[2020-05-30 20:28:31,537 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary__fail
[2020-05-30 20:28:31,537 INFO  L130     BoogieDeclarations]: Found specification of procedure primary_Secondary__success
[2020-05-30 20:28:31,538 INFO  L130     BoogieDeclarations]: Found specification of procedure primary_Secondary__fail
[2020-05-30 20:28:31,538 INFO  L130     BoogieDeclarations]: Found specification of procedure transferPrimary_Secondary__success
[2020-05-30 20:28:31,538 INFO  L130     BoogieDeclarations]: Found specification of procedure transferPrimary_Secondary__fail
[2020-05-30 20:28:31,538 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow_NoBaseCtor__fail
[2020-05-30 20:28:31,538 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow__success
[2020-05-30 20:28:31,538 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow__fail
[2020-05-30 20:28:31,538 INFO  L130     BoogieDeclarations]: Found specification of procedure depositsOf_Escrow__success
[2020-05-30 20:28:31,538 INFO  L130     BoogieDeclarations]: Found specification of procedure depositsOf_Escrow__fail
[2020-05-30 20:28:31,539 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow__success
[2020-05-30 20:28:31,539 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow__fail
[2020-05-30 20:28:31,539 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow_Escrow__fail
[2020-05-30 20:28:31,539 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow__success
[2020-05-30 20:28:31,539 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow__fail
[2020-05-30 20:28:31,539 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow_Escrow__fail
[2020-05-30 20:28:31,539 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow_NoBaseCtor__fail
[2020-05-30 20:28:31,540 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow__success
[2020-05-30 20:28:31,540 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow__fail
[2020-05-30 20:28:31,540 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_ConditionalEscrow__success
[2020-05-30 20:28:31,540 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_ConditionalEscrow__fail
[2020-05-30 20:28:31,540 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow_NoBaseCtor__fail
[2020-05-30 20:28:31,540 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow__success
[2020-05-30 20:28:31,540 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow__fail
[2020-05-30 20:28:31,540 INFO  L130     BoogieDeclarations]: Found specification of procedure state_RefundEscrow__success
[2020-05-30 20:28:31,541 INFO  L130     BoogieDeclarations]: Found specification of procedure state_RefundEscrow__fail
[2020-05-30 20:28:31,541 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiary_RefundEscrow__success
[2020-05-30 20:28:31,541 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiary_RefundEscrow__fail
[2020-05-30 20:28:31,541 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_RefundEscrow__success
[2020-05-30 20:28:31,541 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_RefundEscrow__fail
[2020-05-30 20:28:31,541 INFO  L130     BoogieDeclarations]: Found specification of procedure close_RefundEscrow__success
[2020-05-30 20:28:31,541 INFO  L130     BoogieDeclarations]: Found specification of procedure close_RefundEscrow__fail
[2020-05-30 20:28:31,541 INFO  L130     BoogieDeclarations]: Found specification of procedure enableRefunds_RefundEscrow__success
[2020-05-30 20:28:31,542 INFO  L130     BoogieDeclarations]: Found specification of procedure enableRefunds_RefundEscrow__fail
[2020-05-30 20:28:31,542 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiaryWithdraw_RefundEscrow__success
[2020-05-30 20:28:31,542 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiaryWithdraw_RefundEscrow__fail
[2020-05-30 20:28:31,542 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawalAllowed_RefundEscrow__success
[2020-05-30 20:28:31,542 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawalAllowed_RefundEscrow__fail
[2020-05-30 20:28:31,542 INFO  L130     BoogieDeclarations]: Found specification of procedure FallbackDispatch__fail
[2020-05-30 20:28:31,542 INFO  L130     BoogieDeclarations]: Found specification of procedure Fallback_UnknownType__fail
[2020-05-30 20:28:31,543 INFO  L130     BoogieDeclarations]: Found specification of procedure send__fail
[2020-05-30 20:28:31,543 INFO  L130     BoogieDeclarations]: Found specification of procedure onlyPrimary_pre__fail
[2020-05-30 20:28:31,543 INFO  L138     BoogieDeclarations]: Found implementation of procedure FreshRefGenerator__fail
[2020-05-30 20:28:31,543 INFO  L138     BoogieDeclarations]: Found implementation of procedure FreshRefGenerator__success
[2020-05-30 20:28:31,543 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath_NoBaseCtor__fail
[2020-05-30 20:28:31,543 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath_NoBaseCtor__success
[2020-05-30 20:28:31,543 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath__fail
[2020-05-30 20:28:31,544 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath__success
[2020-05-30 20:28:31,544 INFO  L138     BoogieDeclarations]: Found implementation of procedure sub_SafeMath__fail
[2020-05-30 20:28:31,544 INFO  L138     BoogieDeclarations]: Found implementation of procedure sub_SafeMath__success
[2020-05-30 20:28:31,544 INFO  L138     BoogieDeclarations]: Found implementation of procedure add_SafeMath__fail
[2020-05-30 20:28:31,544 INFO  L138     BoogieDeclarations]: Found implementation of procedure add_SafeMath__success
[2020-05-30 20:28:31,544 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary_NoBaseCtor__fail
[2020-05-30 20:28:31,544 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary_NoBaseCtor__success
[2020-05-30 20:28:31,544 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary__fail
[2020-05-30 20:28:31,545 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary__success
[2020-05-30 20:28:31,545 INFO  L138     BoogieDeclarations]: Found implementation of procedure primary_Secondary__fail
[2020-05-30 20:28:31,545 INFO  L138     BoogieDeclarations]: Found implementation of procedure primary_Secondary__success
[2020-05-30 20:28:31,545 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferPrimary_Secondary__fail
[2020-05-30 20:28:31,545 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferPrimary_Secondary__success
[2020-05-30 20:28:31,545 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow_NoBaseCtor__fail
[2020-05-30 20:28:31,545 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow_NoBaseCtor__success
[2020-05-30 20:28:31,545 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow__fail
[2020-05-30 20:28:31,545 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow__success
[2020-05-30 20:28:31,546 INFO  L138     BoogieDeclarations]: Found implementation of procedure depositsOf_Escrow__fail
[2020-05-30 20:28:31,546 INFO  L138     BoogieDeclarations]: Found implementation of procedure depositsOf_Escrow__success
[2020-05-30 20:28:31,546 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow__fail
[2020-05-30 20:28:31,546 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow__success
[2020-05-30 20:28:31,546 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow_Escrow__fail
[2020-05-30 20:28:31,546 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow_Escrow__success
[2020-05-30 20:28:31,546 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow__fail
[2020-05-30 20:28:31,546 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow__success
[2020-05-30 20:28:31,547 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow_Escrow__fail
[2020-05-30 20:28:31,547 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow_Escrow__success
[2020-05-30 20:28:31,547 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow_NoBaseCtor__fail
[2020-05-30 20:28:31,547 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success
[2020-05-30 20:28:31,547 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow__fail
[2020-05-30 20:28:31,547 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow__success
[2020-05-30 20:28:31,547 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_ConditionalEscrow__fail
[2020-05-30 20:28:31,547 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_ConditionalEscrow__success
[2020-05-30 20:28:31,547 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow_NoBaseCtor__fail
[2020-05-30 20:28:31,547 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow_NoBaseCtor__success
[2020-05-30 20:28:31,547 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow__fail
[2020-05-30 20:28:31,547 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow__success
[2020-05-30 20:28:31,547 INFO  L138     BoogieDeclarations]: Found implementation of procedure state_RefundEscrow__fail
[2020-05-30 20:28:31,547 INFO  L138     BoogieDeclarations]: Found implementation of procedure state_RefundEscrow__success
[2020-05-30 20:28:31,547 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiary_RefundEscrow__fail
[2020-05-30 20:28:31,548 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiary_RefundEscrow__success
[2020-05-30 20:28:31,548 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_RefundEscrow__fail
[2020-05-30 20:28:31,548 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_RefundEscrow__success
[2020-05-30 20:28:31,548 INFO  L138     BoogieDeclarations]: Found implementation of procedure close_RefundEscrow__fail
[2020-05-30 20:28:31,548 INFO  L138     BoogieDeclarations]: Found implementation of procedure close_RefundEscrow__success
[2020-05-30 20:28:31,548 INFO  L138     BoogieDeclarations]: Found implementation of procedure enableRefunds_RefundEscrow__fail
[2020-05-30 20:28:31,548 INFO  L138     BoogieDeclarations]: Found implementation of procedure enableRefunds_RefundEscrow__success
[2020-05-30 20:28:31,548 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiaryWithdraw_RefundEscrow__fail
[2020-05-30 20:28:31,548 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiaryWithdraw_RefundEscrow__success
[2020-05-30 20:28:31,548 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdrawalAllowed_RefundEscrow__fail
[2020-05-30 20:28:31,548 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdrawalAllowed_RefundEscrow__success
[2020-05-30 20:28:31,548 INFO  L138     BoogieDeclarations]: Found implementation of procedure FallbackDispatch__fail
[2020-05-30 20:28:31,548 INFO  L138     BoogieDeclarations]: Found implementation of procedure FallbackDispatch__success
[2020-05-30 20:28:31,548 INFO  L138     BoogieDeclarations]: Found implementation of procedure Fallback_UnknownType__fail
[2020-05-30 20:28:31,548 INFO  L138     BoogieDeclarations]: Found implementation of procedure Fallback_UnknownType__success
[2020-05-30 20:28:31,548 INFO  L138     BoogieDeclarations]: Found implementation of procedure send__fail
[2020-05-30 20:28:31,549 INFO  L138     BoogieDeclarations]: Found implementation of procedure send__success
[2020-05-30 20:28:31,549 INFO  L138     BoogieDeclarations]: Found implementation of procedure onlyPrimary_pre__fail
[2020-05-30 20:28:31,549 INFO  L138     BoogieDeclarations]: Found implementation of procedure onlyPrimary_pre__success
[2020-05-30 20:28:31,549 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_SafeMath
[2020-05-30 20:28:31,549 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_SafeMath
[2020-05-30 20:28:31,549 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_Secondary
[2020-05-30 20:28:31,549 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_Secondary
[2020-05-30 20:28:31,549 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_Escrow
[2020-05-30 20:28:31,549 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_Escrow
[2020-05-30 20:28:31,549 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_ConditionalEscrow
[2020-05-30 20:28:31,549 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_ConditionalEscrow
[2020-05-30 20:28:31,549 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_RefundEscrow
[2020-05-30 20:28:31,549 INFO  L138     BoogieDeclarations]: Found implementation of procedure main
[2020-05-30 20:28:31,549 INFO  L130     BoogieDeclarations]: Found specification of procedure ULTIMATE.start
[2020-05-30 20:28:31,549 INFO  L138     BoogieDeclarations]: Found implementation of procedure ULTIMATE.start
[2020-05-30 20:28:31,669 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 20:28:31,682 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 20:28:31,835 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 20:28:32,022 INFO  L281             CfgBuilder]: Using the 1 location(s) as analysis (start of procedure ULTIMATE.start)
[2020-05-30 20:28:32,022 INFO  L286             CfgBuilder]: Removed 5 assue(true) statements.
[2020-05-30 20:28:32,023 INFO  L202        PluginConnector]: Adding new model L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 08:28:32 BoogieIcfgContainer
[2020-05-30 20:28:32,024 INFO  L185        PluginConnector]: Executing the observer RCFGBuilderObserver from plugin RCFGBuilder for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:28:31" (2/2) ...
[2020-05-30 20:28:32,024 INFO  L85     RCFGBuilderObserver]: No WrapperNode. Let Ultimate process with next node
[2020-05-30 20:28:32,024 INFO  L205        PluginConnector]: Invalid model from RCFGBuilder for observer de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder.RCFGBuilderObserver@4aab7c18 and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 08:28:32, skipping insertion in model container
[2020-05-30 20:28:32,024 INFO  L132        PluginConnector]: ------------------------ END RCFGBuilder----------------------------
[2020-05-30 20:28:32,024 INFO  L113        PluginConnector]: ------------------------UtopiaLTL2Aut----------------------------
[2020-05-30 20:28:32,024 INFO  L271        PluginConnector]: Initializing UtopiaLTL2Aut...
[2020-05-30 20:28:32,025 INFO  L276        PluginConnector]: UtopiaLTL2Aut initialized
[2020-05-30 20:28:32,026 INFO  L185        PluginConnector]: Executing the observer UtopiaLTL2AutObserver from plugin UtopiaLTL2Aut for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:28:31" (1/3) ...
[2020-05-30 20:28:32,026 INFO  L205        PluginConnector]: Invalid model from UtopiaLTL2Aut for observer edu.utexas.cs.utopia.ltl2aut.UtopiaLTL2AutObserver@1a6eac0b and model type Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 08:28:32, skipping insertion in model container
[2020-05-30 20:28:32,026 INFO  L185        PluginConnector]: Executing the observer UtopiaLTL2AutObserver from plugin UtopiaLTL2Aut for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:28:31" (2/3) ...
No working directory specified, using /Users/jon/Documents/Research/devUltimate/ltl2ba
Starting monitored process 1 with /Users/jon/Documents/Research/devUltimate/ltl2ba -f  ( ( <>a ) && ( <>b ) ) && ! ( ( [] ( c -> ( <>d ) ) ) )  (exit command is null, workingDir is null)
[2020-05-30 20:28:32,068 INFO  L202        PluginConnector]: Adding new model Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 08:28:32 NWAContainer
[2020-05-30 20:28:32,068 INFO  L132        PluginConnector]: ------------------------ END UtopiaLTL2Aut----------------------------
[2020-05-30 20:28:32,068 INFO  L113        PluginConnector]: ------------------------BÃ¼chi Program Product----------------------------
[2020-05-30 20:28:32,068 INFO  L271        PluginConnector]: Initializing BÃ¼chi Program Product...
[2020-05-30 20:28:32,069 INFO  L276        PluginConnector]: BÃ¼chi Program Product initialized
[2020-05-30 20:28:32,069 INFO  L185        PluginConnector]: Executing the observer BuchiProductObserver from plugin BÃ¼chi Program Product for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 08:28:32" (3/4) ...
[2020-05-30 20:28:32,070 INFO  L205        PluginConnector]: Invalid model from BÃ¼chi Program Product for observer de.uni_freiburg.informatik.ultimate.buchiprogramproduct.BuchiProductObserver@6182f4f1 and model type LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 08:28:32, skipping insertion in model container
[2020-05-30 20:28:32,070 INFO  L185        PluginConnector]: Executing the observer BuchiProductObserver from plugin BÃ¼chi Program Product for "Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 08:28:32" (4/4) ...
[2020-05-30 20:28:32,072 INFO  L104   BuchiProductObserver]: Initial property automaton 8 locations, 27 edges
[2020-05-30 20:28:32,075 INFO  L110   BuchiProductObserver]: Initial RCFG 1570 locations, 2187 edges
[2020-05-30 20:28:32,075 INFO  L93    BuchiProductObserver]: Beginning generation of product automaton
[2020-05-30 20:28:32,084 INFO  L136       ProductGenerator]: The program has no step specification, so we assume maximum atomicity
[2020-05-30 20:28:37,500 INFO  L97    BuchiProductObserver]: Finished generation of product automaton successfully
[2020-05-30 20:28:37,522 INFO  L110   BuchiProductObserver]: BuchiProgram size 15391 locations, 64141 edges
[2020-05-30 20:28:37,522 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 08:28:37 BoogieIcfgContainer
[2020-05-30 20:28:37,522 INFO  L132        PluginConnector]: ------------------------ END BÃ¼chi Program Product----------------------------
[2020-05-30 20:28:37,523 INFO  L113        PluginConnector]: ------------------------BlockEncodingV2----------------------------
[2020-05-30 20:28:37,523 INFO  L271        PluginConnector]: Initializing BlockEncodingV2...
[2020-05-30 20:28:37,524 INFO  L276        PluginConnector]: BlockEncodingV2 initialized
[2020-05-30 20:28:37,525 INFO  L185        PluginConnector]: Executing the observer BlockEncodingObserver from plugin BlockEncodingV2 for "LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 08:28:37" (1/1) ...
[2020-05-30 20:28:37,969 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:28:37,969 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:28:37,970 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:28:37,970 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:28:37,970 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:28:37,970 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:28:37,970 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:28:37,970 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:28:37,970 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:28:37,970 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:28:37,970 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:28:37,971 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:28:37,971 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:28:37,971 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:28:37,971 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:28:37,971 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:28:37,972 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:28:37,972 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:28:37,973 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,974 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,974 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,974 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,974 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,974 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,975 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:28:37,975 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:28:37,975 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:28:37,976 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:28:37,976 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:28:37,976 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:28:37,976 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,976 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,977 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,977 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,977 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,977 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,979 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,980 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,980 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,980 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,980 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,980 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,981 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,981 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,981 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,981 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,981 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,981 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,982 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,983 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,983 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,983 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,983 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,983 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,987 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,987 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,987 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,987 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,987 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:37,987 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:38,011 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:38,012 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:38,012 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:38,012 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:38,012 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:38,012 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:28:38,044 INFO  L313           BlockEncoder]: Initial Icfg 15391 locations, 64141 edges
[2020-05-30 20:28:38,044 INFO  L258           BlockEncoder]: Using Remove infeasible edges
[2020-05-30 20:28:38,045 INFO  L270           BlockEncoder]: Using Minimize states even if more edges are added than removed.=true
[2020-05-30 20:28:38,045 INFO  L296           BlockEncoder]: Using Remove sink states
[2020-05-30 20:28:38,045 INFO  L171           BlockEncoder]: Using Apply optimizations until nothing changes=true
[2020-05-30 20:28:38,079 INFO  L70    emoveInfeasibleEdges]: Removed 764 edges and 52 locations because of local infeasibility
[2020-05-30 20:28:38,100 INFO  L70        RemoveSinkStates]: Removed 288 edges and 84 locations by removing sink states
[2020-05-30 20:28:38,144 INFO  L70    emoveInfeasibleEdges]: Removed 0 edges and 0 locations because of local infeasibility
[2020-05-30 20:28:38,158 INFO  L70        RemoveSinkStates]: Removed 0 edges and 0 locations by removing sink states
[2020-05-30 20:28:38,173 INFO  L237           BlockEncoder]: Using Create parallel compositions if possible
[2020-05-30 20:28:38,173 INFO  L66        ParallelComposer]: Creating parallel compositions
[2020-05-30 20:28:38,186 INFO  L313           BlockEncoder]: Encoded RCFG 15167 locations, 62811 edges
[2020-05-30 20:28:38,186 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.blockencoding CFG 30.05 08:28:38 BasicIcfg
[2020-05-30 20:28:38,187 INFO  L132        PluginConnector]: ------------------------ END BlockEncodingV2----------------------------
[2020-05-30 20:28:38,187 INFO  L113        PluginConnector]: ------------------------BuchiAutomizer----------------------------
[2020-05-30 20:28:38,187 INFO  L271        PluginConnector]: Initializing BuchiAutomizer...
[2020-05-30 20:28:38,189 INFO  L276        PluginConnector]: BuchiAutomizer initialized
[2020-05-30 20:28:38,189 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:28:38,189 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:28:31" (1/6) ...
[2020-05-30 20:28:38,190 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@2608d5c2 and model type L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 30.05 08:28:38, skipping insertion in model container
[2020-05-30 20:28:38,190 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:28:38,191 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:28:31" (2/6) ...
[2020-05-30 20:28:38,191 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@2608d5c2 and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 30.05 08:28:38, skipping insertion in model container
[2020-05-30 20:28:38,191 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:28:38,191 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 08:28:32" (3/6) ...
[2020-05-30 20:28:38,191 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@2608d5c2 and model type L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer CFG 30.05 08:28:38, skipping insertion in model container
[2020-05-30 20:28:38,191 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:28:38,191 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 08:28:32" (4/6) ...
[2020-05-30 20:28:38,191 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@2608d5c2 and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 30.05 08:28:38, skipping insertion in model container
[2020-05-30 20:28:38,191 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:28:38,192 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 08:28:37" (5/6) ...
[2020-05-30 20:28:38,192 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@2608d5c2 and model type LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer OTHER 30.05 08:28:38, skipping insertion in model container
[2020-05-30 20:28:38,192 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:28:38,192 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.blockencoding CFG 30.05 08:28:38" (6/6) ...
[2020-05-30 20:28:38,193 INFO  L404   chiAutomizerObserver]: Analyzing ICFG L2-RefundEscrow.bpl_BEv2
[2020-05-30 20:28:38,223 INFO  L133   ementStrategyFactory]: Using default assertion order modulation
[2020-05-30 20:28:38,224 INFO  L377         BuchiCegarLoop]: Interprodecural is true
[2020-05-30 20:28:38,224 INFO  L378         BuchiCegarLoop]: Hoare is false
[2020-05-30 20:28:38,224 INFO  L379         BuchiCegarLoop]: Compute interpolants for Craig_TreeInterpolation
[2020-05-30 20:28:38,224 INFO  L380         BuchiCegarLoop]: Backedges is STRAIGHT_LINE
[2020-05-30 20:28:38,224 INFO  L381         BuchiCegarLoop]: Determinization is PREDICATE_ABSTRACTION
[2020-05-30 20:28:38,224 INFO  L382         BuchiCegarLoop]: Difference is false
[2020-05-30 20:28:38,224 INFO  L383         BuchiCegarLoop]: Minimize is MINIMIZE_SEVPA
[2020-05-30 20:28:38,224 INFO  L386         BuchiCegarLoop]: ======== Iteration 0==of CEGAR loop == BuchiCegarLoop========
[2020-05-30 20:28:38,360 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 15167 states.
[2020-05-30 20:28:38,540 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:28:38,540 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:28:38,540 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:28:38,550 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:28:38,550 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:28:38,550 INFO  L445         BuchiCegarLoop]: ======== Iteration 1============
[2020-05-30 20:28:38,551 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 15167 states.
[2020-05-30 20:28:38,640 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:28:38,641 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:28:38,641 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:28:38,643 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:28:38,643 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_close_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc ben;
[L3811]              assume null == 0;
[L3812]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3812]  RET         call this := FreshRefGenerator__success();
[L3813]              assume now >= 0;
[L3814]              assume DType[this] == RefundEscrow;
[L3815]              gas := gas - 53000;
[L3816]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND TRUE   revert
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3816]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]              assume !revert && gas >= 0;

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND TRUE   choice == 11
[L3703]              gas := gas - 21000;
[L3704]  COND FALSE  !(gas >= 0)
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:28:38,657 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:28:38,658 INFO  L82        PathProgramCache]: Analyzing trace with hash 210075018, now seen corresponding path program 1 times
[2020-05-30 20:28:38,661 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:28:38,677 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:28:38,718 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 20:28:38,720 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:28:38,720 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:28:39,411 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:28:39,426 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:28:39,426 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:28:39,428 INFO  L87              Difference]: Start difference. First operand 15167 states. Second operand 3 states.
[2020-05-30 20:28:40,656 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:28:40,657 INFO  L93              Difference]: Finished difference Result 11763 states and 30227 transitions.
[2020-05-30 20:28:40,657 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:28:40,658 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 11763 states and 30227 transitions.
[2020-05-30 20:28:40,753 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:28:40,884 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 11763 states to 11763 states and 30227 transitions.
[2020-05-30 20:28:40,885 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 8
[2020-05-30 20:28:40,889 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 362
[2020-05-30 20:28:40,889 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 11763 states and 30227 transitions.
[2020-05-30 20:28:40,935 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:28:40,935 INFO  L728         BuchiCegarLoop]: Abstraction has 11763 states and 30227 transitions.
[2020-05-30 20:28:40,967 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 11763 states and 30227 transitions.
[2020-05-30 20:28:41,174 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 11763 to 11763.
[2020-05-30 20:28:41,175 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 11763 states.
[2020-05-30 20:28:41,208 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 11763 states to 11763 states and 30227 transitions.
[2020-05-30 20:28:41,209 INFO  L751         BuchiCegarLoop]: Abstraction has 11763 states and 30227 transitions.
[2020-05-30 20:28:41,209 INFO  L631         BuchiCegarLoop]: Abstraction has 11763 states and 30227 transitions.
[2020-05-30 20:28:41,209 INFO  L445         BuchiCegarLoop]: ======== Iteration 2============
[2020-05-30 20:28:41,209 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 11763 states and 30227 transitions.
[2020-05-30 20:28:41,241 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:28:41,241 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:28:41,241 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:28:41,244 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:28:41,244 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_close_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc ben;
[L3811]              assume null == 0;
[L3812]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3812]  RET         call this := FreshRefGenerator__success();
[L3813]              assume now >= 0;
[L3814]              assume DType[this] == RefundEscrow;
[L3815]              gas := gas - 53000;
[L3816]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND TRUE   revert
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3816]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]              assume !revert && gas >= 0;
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND TRUE   choice == 3
[L3775]              gas := gas - 21000;
[L3776]  COND TRUE   gas >= 0
[L3778]              assume msgvalue_MSG == 0;
[L3779]  CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]               havoc __exception;
[L676]               revert := false;
[L677]   COND FALSE  !(__exception)
[L696]   CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]              gas := gas - 2208;
[L3301]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]  COND TRUE   revert
[L696]   RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L1]     CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]              gas := gas - 3;
[L2149]              gas := gas - 294;
[L2150]              __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]     RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                 assume ben == __beneficiary_RefundEscrow0;
[L7]                 success_close_RefundEscrow0 := true;
[L7]                 success_close_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3779]  RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND TRUE   choice == 3
[L3775]              gas := gas - 21000;
[L3776]  COND TRUE   gas >= 0
[L3778]              assume msgvalue_MSG == 0;
[L3779]  CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]               havoc __exception;
[L676]               revert := false;
[L677]   COND FALSE  !(__exception)
[L696]   CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]              gas := gas - 2208;
[L3301]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]  COND TRUE   revert
[L696]   RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L1]     CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]              gas := gas - 3;
[L2149]              gas := gas - 294;
[L2150]              __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]     RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                 assume ben == __beneficiary_RefundEscrow0;
[L7]                 success_close_RefundEscrow0 := true;
[L7]                 success_close_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3779]  RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:28:41,249 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:28:41,249 INFO  L82        PathProgramCache]: Analyzing trace with hash 1813691532, now seen corresponding path program 1 times
[2020-05-30 20:28:41,250 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:28:41,258 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:28:41,271 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 20:28:41,272 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:28:41,272 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:28:41,273 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:28:41,273 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:28:41,274 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:28:41,274 INFO  L87              Difference]: Start difference. First operand 11763 states and 30227 transitions. cyclomatic complexity: 18488 Second operand 3 states.
[2020-05-30 20:28:41,938 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:28:41,938 INFO  L93              Difference]: Finished difference Result 11349 states and 20235 transitions.
[2020-05-30 20:28:41,939 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:28:41,939 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 11349 states and 20235 transitions.
[2020-05-30 20:28:41,987 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:28:42,078 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 11349 states to 11349 states and 20235 transitions.
[2020-05-30 20:28:42,078 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 362
[2020-05-30 20:28:42,079 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 362
[2020-05-30 20:28:42,079 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 11349 states and 20235 transitions.
[2020-05-30 20:28:42,096 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:28:42,097 INFO  L728         BuchiCegarLoop]: Abstraction has 11349 states and 20235 transitions.
[2020-05-30 20:28:42,118 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 11349 states and 20235 transitions.
[2020-05-30 20:28:42,271 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 11349 to 11349.
[2020-05-30 20:28:42,271 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 11349 states.
[2020-05-30 20:28:42,300 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 11349 states to 11349 states and 20235 transitions.
[2020-05-30 20:28:42,301 INFO  L751         BuchiCegarLoop]: Abstraction has 11349 states and 20235 transitions.
[2020-05-30 20:28:42,301 INFO  L631         BuchiCegarLoop]: Abstraction has 11349 states and 20235 transitions.
[2020-05-30 20:28:42,301 INFO  L445         BuchiCegarLoop]: ======== Iteration 3============
[2020-05-30 20:28:42,301 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 11349 states and 20235 transitions.
[2020-05-30 20:28:42,329 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:28:42,329 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:28:42,329 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:28:42,332 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:28:42,332 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_close_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc ben;
[L3811]              assume null == 0;
[L3812]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3812]  RET         call this := FreshRefGenerator__success();
[L3813]              assume now >= 0;
[L3814]              assume DType[this] == RefundEscrow;
[L3815]              gas := gas - 53000;
[L3816]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND TRUE   revert
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3816]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]              assume !revert && gas >= 0;
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND TRUE   choice == 8
[L3730]              gas := gas - 21000;
[L3731]  COND TRUE   gas >= 0
[L3733]              assume msgvalue_MSG >= 0;
[L3734]  CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]               havoc __exception;
[L639]               revert := false;
[L640]   COND FALSE  !(__exception)
[L659]   CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]              assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]              Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]              Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]              gas := gas - 317;
[L2191]  COND TRUE   !(_state_RefundEscrow[this] == 0)
[L2193]              revert := true;
[L659]   RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_deposit_RefundEscrow0 := true;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L7]                 fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]  RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]  RET         call CorralChoice_RefundEscrow(this);
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND TRUE   choice == 3
[L3775]              gas := gas - 21000;
[L3776]  COND TRUE   gas >= 0
[L3778]              assume msgvalue_MSG == 0;
[L3779]  CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]               havoc __exception;
[L676]               revert := false;
[L677]   COND FALSE  !(__exception)
[L696]   CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]              gas := gas - 2208;
[L3301]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]  COND TRUE   revert
[L696]   RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L1]     CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]              gas := gas - 3;
[L2149]              gas := gas - 294;
[L2150]              __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]     RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                 assume ben == __beneficiary_RefundEscrow0;
[L7]                 success_close_RefundEscrow0 := true;
[L7]                 success_close_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3779]  RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND TRUE   choice == 8
[L3730]              gas := gas - 21000;
[L3731]  COND TRUE   gas >= 0
[L3733]              assume msgvalue_MSG >= 0;
[L3734]  CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]               havoc __exception;
[L639]               revert := false;
[L640]   COND FALSE  !(__exception)
[L659]   CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]              assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]              Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]              Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]              gas := gas - 317;
[L2191]  COND TRUE   !(_state_RefundEscrow[this] == 0)
[L2193]              revert := true;
[L659]   RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_deposit_RefundEscrow0 := true;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L7]                 fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]  RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:28:42,378 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:28:42,378 INFO  L82        PathProgramCache]: Analyzing trace with hash 808079788, now seen corresponding path program 1 times
[2020-05-30 20:28:42,379 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:28:42,387 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:28:42,409 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 20:28:42,409 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:28:42,409 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-05-30 20:28:42,410 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:28:42,410 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-05-30 20:28:42,410 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=5, Invalid=7, Unknown=0, NotChecked=0, Total=12
[2020-05-30 20:28:42,410 INFO  L87              Difference]: Start difference. First operand 11349 states and 20235 transitions. cyclomatic complexity: 8910 Second operand 4 states.
[2020-05-30 20:28:44,549 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:28:44,549 INFO  L93              Difference]: Finished difference Result 11142 states and 13958 transitions.
[2020-05-30 20:28:44,549 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 4 states. 
[2020-05-30 20:28:44,549 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 11142 states and 13958 transitions.
[2020-05-30 20:28:44,575 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:28:44,611 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 11142 states to 11142 states and 13958 transitions.
[2020-05-30 20:28:44,611 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 362
[2020-05-30 20:28:44,612 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 362
[2020-05-30 20:28:44,612 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 11142 states and 13958 transitions.
[2020-05-30 20:28:44,620 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:28:44,621 INFO  L728         BuchiCegarLoop]: Abstraction has 11142 states and 13958 transitions.
[2020-05-30 20:28:44,633 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 11142 states and 13958 transitions.
[2020-05-30 20:28:44,711 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 11142 to 11142.
[2020-05-30 20:28:44,712 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 11142 states.
[2020-05-30 20:28:44,724 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 11142 states to 11142 states and 13958 transitions.
[2020-05-30 20:28:44,724 INFO  L751         BuchiCegarLoop]: Abstraction has 11142 states and 13958 transitions.
[2020-05-30 20:28:44,724 INFO  L631         BuchiCegarLoop]: Abstraction has 11142 states and 13958 transitions.
[2020-05-30 20:28:44,724 INFO  L445         BuchiCegarLoop]: ======== Iteration 4============
[2020-05-30 20:28:44,724 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 11142 states and 13958 transitions.
[2020-05-30 20:28:44,736 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:28:44,736 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:28:44,736 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:28:44,738 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:28:44,738 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_close_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc ben;
[L3811]              assume null == 0;
[L3812]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3812]  RET         call this := FreshRefGenerator__success();
[L3813]              assume now >= 0;
[L3814]              assume DType[this] == RefundEscrow;
[L3815]              gas := gas - 53000;
[L3816]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND TRUE   revert
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3816]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]              assume !revert && gas >= 0;
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND TRUE   choice == 8
[L3730]              gas := gas - 21000;
[L3731]  COND TRUE   gas >= 0
[L3733]              assume msgvalue_MSG >= 0;
[L3734]  CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]               havoc __exception;
[L639]               revert := false;
[L640]   COND FALSE  !(__exception)
[L659]   CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]              assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]              Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]              Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]              gas := gas - 317;
[L2191]  COND TRUE   !(_state_RefundEscrow[this] == 0)
[L2193]              revert := true;
[L659]   RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_deposit_RefundEscrow0 := true;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L7]                 fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]  RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]  RET         call CorralChoice_RefundEscrow(this);
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND TRUE   choice == 1
[L3793]              gas := gas - 21000;
[L3794]  COND TRUE   gas >= 0
[L3796]              assume msgvalue_MSG == 0;
[L3797]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND TRUE   !(_state_RefundEscrow[this] == 2)
[L2344]              revert := true;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3797]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]  RET         call CorralChoice_RefundEscrow(this);
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND TRUE   choice == 3
[L3775]              gas := gas - 21000;
[L3776]  COND TRUE   gas >= 0
[L3778]              assume msgvalue_MSG == 0;
[L3779]  CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]               havoc __exception;
[L676]               revert := false;
[L677]   COND FALSE  !(__exception)
[L696]   CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]              gas := gas - 2208;
[L3301]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]  COND TRUE   revert
[L696]   RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L1]     CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]              gas := gas - 3;
[L2149]              gas := gas - 294;
[L2150]              __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]     RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                 assume ben == __beneficiary_RefundEscrow0;
[L7]                 success_close_RefundEscrow0 := true;
[L7]                 success_close_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3779]  RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND TRUE   choice == 8
[L3730]              gas := gas - 21000;
[L3731]  COND TRUE   gas >= 0
[L3733]              assume msgvalue_MSG >= 0;
[L3734]  CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]               havoc __exception;
[L639]               revert := false;
[L640]   COND FALSE  !(__exception)
[L659]   CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]              assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]              Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]              Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]              gas := gas - 317;
[L2191]  COND TRUE   !(_state_RefundEscrow[this] == 0)
[L2193]              revert := true;
[L659]   RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_deposit_RefundEscrow0 := true;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L7]                 fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]  RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:28:44,741 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:28:44,741 INFO  L82        PathProgramCache]: Analyzing trace with hash -759086318, now seen corresponding path program 1 times
[2020-05-30 20:28:44,741 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:28:44,747 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:28:44,776 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 20:28:44,776 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:28:44,776 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:28:44,776 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:28:44,777 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:28:44,777 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:28:44,777 INFO  L87              Difference]: Start difference. First operand 11142 states and 13958 transitions. cyclomatic complexity: 2840 Second operand 3 states.
[2020-05-30 20:28:44,989 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:28:44,989 INFO  L93              Difference]: Finished difference Result 13904 states and 17203 transitions.
[2020-05-30 20:28:44,989 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:28:44,990 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 13904 states and 17203 transitions.
[2020-05-30 20:28:45,030 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:28:45,084 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 13904 states to 13904 states and 17203 transitions.
[2020-05-30 20:28:45,084 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 479
[2020-05-30 20:28:45,085 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 479
[2020-05-30 20:28:45,085 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 13904 states and 17203 transitions.
[2020-05-30 20:28:45,096 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:28:45,097 INFO  L728         BuchiCegarLoop]: Abstraction has 13904 states and 17203 transitions.
[2020-05-30 20:28:45,110 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 13904 states and 17203 transitions.
[2020-05-30 20:28:45,245 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 13904 to 13037.
[2020-05-30 20:28:45,245 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 13037 states.
[2020-05-30 20:28:45,269 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 13037 states to 13037 states and 16145 transitions.
[2020-05-30 20:28:45,269 INFO  L751         BuchiCegarLoop]: Abstraction has 13037 states and 16145 transitions.
[2020-05-30 20:28:45,269 INFO  L631         BuchiCegarLoop]: Abstraction has 13037 states and 16145 transitions.
[2020-05-30 20:28:45,269 INFO  L445         BuchiCegarLoop]: ======== Iteration 5============
[2020-05-30 20:28:45,269 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 13037 states and 16145 transitions.
[2020-05-30 20:28:45,291 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:28:45,291 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:28:45,292 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:28:45,293 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:28:45,293 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_close_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc ben;
[L3811]              assume null == 0;
[L3812]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3812]  RET         call this := FreshRefGenerator__success();
[L3813]              assume now >= 0;
[L3814]              assume DType[this] == RefundEscrow;
[L3815]              gas := gas - 53000;
[L3816]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND FALSE  !(revert)
[L2095]  CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L1501]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]  COND FALSE  !(revert)
[L1507]  CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]              assume msgsender_MSG != null;
[L1468]              Balance[this] := 0;
[L1469]  CALL        call __var_2 := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L1469]  RET         call __var_2 := FreshRefGenerator__success();
[L1470]  COND FALSE  !(revert)
[L1475]              _deposits_Escrow[this] := __var_2;
[L1476]              M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]              sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]  RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]  COND FALSE  !(revert)
[L2095]  RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]  COND FALSE  !(revert)
[L2101]  CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L1887]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]  COND FALSE  !(revert)
[L1893]  CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L1501]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]  COND FALSE  !(revert)
[L1507]  CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]              assume msgsender_MSG != null;
[L1468]              Balance[this] := 0;
[L1469]  CALL        call __var_2 := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L1469]  RET         call __var_2 := FreshRefGenerator__success();
[L1470]  COND FALSE  !(revert)
[L1475]              _deposits_Escrow[this] := __var_2;
[L1476]              M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]              sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]  RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]  COND FALSE  !(revert)
[L1893]  RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]  COND FALSE  !(revert)
[L1899]  CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]              assume msgsender_MSG != null;
[L1857]              Balance[this] := 0;
[L1899]  RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]  COND FALSE  !(revert)
[L2101]  RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]  COND FALSE  !(revert)
[L2107]  CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]              assume msgsender_MSG != null;
[L2039]              Balance[this] := 0;
[L2040]              _beneficiary_RefundEscrow[this] := null;
[L2041]              __var_7 := null;
[L2042]  COND TRUE   !(beneficiary_s294 != null)
[L2044]              revert := true;
[L2107]  RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]  COND TRUE   revert
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3816]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]              assume !revert && gas >= 0;
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND TRUE   choice == 8
[L3730]              gas := gas - 21000;
[L3731]  COND TRUE   gas >= 0
[L3733]              assume msgvalue_MSG >= 0;
[L3734]  CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]               havoc __exception;
[L639]               revert := false;
[L640]   COND FALSE  !(__exception)
[L659]   CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]              assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]              Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]              Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]              gas := gas - 317;
[L2191]  COND TRUE   !(_state_RefundEscrow[this] == 0)
[L2193]              revert := true;
[L659]   RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_deposit_RefundEscrow0 := true;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L7]                 fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]  RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]  RET         call CorralChoice_RefundEscrow(this);
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND TRUE   choice == 1
[L3793]              gas := gas - 21000;
[L3794]  COND TRUE   gas >= 0
[L3796]              assume msgvalue_MSG == 0;
[L3797]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND TRUE   !(_state_RefundEscrow[this] == 2)
[L2344]              revert := true;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3797]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]  RET         call CorralChoice_RefundEscrow(this);
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND TRUE   choice == 3
[L3775]              gas := gas - 21000;
[L3776]  COND TRUE   gas >= 0
[L3778]              assume msgvalue_MSG == 0;
[L3779]  CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]               havoc __exception;
[L676]               revert := false;
[L677]   COND FALSE  !(__exception)
[L696]   CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]              gas := gas - 2208;
[L3301]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]  COND FALSE  !(revert)
[L2243]              gas := gas - 317;
[L2244]  COND TRUE   !(_state_RefundEscrow[this] == 0)
[L2246]              revert := true;
[L696]   RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L1]     CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]              gas := gas - 3;
[L2149]              gas := gas - 294;
[L2150]              __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]     RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                 assume ben == __beneficiary_RefundEscrow0;
[L7]                 success_close_RefundEscrow0 := true;
[L7]                 success_close_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3779]  RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND TRUE   choice == 8
[L3730]              gas := gas - 21000;
[L3731]  COND TRUE   gas >= 0
[L3733]              assume msgvalue_MSG >= 0;
[L3734]  CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]               havoc __exception;
[L639]               revert := false;
[L640]   COND FALSE  !(__exception)
[L659]   CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]              assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]              Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]              Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]              gas := gas - 317;
[L2191]  COND TRUE   !(_state_RefundEscrow[this] == 0)
[L2193]              revert := true;
[L659]   RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_deposit_RefundEscrow0 := true;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L7]                 fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]  RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:28:45,298 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:28:45,298 INFO  L82        PathProgramCache]: Analyzing trace with hash -522473511, now seen corresponding path program 1 times
[2020-05-30 20:28:45,299 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:28:45,309 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:28:45,373 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:28:45,373 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:28:45,373 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:28:45,374 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:28:45,374 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:28:45,374 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:28:45,374 INFO  L87              Difference]: Start difference. First operand 13037 states and 16145 transitions. cyclomatic complexity: 3132 Second operand 3 states.
[2020-05-30 20:28:45,597 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:28:45,597 INFO  L93              Difference]: Finished difference Result 14566 states and 17633 transitions.
[2020-05-30 20:28:45,597 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:28:45,598 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 14566 states and 17633 transitions.
[2020-05-30 20:28:45,647 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 6
[2020-05-30 20:28:45,699 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 14566 states to 13624 states and 16435 transitions.
[2020-05-30 20:28:45,700 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 403
[2020-05-30 20:28:45,700 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 403
[2020-05-30 20:28:45,700 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 13624 states and 16435 transitions.
[2020-05-30 20:28:45,717 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:28:45,718 INFO  L728         BuchiCegarLoop]: Abstraction has 13624 states and 16435 transitions.
[2020-05-30 20:28:45,731 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 13624 states and 16435 transitions.
[2020-05-30 20:28:45,820 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 13624 to 12264.
[2020-05-30 20:28:45,820 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 12264 states.
[2020-05-30 20:28:45,833 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 12264 states to 12264 states and 14688 transitions.
[2020-05-30 20:28:45,833 INFO  L751         BuchiCegarLoop]: Abstraction has 12264 states and 14688 transitions.
[2020-05-30 20:28:45,833 INFO  L631         BuchiCegarLoop]: Abstraction has 12264 states and 14688 transitions.
[2020-05-30 20:28:45,833 INFO  L445         BuchiCegarLoop]: ======== Iteration 6============
[2020-05-30 20:28:45,834 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 12264 states and 14688 transitions.
[2020-05-30 20:28:45,845 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:28:45,846 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:28:45,846 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:28:45,848 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:28:45,848 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND FALSE  !(choice == 2)
[L3791]        COND TRUE   choice == 1
[L3793]                    gas := gas - 21000;
[L3794]        COND TRUE   gas >= 0
[L3796]                    assume msgvalue_MSG == 0;
[L3797]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND FALSE  !(gas > 2300)
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND FALSE  !(Balance[from] >= amount)
[L3277]                    success := false;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3797]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND TRUE   choice == 1
[L3793]              gas := gas - 21000;
[L3794]  COND TRUE   gas >= 0
[L3796]              assume msgvalue_MSG == 0;
[L3797]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND FALSE  !(gas > 2300)
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]              havoc __exception;
[L3245]  COND FALSE  !(__exception)
[L3270]  COND FALSE  !(Balance[from] >= amount)
[L3277]              success := false;
[L3280]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3797]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:28:45,853 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:28:45,853 INFO  L82        PathProgramCache]: Analyzing trace with hash -1400621494, now seen corresponding path program 1 times
[2020-05-30 20:28:45,853 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:28:45,876 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:28:46,027 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:28:46,027 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:28:46,027 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-05-30 20:28:46,028 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:28:46,028 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-05-30 20:28:46,028 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=5, Invalid=7, Unknown=0, NotChecked=0, Total=12
[2020-05-30 20:28:46,028 INFO  L87              Difference]: Start difference. First operand 12264 states and 14688 transitions. cyclomatic complexity: 2448 Second operand 4 states.
[2020-05-30 20:28:46,151 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:28:46,151 INFO  L93              Difference]: Finished difference Result 12344 states and 14772 transitions.
[2020-05-30 20:28:46,151 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 4 states. 
[2020-05-30 20:28:46,151 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 12344 states and 14772 transitions.
[2020-05-30 20:28:46,172 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:28:46,204 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 12344 states to 12328 states and 14756 transitions.
[2020-05-30 20:28:46,204 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 372
[2020-05-30 20:28:46,205 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 372
[2020-05-30 20:28:46,205 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 12328 states and 14756 transitions.
[2020-05-30 20:28:46,215 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:28:46,215 INFO  L728         BuchiCegarLoop]: Abstraction has 12328 states and 14756 transitions.
[2020-05-30 20:28:46,227 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 12328 states and 14756 transitions.
[2020-05-30 20:28:46,300 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 12328 to 12328.
[2020-05-30 20:28:46,300 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 12328 states.
[2020-05-30 20:28:46,314 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 12328 states to 12328 states and 14756 transitions.
[2020-05-30 20:28:46,314 INFO  L751         BuchiCegarLoop]: Abstraction has 12328 states and 14756 transitions.
[2020-05-30 20:28:46,314 INFO  L631         BuchiCegarLoop]: Abstraction has 12328 states and 14756 transitions.
[2020-05-30 20:28:46,314 INFO  L445         BuchiCegarLoop]: ======== Iteration 7============
[2020-05-30 20:28:46,314 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 12328 states and 14756 transitions.
[2020-05-30 20:28:46,327 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:28:46,327 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:28:46,327 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:28:46,329 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:28:46,329 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND FALSE  !(choice == 2)
[L3791]        COND TRUE   choice == 1
[L3793]                    gas := gas - 21000;
[L3794]        COND TRUE   gas >= 0
[L3796]                    assume msgvalue_MSG == 0;
[L3797]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND FALSE  !(gas > 2300)
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3797]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND TRUE   choice == 1
[L3793]              gas := gas - 21000;
[L3794]  COND TRUE   gas >= 0
[L3796]              assume msgvalue_MSG == 0;
[L3797]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND FALSE  !(gas > 2300)
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]              havoc __exception;
[L3245]  COND FALSE  !(__exception)
[L3270]  COND TRUE   Balance[from] >= amount
[L3272]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND TRUE   DType[to] == RefundEscrow
[L2426]              assume amount == 0;
[L3272]  RET         call FallbackDispatch__success(from, to, amount);
[L3273]              success := true;
[L3280]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3797]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:28:46,333 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:28:46,333 INFO  L82        PathProgramCache]: Analyzing trace with hash -1712115919, now seen corresponding path program 1 times
[2020-05-30 20:28:46,334 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:28:46,349 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:28:46,452 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:28:46,452 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:28:46,452 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [11] imperfect sequences [] total 11
[2020-05-30 20:28:46,453 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:28:46,453 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-05-30 20:28:46,453 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=21, Invalid=89, Unknown=0, NotChecked=0, Total=110
[2020-05-30 20:28:46,453 INFO  L87              Difference]: Start difference. First operand 12328 states and 14756 transitions. cyclomatic complexity: 2452 Second operand 11 states.
[2020-05-30 20:28:51,944 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:28:51,944 INFO  L93              Difference]: Finished difference Result 12956 states and 15565 transitions.
[2020-05-30 20:28:51,944 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-30 20:28:51,945 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 12956 states and 15565 transitions.
[2020-05-30 20:28:51,974 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:28:52,012 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 12956 states to 12956 states and 15565 transitions.
[2020-05-30 20:28:52,012 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 446
[2020-05-30 20:28:52,013 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 446
[2020-05-30 20:28:52,013 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 12956 states and 15565 transitions.
[2020-05-30 20:28:52,021 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:28:52,021 INFO  L728         BuchiCegarLoop]: Abstraction has 12956 states and 15565 transitions.
[2020-05-30 20:28:52,032 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 12956 states and 15565 transitions.
[2020-05-30 20:28:52,111 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 12956 to 12280.
[2020-05-30 20:28:52,112 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 12280 states.
[2020-05-30 20:28:52,125 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 12280 states to 12280 states and 14672 transitions.
[2020-05-30 20:28:52,125 INFO  L751         BuchiCegarLoop]: Abstraction has 12280 states and 14672 transitions.
[2020-05-30 20:28:52,125 INFO  L631         BuchiCegarLoop]: Abstraction has 12280 states and 14672 transitions.
[2020-05-30 20:28:52,125 INFO  L445         BuchiCegarLoop]: ======== Iteration 8============
[2020-05-30 20:28:52,126 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 12280 states and 14672 transitions.
[2020-05-30 20:28:52,137 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:28:52,137 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:28:52,137 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:28:52,139 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:28:52,140 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND FALSE  !(choice == 2)
[L3791]        COND TRUE   choice == 1
[L3793]                    gas := gas - 21000;
[L3794]        COND TRUE   gas >= 0
[L3796]                    assume msgvalue_MSG == 0;
[L3797]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND FALSE  !(gas > 2300)
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3797]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND TRUE   choice == 11
[L3703]              gas := gas - 21000;
[L3704]  COND FALSE  !(gas >= 0)
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:28:52,143 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:28:52,143 INFO  L82        PathProgramCache]: Analyzing trace with hash 1349066414, now seen corresponding path program 1 times
[2020-05-30 20:28:52,144 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:28:52,158 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:28:52,245 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:28:52,245 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:28:52,245 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [9] imperfect sequences [] total 9
[2020-05-30 20:28:52,246 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:28:52,246 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 10 interpolants.
[2020-05-30 20:28:52,246 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=17, Invalid=73, Unknown=0, NotChecked=0, Total=90
[2020-05-30 20:28:52,247 INFO  L87              Difference]: Start difference. First operand 12280 states and 14672 transitions. cyclomatic complexity: 2418 Second operand 10 states.
[2020-05-30 20:29:02,166 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:29:02,166 INFO  L93              Difference]: Finished difference Result 14019 states and 17057 transitions.
[2020-05-30 20:29:02,166 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 11 states. 
[2020-05-30 20:29:02,166 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 14019 states and 17057 transitions.
[2020-05-30 20:29:02,200 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 8
[2020-05-30 20:29:02,240 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 14019 states to 14019 states and 17057 transitions.
[2020-05-30 20:29:02,240 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 471
[2020-05-30 20:29:02,241 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 471
[2020-05-30 20:29:02,241 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 14019 states and 17057 transitions.
[2020-05-30 20:29:02,249 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:29:02,249 INFO  L728         BuchiCegarLoop]: Abstraction has 14019 states and 17057 transitions.
[2020-05-30 20:29:02,259 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 14019 states and 17057 transitions.
[2020-05-30 20:29:02,337 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 14019 to 13429.
[2020-05-30 20:29:02,337 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 13429 states.
[2020-05-30 20:29:02,352 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 13429 states to 13429 states and 16138 transitions.
[2020-05-30 20:29:02,352 INFO  L751         BuchiCegarLoop]: Abstraction has 13429 states and 16138 transitions.
[2020-05-30 20:29:02,352 INFO  L631         BuchiCegarLoop]: Abstraction has 13429 states and 16138 transitions.
[2020-05-30 20:29:02,353 INFO  L445         BuchiCegarLoop]: ======== Iteration 9============
[2020-05-30 20:29:02,353 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 13429 states and 16138 transitions.
[2020-05-30 20:29:02,365 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:29:02,366 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:29:02,366 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:29:02,367 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:29:02,367 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND FALSE  !(choice == 2)
[L3791]        COND TRUE   choice == 1
[L3793]                    gas := gas - 21000;
[L3794]        COND TRUE   gas >= 0
[L3796]                    assume msgvalue_MSG == 0;
[L3797]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND FALSE  !(gas > 2300)
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3797]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND TRUE   choice == 11
[L3703]              gas := gas - 21000;
[L3704]  COND FALSE  !(gas >= 0)
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:29:02,371 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:29:02,371 INFO  L82        PathProgramCache]: Analyzing trace with hash -123318448, now seen corresponding path program 1 times
[2020-05-30 20:29:02,371 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:29:02,387 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:29:02,470 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:29:02,470 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:29:02,470 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [8] imperfect sequences [] total 8
[2020-05-30 20:29:02,470 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:29:02,470 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 8 interpolants.
[2020-05-30 20:29:02,471 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=17, Invalid=39, Unknown=0, NotChecked=0, Total=56
[2020-05-30 20:29:02,471 INFO  L87              Difference]: Start difference. First operand 13429 states and 16138 transitions. cyclomatic complexity: 2735 Second operand 8 states.
[2020-05-30 20:29:14,208 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:29:14,208 INFO  L93              Difference]: Finished difference Result 16569 states and 19861 transitions.
[2020-05-30 20:29:14,208 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 12 states. 
[2020-05-30 20:29:14,208 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 16569 states and 19861 transitions.
[2020-05-30 20:29:14,244 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 8
[2020-05-30 20:29:14,292 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 16569 states to 16569 states and 19861 transitions.
[2020-05-30 20:29:14,292 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 616
[2020-05-30 20:29:14,293 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 616
[2020-05-30 20:29:14,293 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 16569 states and 19861 transitions.
[2020-05-30 20:29:14,303 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:29:14,303 INFO  L728         BuchiCegarLoop]: Abstraction has 16569 states and 19861 transitions.
[2020-05-30 20:29:14,313 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 16569 states and 19861 transitions.
[2020-05-30 20:29:14,398 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 16569 to 13645.
[2020-05-30 20:29:14,398 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 13645 states.
[2020-05-30 20:29:14,413 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 13645 states to 13645 states and 16212 transitions.
[2020-05-30 20:29:14,413 INFO  L751         BuchiCegarLoop]: Abstraction has 13645 states and 16212 transitions.
[2020-05-30 20:29:14,414 INFO  L631         BuchiCegarLoop]: Abstraction has 13645 states and 16212 transitions.
[2020-05-30 20:29:14,414 INFO  L445         BuchiCegarLoop]: ======== Iteration 10============
[2020-05-30 20:29:14,414 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 13645 states and 16212 transitions.
[2020-05-30 20:29:14,427 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:29:14,427 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:29:14,427 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:29:14,428 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:29:14,428 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND FALSE  !(choice == 2)
[L3791]        COND TRUE   choice == 1
[L3793]                    gas := gas - 21000;
[L3794]        COND TRUE   gas >= 0
[L3796]                    assume msgvalue_MSG == 0;
[L3797]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND FALSE  !(gas < 21000)
[L2846]        COND TRUE   DType[from] == RefundEscrow
[L2848]        COND FALSE  !(choice == 11)
[L2861]        COND FALSE  !(choice == 10)
[L2874]        COND FALSE  !(choice == 9)
[L2887]        COND FALSE  !(choice == 8)
[L2900]        COND FALSE  !(choice == 7)
[L2913]        COND FALSE  !(choice == 6)
[L2926]        COND FALSE  !(choice == 5)
[L2939]        COND FALSE  !(choice == 4)
[L2952]        COND TRUE   choice == 3
[L2954]                    gas := gas - 21000;
[L2955]        COND TRUE   gas >= 0
[L2957]                    assume msgvalue_MSG == 0;
[L2958]        CALL        call close_RefundEscrow__success(from, to, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L2958]        RET         call close_RefundEscrow__success(from, to, msgvalue_MSG);
[L2959]        COND FALSE  !(revert)
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3797]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:29:14,432 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:29:14,432 INFO  L82        PathProgramCache]: Analyzing trace with hash -11453752, now seen corresponding path program 1 times
[2020-05-30 20:29:14,433 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:29:14,449 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:29:14,527 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:29:14,527 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:29:14,527 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [6] imperfect sequences [] total 6
[2020-05-30 20:29:14,527 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:29:14,528 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 6 interpolants.
[2020-05-30 20:29:14,528 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=11, Invalid=19, Unknown=0, NotChecked=0, Total=30
[2020-05-30 20:29:14,528 INFO  L87              Difference]: Start difference. First operand 13645 states and 16212 transitions. cyclomatic complexity: 2593 Second operand 6 states.
[2020-05-30 20:29:16,210 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:29:16,211 INFO  L93              Difference]: Finished difference Result 9579 states and 10654 transitions.
[2020-05-30 20:29:16,211 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 5 states. 
[2020-05-30 20:29:16,211 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9579 states and 10654 transitions.
[2020-05-30 20:29:16,233 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 8
[2020-05-30 20:29:16,255 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9579 states to 9411 states and 10470 transitions.
[2020-05-30 20:29:16,255 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 310
[2020-05-30 20:29:16,257 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1148
[2020-05-30 20:29:16,257 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9411 states and 10470 transitions.
[2020-05-30 20:29:16,262 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:29:16,262 INFO  L728         BuchiCegarLoop]: Abstraction has 9411 states and 10470 transitions.
[2020-05-30 20:29:16,268 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9411 states and 10470 transitions.
[2020-05-30 20:29:16,313 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9411 to 8789.
[2020-05-30 20:29:16,313 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8789 states.
[2020-05-30 20:29:16,322 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8789 states to 8789 states and 9712 transitions.
[2020-05-30 20:29:16,322 INFO  L751         BuchiCegarLoop]: Abstraction has 8789 states and 9712 transitions.
[2020-05-30 20:29:16,322 INFO  L631         BuchiCegarLoop]: Abstraction has 8789 states and 9712 transitions.
[2020-05-30 20:29:16,322 INFO  L445         BuchiCegarLoop]: ======== Iteration 11============
[2020-05-30 20:29:16,322 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8789 states and 9712 transitions.
[2020-05-30 20:29:16,331 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:29:16,331 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:29:16,331 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:29:16,332 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:29:16,332 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND FALSE  !(choice == 2)
[L3791]        COND TRUE   choice == 1
[L3793]                    gas := gas - 21000;
[L3794]        COND TRUE   gas >= 0
[L3796]                    assume msgvalue_MSG == 0;
[L3797]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3797]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND TRUE   choice == 1
[L3793]              gas := gas - 21000;
[L3794]  COND TRUE   gas >= 0
[L3796]              assume msgvalue_MSG == 0;
[L3797]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND TRUE   gas > 2300
[L2352]              gas := 2300;
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]              havoc __exception;
[L3245]  COND FALSE  !(__exception)
[L3270]  COND TRUE   Balance[from] >= amount
[L3272]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND TRUE   DType[to] == RefundEscrow
[L2426]              assume amount == 0;
[L3272]  RET         call FallbackDispatch__success(from, to, amount);
[L3273]              success := true;
[L3280]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3797]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:29:16,336 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:29:16,336 INFO  L82        PathProgramCache]: Analyzing trace with hash -1035843312, now seen corresponding path program 1 times
[2020-05-30 20:29:16,337 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:29:16,354 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:29:16,689 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:29:16,689 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:29:16,689 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [34] imperfect sequences [] total 34
[2020-05-30 20:29:16,690 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:29:16,690 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 35 interpolants.
[2020-05-30 20:29:16,690 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=101, Invalid=1089, Unknown=0, NotChecked=0, Total=1190
[2020-05-30 20:29:16,691 INFO  L87              Difference]: Start difference. First operand 8789 states and 9712 transitions. cyclomatic complexity: 933 Second operand 35 states.
[2020-05-30 20:29:49,008 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:29:49,009 INFO  L93              Difference]: Finished difference Result 18820 states and 22535 transitions.
[2020-05-30 20:29:49,009 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 75 states. 
[2020-05-30 20:29:49,009 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 18820 states and 22535 transitions.
[2020-05-30 20:29:49,058 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 16
[2020-05-30 20:29:49,116 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 18820 states to 18820 states and 22535 transitions.
[2020-05-30 20:29:49,116 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2275
[2020-05-30 20:29:49,117 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2275
[2020-05-30 20:29:49,117 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 18820 states and 22535 transitions.
[2020-05-30 20:29:49,131 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:29:49,132 INFO  L728         BuchiCegarLoop]: Abstraction has 18820 states and 22535 transitions.
[2020-05-30 20:29:49,140 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 18820 states and 22535 transitions.
[2020-05-30 20:29:49,305 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 18820 to 18402.
[2020-05-30 20:29:49,305 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 18402 states.
[2020-05-30 20:29:49,330 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 18402 states to 18402 states and 21152 transitions.
[2020-05-30 20:29:49,330 INFO  L751         BuchiCegarLoop]: Abstraction has 18402 states and 21152 transitions.
[2020-05-30 20:29:49,330 INFO  L631         BuchiCegarLoop]: Abstraction has 18402 states and 21152 transitions.
[2020-05-30 20:29:49,330 INFO  L445         BuchiCegarLoop]: ======== Iteration 12============
[2020-05-30 20:29:49,330 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 18402 states and 21152 transitions.
[2020-05-30 20:29:49,350 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 16
[2020-05-30 20:29:49,350 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:29:49,350 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:29:49,351 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:29:49,351 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND FALSE  !(choice == 2)
[L3791]        COND TRUE   choice == 1
[L3793]                    gas := gas - 21000;
[L3794]        COND TRUE   gas >= 0
[L3796]                    assume msgvalue_MSG == 0;
[L3797]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3797]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND TRUE   choice == 1
[L3793]              gas := gas - 21000;
[L3794]  COND TRUE   gas >= 0
[L3796]              assume msgvalue_MSG == 0;
[L3797]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND TRUE   gas > 2300
[L2352]              gas := 2300;
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]              havoc __exception;
[L3245]  COND FALSE  !(__exception)
[L3270]  COND TRUE   Balance[from] >= amount
[L3272]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND TRUE   DType[to] == RefundEscrow
[L2426]              assume amount == 0;
[L3272]  RET         call FallbackDispatch__success(from, to, amount);
[L3273]              success := true;
[L3280]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3797]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:29:49,355 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:29:49,355 INFO  L82        PathProgramCache]: Analyzing trace with hash 868156579, now seen corresponding path program 1 times
[2020-05-30 20:29:49,356 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:29:49,368 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:29:49,437 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:29:49,437 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:29:49,437 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [10] imperfect sequences [] total 10
[2020-05-30 20:29:49,437 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:29:49,438 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 10 interpolants.
[2020-05-30 20:29:49,438 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=18, Invalid=72, Unknown=0, NotChecked=0, Total=90
[2020-05-30 20:29:49,438 INFO  L87              Difference]: Start difference. First operand 18402 states and 21152 transitions. cyclomatic complexity: 2788 Second operand 10 states.
[2020-05-30 20:29:56,056 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:29:56,056 INFO  L93              Difference]: Finished difference Result 22444 states and 27015 transitions.
[2020-05-30 20:29:56,057 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-30 20:29:56,057 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 22444 states and 27015 transitions.
[2020-05-30 20:29:56,129 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 32
[2020-05-30 20:29:56,214 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 22444 states to 22332 states and 26887 transitions.
[2020-05-30 20:29:56,214 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2713
[2020-05-30 20:29:56,216 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2713
[2020-05-30 20:29:56,216 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 22332 states and 26887 transitions.
[2020-05-30 20:29:56,235 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:29:56,235 INFO  L728         BuchiCegarLoop]: Abstraction has 22332 states and 26887 transitions.
[2020-05-30 20:29:56,246 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 22332 states and 26887 transitions.
[2020-05-30 20:29:56,429 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 22332 to 22298.
[2020-05-30 20:29:56,429 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 22298 states.
[2020-05-30 20:29:56,473 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 22298 states to 22298 states and 26640 transitions.
[2020-05-30 20:29:56,473 INFO  L751         BuchiCegarLoop]: Abstraction has 22298 states and 26640 transitions.
[2020-05-30 20:29:56,474 INFO  L631         BuchiCegarLoop]: Abstraction has 22298 states and 26640 transitions.
[2020-05-30 20:29:56,474 INFO  L445         BuchiCegarLoop]: ======== Iteration 13============
[2020-05-30 20:29:56,474 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 22298 states and 26640 transitions.
[2020-05-30 20:29:56,500 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 32
[2020-05-30 20:29:56,500 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:29:56,500 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:29:56,501 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:29:56,502 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND FALSE  !(choice == 2)
[L3791]        COND TRUE   choice == 1
[L3793]                    gas := gas - 21000;
[L3794]        COND TRUE   gas >= 0
[L3796]                    assume msgvalue_MSG == 0;
[L3797]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3797]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND TRUE   choice == 10
[L3712]              gas := gas - 21000;
[L3713]  COND TRUE   gas >= 0
[L3715]              assume msgvalue_MSG == 0;
[L3716]  CALL        call transferPrimary_Secondary(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L230]               havoc __exception;
[L231]               revert := false;
[L232]   COND FALSE  !(__exception)
[L251]   CALL        call transferPrimary_Secondary__success(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L1423]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]              gas := gas - 2208;
[L3301]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1423]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1424]  COND FALSE  !(revert)
[L1429]              gas := gas - 88;
[L1430]              __var_1 := null;
[L1431]  COND FALSE  !(!(recipient_s113 != null))
[L1437]              gas := gas - 40534;
[L1438]              _primary_Secondary[this] := recipient_s113;
[L1439]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L251]   RET         call transferPrimary_Secondary__success(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L252]               assume !revert && gas >= 0;
[L3716]  RET         call transferPrimary_Secondary(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:29:56,505 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:29:56,506 INFO  L82        PathProgramCache]: Analyzing trace with hash -279388183, now seen corresponding path program 1 times
[2020-05-30 20:29:56,506 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:29:56,527 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:29:56,711 WARN  L188               SmtUtils]: Spent 121.00 ms on a formula simplification that was a NOOP. DAG size: 18
[2020-05-30 20:29:56,866 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:29:56,866 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:29:56,866 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [31] imperfect sequences [] total 31
[2020-05-30 20:29:56,867 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:29:56,867 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 32 interpolants.
[2020-05-30 20:29:56,867 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=91, Invalid=901, Unknown=0, NotChecked=0, Total=992
[2020-05-30 20:29:56,867 INFO  L87              Difference]: Start difference. First operand 22298 states and 26640 transitions. cyclomatic complexity: 4380 Second operand 32 states.
[2020-05-30 20:30:15,614 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:30:15,614 INFO  L93              Difference]: Finished difference Result 28576 states and 35871 transitions.
[2020-05-30 20:30:15,615 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 62 states. 
[2020-05-30 20:30:15,615 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 28576 states and 35871 transitions.
[2020-05-30 20:30:15,713 INFO  L131   ngComponentsAnalysis]: Automaton has 7 accepting balls. 48
[2020-05-30 20:30:15,841 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 28576 states to 28576 states and 35871 transitions.
[2020-05-30 20:30:15,842 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2756
[2020-05-30 20:30:15,843 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2756
[2020-05-30 20:30:15,843 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 28576 states and 35871 transitions.
[2020-05-30 20:30:15,871 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:30:15,871 INFO  L728         BuchiCegarLoop]: Abstraction has 28576 states and 35871 transitions.
[2020-05-30 20:30:15,884 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 28576 states and 35871 transitions.
[2020-05-30 20:30:16,102 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 28576 to 28158.
[2020-05-30 20:30:16,102 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 28158 states.
[2020-05-30 20:30:16,164 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 28158 states to 28158 states and 34365 transitions.
[2020-05-30 20:30:16,164 INFO  L751         BuchiCegarLoop]: Abstraction has 28158 states and 34365 transitions.
[2020-05-30 20:30:16,164 INFO  L631         BuchiCegarLoop]: Abstraction has 28158 states and 34365 transitions.
[2020-05-30 20:30:16,164 INFO  L445         BuchiCegarLoop]: ======== Iteration 14============
[2020-05-30 20:30:16,164 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 28158 states and 34365 transitions.
[2020-05-30 20:30:16,198 INFO  L131   ngComponentsAnalysis]: Automaton has 7 accepting balls. 48
[2020-05-30 20:30:16,199 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:30:16,199 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:30:16,200 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:30:16,200 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume !(ben == __beneficiary_RefundEscrow0);
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND FALSE  !(choice == 2)
[L3791]        COND TRUE   choice == 1
[L3793]                    gas := gas - 21000;
[L3794]        COND TRUE   gas >= 0
[L3796]                    assume msgvalue_MSG == 0;
[L3797]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == ben && amount == fsum_deposit_RefundEscrow_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3797]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND FALSE  !(choice == 1)
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:30:16,205 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:30:16,205 INFO  L82        PathProgramCache]: Analyzing trace with hash 49721056, now seen corresponding path program 1 times
[2020-05-30 20:30:16,206 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:30:16,223 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:30:16,325 INFO  L134       CoverageAnalysis]: Checked inductivity of 203 backedges. 4 proven. 2 refuted. 0 times theorem prover too weak. 197 trivial. 0 not checked.
[2020-05-30 20:30:16,326 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:30:16,326 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [11] total 11
[2020-05-30 20:30:16,326 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:30:16,326 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-05-30 20:30:16,327 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=19, Invalid=91, Unknown=0, NotChecked=0, Total=110
[2020-05-30 20:30:16,327 INFO  L87              Difference]: Start difference. First operand 28158 states and 34365 transitions. cyclomatic complexity: 6281 Second operand 11 states.
[2020-05-30 20:30:17,860 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:30:17,860 INFO  L93              Difference]: Finished difference Result 38016 states and 47839 transitions.
[2020-05-30 20:30:17,860 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 12 states. 
[2020-05-30 20:30:17,861 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 38016 states and 47839 transitions.
[2020-05-30 20:30:18,000 INFO  L131   ngComponentsAnalysis]: Automaton has 15 accepting balls. 88
[2020-05-30 20:30:18,155 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 38016 states to 32918 states and 40449 transitions.
[2020-05-30 20:30:18,156 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 3696
[2020-05-30 20:30:18,157 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 3696
[2020-05-30 20:30:18,158 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 32918 states and 40449 transitions.
[2020-05-30 20:30:18,189 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:30:18,189 INFO  L728         BuchiCegarLoop]: Abstraction has 32918 states and 40449 transitions.
[2020-05-30 20:30:18,206 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 32918 states and 40449 transitions.
[2020-05-30 20:30:18,454 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 32918 to 32680.
[2020-05-30 20:30:18,454 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 32680 states.
[2020-05-30 20:30:18,531 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 32680 states to 32680 states and 39871 transitions.
[2020-05-30 20:30:18,531 INFO  L751         BuchiCegarLoop]: Abstraction has 32680 states and 39871 transitions.
[2020-05-30 20:30:18,531 INFO  L631         BuchiCegarLoop]: Abstraction has 32680 states and 39871 transitions.
[2020-05-30 20:30:18,531 INFO  L445         BuchiCegarLoop]: ======== Iteration 15============
[2020-05-30 20:30:18,531 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 32680 states and 39871 transitions.
[2020-05-30 20:30:18,572 INFO  L131   ngComponentsAnalysis]: Automaton has 13 accepting balls. 72
[2020-05-30 20:30:18,572 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:30:18,572 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:30:18,573 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:30:18,574 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND FALSE  !(choice == 2)
[L3791]        COND TRUE   choice == 1
[L3793]                    gas := gas - 21000;
[L3794]        COND TRUE   gas >= 0
[L3796]                    assume msgvalue_MSG == 0;
[L3797]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == ben && amount == fsum_deposit_RefundEscrow_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3797]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND FALSE  !(choice == 1)
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:30:18,578 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:30:18,579 INFO  L82        PathProgramCache]: Analyzing trace with hash -1380947769, now seen corresponding path program 1 times
[2020-05-30 20:30:18,579 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:30:18,598 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:30:18,814 INFO  L134       CoverageAnalysis]: Checked inductivity of 307 backedges. 2 proven. 39 refuted. 0 times theorem prover too weak. 266 trivial. 0 not checked.
[2020-05-30 20:30:18,814 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:30:18,814 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [11] total 11
[2020-05-30 20:30:18,815 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:30:18,815 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-05-30 20:30:18,815 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=21, Invalid=89, Unknown=0, NotChecked=0, Total=110
[2020-05-30 20:30:18,815 INFO  L87              Difference]: Start difference. First operand 32680 states and 39871 transitions. cyclomatic complexity: 7301 Second operand 11 states.
[2020-05-30 20:30:22,667 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:30:22,667 INFO  L93              Difference]: Finished difference Result 32784 states and 40005 transitions.
[2020-05-30 20:30:22,668 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 12 states. 
[2020-05-30 20:30:22,668 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 32784 states and 40005 transitions.
[2020-05-30 20:30:22,781 INFO  L131   ngComponentsAnalysis]: Automaton has 19 accepting balls. 72
[2020-05-30 20:30:22,913 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 32784 states to 30362 states and 36495 transitions.
[2020-05-30 20:30:22,913 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 3667
[2020-05-30 20:30:22,915 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 3667
[2020-05-30 20:30:22,915 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 30362 states and 36495 transitions.
[2020-05-30 20:30:22,942 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:30:22,942 INFO  L728         BuchiCegarLoop]: Abstraction has 30362 states and 36495 transitions.
[2020-05-30 20:30:22,958 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 30362 states and 36495 transitions.
[2020-05-30 20:30:23,183 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 30362 to 30248.
[2020-05-30 20:30:23,184 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 30248 states.
[2020-05-30 20:30:23,248 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 30248 states to 30248 states and 36108 transitions.
[2020-05-30 20:30:23,249 INFO  L751         BuchiCegarLoop]: Abstraction has 30248 states and 36108 transitions.
[2020-05-30 20:30:23,249 INFO  L631         BuchiCegarLoop]: Abstraction has 30248 states and 36108 transitions.
[2020-05-30 20:30:23,249 INFO  L445         BuchiCegarLoop]: ======== Iteration 16============
[2020-05-30 20:30:23,249 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 30248 states and 36108 transitions.
[2020-05-30 20:30:23,287 INFO  L131   ngComponentsAnalysis]: Automaton has 19 accepting balls. 72
[2020-05-30 20:30:23,287 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:30:23,287 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:30:23,288 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:30:23,288 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND FALSE  !(choice == 2)
[L3791]        COND TRUE   choice == 1
[L3793]                    gas := gas - 21000;
[L3794]        COND TRUE   gas >= 0
[L3796]                    assume msgvalue_MSG == 0;
[L3797]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3797]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND FALSE  !(choice == 1)
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:30:23,292 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:30:23,293 INFO  L82        PathProgramCache]: Analyzing trace with hash -2066359866, now seen corresponding path program 1 times
[2020-05-30 20:30:23,293 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:30:23,307 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:30:23,392 INFO  L134       CoverageAnalysis]: Checked inductivity of 154 backedges. 33 proven. 0 refuted. 0 times theorem prover too weak. 121 trivial. 0 not checked.
[2020-05-30 20:30:23,392 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:30:23,392 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [10] imperfect sequences [] total 10
[2020-05-30 20:30:23,392 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:30:23,392 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 10 interpolants.
[2020-05-30 20:30:23,393 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=18, Invalid=72, Unknown=0, NotChecked=0, Total=90
[2020-05-30 20:30:23,393 INFO  L87              Difference]: Start difference. First operand 30248 states and 36108 transitions. cyclomatic complexity: 5997 Second operand 10 states.
[2020-05-30 20:30:29,841 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:30:29,842 INFO  L93              Difference]: Finished difference Result 32341 states and 38103 transitions.
[2020-05-30 20:30:29,842 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-30 20:30:29,842 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 32341 states and 38103 transitions.
[2020-05-30 20:30:29,935 INFO  L131   ngComponentsAnalysis]: Automaton has 13 accepting balls. 56
[2020-05-30 20:30:29,985 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 32341 states to 15872 states and 18534 transitions.
[2020-05-30 20:30:29,985 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 3561
[2020-05-30 20:30:29,986 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 3561
[2020-05-30 20:30:29,986 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 15872 states and 18534 transitions.
[2020-05-30 20:30:29,997 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:30:29,997 INFO  L728         BuchiCegarLoop]: Abstraction has 15872 states and 18534 transitions.
[2020-05-30 20:30:30,003 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 15872 states and 18534 transitions.
[2020-05-30 20:30:30,094 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 15872 to 14779.
[2020-05-30 20:30:30,094 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 14779 states.
[2020-05-30 20:30:30,119 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 14779 states to 14779 states and 17259 transitions.
[2020-05-30 20:30:30,119 INFO  L751         BuchiCegarLoop]: Abstraction has 14779 states and 17259 transitions.
[2020-05-30 20:30:30,119 INFO  L631         BuchiCegarLoop]: Abstraction has 14779 states and 17259 transitions.
[2020-05-30 20:30:30,119 INFO  L445         BuchiCegarLoop]: ======== Iteration 17============
[2020-05-30 20:30:30,119 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 14779 states and 17259 transitions.
[2020-05-30 20:30:30,137 INFO  L131   ngComponentsAnalysis]: Automaton has 13 accepting balls. 56
[2020-05-30 20:30:30,137 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:30:30,137 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:30:30,138 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:30:30,138 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND FALSE  !(choice == 2)
[L3791]        COND TRUE   choice == 1
[L3793]                    gas := gas - 21000;
[L3794]        COND TRUE   gas >= 0
[L3796]                    assume msgvalue_MSG == 0;
[L3797]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == ben && amount == fsum_deposit_RefundEscrow_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3797]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND FALSE  !(choice == 1)
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:30:30,142 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:30:30,142 INFO  L82        PathProgramCache]: Analyzing trace with hash 1045966402, now seen corresponding path program 1 times
[2020-05-30 20:30:30,142 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:30:30,155 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:30:30,242 INFO  L134       CoverageAnalysis]: Checked inductivity of 159 backedges. 42 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:30:30,242 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:30:30,242 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [11] imperfect sequences [] total 11
[2020-05-30 20:30:30,242 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:30:30,243 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-05-30 20:30:30,243 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=21, Invalid=89, Unknown=0, NotChecked=0, Total=110
[2020-05-30 20:30:30,243 INFO  L87              Difference]: Start difference. First operand 14779 states and 17259 transitions. cyclomatic complexity: 2533 Second operand 11 states.
[2020-05-30 20:30:32,934 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:30:32,934 INFO  L93              Difference]: Finished difference Result 13461 states and 15303 transitions.
[2020-05-30 20:30:32,934 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 12 states. 
[2020-05-30 20:30:32,934 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 13461 states and 15303 transitions.
[2020-05-30 20:30:32,971 INFO  L131   ngComponentsAnalysis]: Automaton has 9 accepting balls. 32
[2020-05-30 20:30:33,007 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 13461 states to 13461 states and 15303 transitions.
[2020-05-30 20:30:33,007 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 3100
[2020-05-30 20:30:33,008 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 3100
[2020-05-30 20:30:33,009 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 13461 states and 15303 transitions.
[2020-05-30 20:30:33,017 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:30:33,017 INFO  L728         BuchiCegarLoop]: Abstraction has 13461 states and 15303 transitions.
[2020-05-30 20:30:33,023 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 13461 states and 15303 transitions.
[2020-05-30 20:30:33,101 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 13461 to 13259.
[2020-05-30 20:30:33,101 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 13259 states.
[2020-05-30 20:30:33,120 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 13259 states to 13259 states and 15049 transitions.
[2020-05-30 20:30:33,121 INFO  L751         BuchiCegarLoop]: Abstraction has 13259 states and 15049 transitions.
[2020-05-30 20:30:33,121 INFO  L631         BuchiCegarLoop]: Abstraction has 13259 states and 15049 transitions.
[2020-05-30 20:30:33,121 INFO  L445         BuchiCegarLoop]: ======== Iteration 18============
[2020-05-30 20:30:33,121 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 13259 states and 15049 transitions.
[2020-05-30 20:30:33,136 INFO  L131   ngComponentsAnalysis]: Automaton has 9 accepting balls. 32
[2020-05-30 20:30:33,137 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:30:33,137 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:30:33,138 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:30:33,138 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND FALSE  !(choice == 2)
[L3791]        COND TRUE   choice == 1
[L3793]                    gas := gas - 21000;
[L3794]        COND TRUE   gas >= 0
[L3796]                    assume msgvalue_MSG == 0;
[L3797]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3797]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND FALSE  !(choice == 1)
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:30:33,141 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:30:33,141 INFO  L82        PathProgramCache]: Analyzing trace with hash -1504693897, now seen corresponding path program 1 times
[2020-05-30 20:30:33,142 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:30:33,160 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:30:33,516 INFO  L134       CoverageAnalysis]: Checked inductivity of 221 backedges. 36 proven. 15 refuted. 0 times theorem prover too weak. 170 trivial. 0 not checked.
[2020-05-30 20:30:33,517 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:30:33,517 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [37] total 37
[2020-05-30 20:30:33,518 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:30:33,518 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 38 interpolants.
[2020-05-30 20:30:33,519 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=105, Invalid=1301, Unknown=0, NotChecked=0, Total=1406
[2020-05-30 20:30:33,519 INFO  L87              Difference]: Start difference. First operand 13259 states and 15049 transitions. cyclomatic complexity: 1833 Second operand 38 states.
[2020-05-30 20:30:55,464 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:30:55,464 INFO  L93              Difference]: Finished difference Result 14720 states and 17098 transitions.
[2020-05-30 20:30:55,464 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 60 states. 
[2020-05-30 20:30:55,464 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 14720 states and 17098 transitions.
[2020-05-30 20:30:55,499 INFO  L131   ngComponentsAnalysis]: Automaton has 11 accepting balls. 40
[2020-05-30 20:30:55,538 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 14720 states to 14720 states and 17098 transitions.
[2020-05-30 20:30:55,538 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 3180
[2020-05-30 20:30:55,539 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 3180
[2020-05-30 20:30:55,539 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 14720 states and 17098 transitions.
[2020-05-30 20:30:55,548 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:30:55,548 INFO  L728         BuchiCegarLoop]: Abstraction has 14720 states and 17098 transitions.
[2020-05-30 20:30:55,553 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 14720 states and 17098 transitions.
[2020-05-30 20:30:55,646 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 14720 to 14265.
[2020-05-30 20:30:55,646 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 14265 states.
[2020-05-30 20:30:55,667 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 14265 states to 14265 states and 16227 transitions.
[2020-05-30 20:30:55,667 INFO  L751         BuchiCegarLoop]: Abstraction has 14265 states and 16227 transitions.
[2020-05-30 20:30:55,667 INFO  L631         BuchiCegarLoop]: Abstraction has 14265 states and 16227 transitions.
[2020-05-30 20:30:55,667 INFO  L445         BuchiCegarLoop]: ======== Iteration 19============
[2020-05-30 20:30:55,667 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 14265 states and 16227 transitions.
[2020-05-30 20:30:55,684 INFO  L131   ngComponentsAnalysis]: Automaton has 9 accepting balls. 32
[2020-05-30 20:30:55,684 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:30:55,684 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:30:55,685 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:30:55,686 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND FALSE  !(DType[this] == RefundEscrow)
[L1974]        COND TRUE   DType[this] == ConditionalEscrow
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND FALSE  !(choice == 2)
[L3791]        COND TRUE   choice == 1
[L3793]                    gas := gas - 21000;
[L3794]        COND TRUE   gas >= 0
[L3796]                    assume msgvalue_MSG == 0;
[L3797]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3797]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND TRUE   choice == 1
[L3793]              gas := gas - 21000;
[L3794]  COND TRUE   gas >= 0
[L3796]              assume msgvalue_MSG == 0;
[L3797]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND TRUE   gas > 2300
[L2352]              gas := 2300;
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]              havoc __exception;
[L3245]  COND FALSE  !(__exception)
[L3270]  COND TRUE   Balance[from] >= amount
[L3272]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND TRUE   DType[to] == RefundEscrow
[L2426]              assume amount == 0;
[L3272]  RET         call FallbackDispatch__success(from, to, amount);
[L3273]              success := true;
[L3280]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3797]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:30:55,690 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:30:55,690 INFO  L82        PathProgramCache]: Analyzing trace with hash -1333616651, now seen corresponding path program 1 times
[2020-05-30 20:30:55,691 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:30:55,706 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:30:55,790 INFO  L134       CoverageAnalysis]: Checked inductivity of 171 backedges. 4 proven. 0 refuted. 0 times theorem prover too weak. 167 trivial. 0 not checked.
[2020-05-30 20:30:55,790 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:30:55,790 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:30:55,791 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:30:55,791 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:30:55,791 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:30:55,791 INFO  L87              Difference]: Start difference. First operand 14265 states and 16227 transitions. cyclomatic complexity: 2011 Second operand 3 states.
[2020-05-30 20:30:55,847 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:30:55,847 INFO  L93              Difference]: Finished difference Result 14338 states and 16303 transitions.
[2020-05-30 20:30:55,847 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:30:55,847 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 14338 states and 16303 transitions.
[2020-05-30 20:30:55,879 INFO  L131   ngComponentsAnalysis]: Automaton has 9 accepting balls. 32
[2020-05-30 20:30:55,914 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 14338 states to 14338 states and 16303 transitions.
[2020-05-30 20:30:55,915 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 3104
[2020-05-30 20:30:55,916 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 3104
[2020-05-30 20:30:55,916 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 14338 states and 16303 transitions.
[2020-05-30 20:30:55,925 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:30:55,925 INFO  L728         BuchiCegarLoop]: Abstraction has 14338 states and 16303 transitions.
[2020-05-30 20:30:55,930 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 14338 states and 16303 transitions.
[2020-05-30 20:30:56,019 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 14338 to 14298.
[2020-05-30 20:30:56,020 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 14298 states.
[2020-05-30 20:30:56,041 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 14298 states to 14298 states and 16260 transitions.
[2020-05-30 20:30:56,042 INFO  L751         BuchiCegarLoop]: Abstraction has 14298 states and 16260 transitions.
[2020-05-30 20:30:56,042 INFO  L631         BuchiCegarLoop]: Abstraction has 14298 states and 16260 transitions.
[2020-05-30 20:30:56,042 INFO  L445         BuchiCegarLoop]: ======== Iteration 20============
[2020-05-30 20:30:56,042 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 14298 states and 16260 transitions.
[2020-05-30 20:30:56,059 INFO  L131   ngComponentsAnalysis]: Automaton has 9 accepting balls. 32
[2020-05-30 20:30:56,059 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:30:56,059 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:30:56,061 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:30:56,061 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND FALSE  !(DType[this] == RefundEscrow)
[L1974]        COND TRUE   DType[this] == ConditionalEscrow
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND FALSE  !(DType[this] == RefundEscrow)
[L1998]        COND TRUE   DType[this] == ConditionalEscrow
[L2000]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L2000]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2001]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND FALSE  !(choice == 2)
[L3791]        COND TRUE   choice == 1
[L3793]                    gas := gas - 21000;
[L3794]        COND TRUE   gas >= 0
[L3796]                    assume msgvalue_MSG == 0;
[L3797]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3797]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND TRUE   choice == 1
[L3793]              gas := gas - 21000;
[L3794]  COND TRUE   gas >= 0
[L3796]              assume msgvalue_MSG == 0;
[L3797]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND TRUE   gas > 2300
[L2352]              gas := 2300;
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]              havoc __exception;
[L3245]  COND FALSE  !(__exception)
[L3270]  COND TRUE   Balance[from] >= amount
[L3272]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND TRUE   DType[to] == RefundEscrow
[L2426]              assume amount == 0;
[L3272]  RET         call FallbackDispatch__success(from, to, amount);
[L3273]              success := true;
[L3280]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3797]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:30:56,065 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:30:56,065 INFO  L82        PathProgramCache]: Analyzing trace with hash -315154046, now seen corresponding path program 1 times
[2020-05-30 20:30:56,066 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:30:56,080 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:30:56,172 INFO  L134       CoverageAnalysis]: Checked inductivity of 171 backedges. 4 proven. 0 refuted. 0 times theorem prover too weak. 167 trivial. 0 not checked.
[2020-05-30 20:30:56,172 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:30:56,172 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [6] imperfect sequences [] total 6
[2020-05-30 20:30:56,172 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:30:56,172 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 6 interpolants.
[2020-05-30 20:30:56,173 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=9, Invalid=21, Unknown=0, NotChecked=0, Total=30
[2020-05-30 20:30:56,173 INFO  L87              Difference]: Start difference. First operand 14298 states and 16260 transitions. cyclomatic complexity: 2011 Second operand 6 states.
[2020-05-30 20:30:56,291 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:30:56,291 INFO  L93              Difference]: Finished difference Result 14616 states and 16576 transitions.
[2020-05-30 20:30:56,291 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 6 states. 
[2020-05-30 20:30:56,291 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 14616 states and 16576 transitions.
[2020-05-30 20:30:56,321 INFO  L131   ngComponentsAnalysis]: Automaton has 9 accepting balls. 32
[2020-05-30 20:30:56,356 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 14616 states to 14170 states and 16087 transitions.
[2020-05-30 20:30:56,357 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 3076
[2020-05-30 20:30:56,358 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 3076
[2020-05-30 20:30:56,358 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 14170 states and 16087 transitions.
[2020-05-30 20:30:56,366 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:30:56,366 INFO  L728         BuchiCegarLoop]: Abstraction has 14170 states and 16087 transitions.
[2020-05-30 20:30:56,372 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 14170 states and 16087 transitions.
[2020-05-30 20:30:56,458 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 14170 to 14170.
[2020-05-30 20:30:56,458 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 14170 states.
[2020-05-30 20:30:56,479 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 14170 states to 14170 states and 16087 transitions.
[2020-05-30 20:30:56,480 INFO  L751         BuchiCegarLoop]: Abstraction has 14170 states and 16087 transitions.
[2020-05-30 20:30:56,480 INFO  L631         BuchiCegarLoop]: Abstraction has 14170 states and 16087 transitions.
[2020-05-30 20:30:56,480 INFO  L445         BuchiCegarLoop]: ======== Iteration 21============
[2020-05-30 20:30:56,480 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 14170 states and 16087 transitions.
[2020-05-30 20:30:56,497 INFO  L131   ngComponentsAnalysis]: Automaton has 9 accepting balls. 32
[2020-05-30 20:30:56,497 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:30:56,497 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:30:56,499 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:30:56,499 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume !(ben == __beneficiary_RefundEscrow0);
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND FALSE  !(choice == 2)
[L3791]        COND TRUE   choice == 1
[L3793]                    gas := gas - 21000;
[L3794]        COND TRUE   gas >= 0
[L3796]                    assume msgvalue_MSG == 0;
[L3797]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3797]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND TRUE   choice == 1
[L3793]              gas := gas - 21000;
[L3794]  COND TRUE   gas >= 0
[L3796]              assume msgvalue_MSG == 0;
[L3797]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND TRUE   gas > 2300
[L2352]              gas := 2300;
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]              havoc __exception;
[L3245]  COND FALSE  !(__exception)
[L3270]  COND TRUE   Balance[from] >= amount
[L3272]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND FALSE  !(DType[to] == RefundEscrow)
[L2428]  COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]  COND FALSE  !(DType[to] == Escrow)
[L2436]  COND FALSE  !(DType[to] == Secondary)
[L2442]  CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]              assume Balance[from] >= amount;
[L2833]              Balance[from] := Balance[from] - amount;
[L2834]              Balance[to] := Balance[to] + amount;
[L2835]  COND FALSE  !(choice == 0)
[L2841]  COND TRUE   gas < 21000
[L2442]  RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]  COND FALSE  !(revert)
[L3272]  RET         call FallbackDispatch__success(from, to, amount);
[L3273]              success := true;
[L3280]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3797]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:30:56,504 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:30:56,504 INFO  L82        PathProgramCache]: Analyzing trace with hash 2107306945, now seen corresponding path program 1 times
[2020-05-30 20:30:56,504 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:30:56,526 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:30:56,668 INFO  L134       CoverageAnalysis]: Checked inductivity of 385 backedges. 10 proven. 12 refuted. 0 times theorem prover too weak. 363 trivial. 0 not checked.
[2020-05-30 20:30:56,668 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:30:56,668 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [9] total 9
[2020-05-30 20:30:56,668 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:30:56,668 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 9 interpolants.
[2020-05-30 20:30:56,669 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=15, Invalid=57, Unknown=0, NotChecked=0, Total=72
[2020-05-30 20:30:56,669 INFO  L87              Difference]: Start difference. First operand 14170 states and 16087 transitions. cyclomatic complexity: 1966 Second operand 9 states.
[2020-05-30 20:30:56,892 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:30:56,892 INFO  L93              Difference]: Finished difference Result 13030 states and 14640 transitions.
[2020-05-30 20:30:56,892 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 8 states. 
[2020-05-30 20:30:56,892 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 13030 states and 14640 transitions.
[2020-05-30 20:30:56,916 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 16
[2020-05-30 20:30:56,942 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 13030 states to 13030 states and 14640 transitions.
[2020-05-30 20:30:56,942 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2348
[2020-05-30 20:30:56,943 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2348
[2020-05-30 20:30:56,943 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 13030 states and 14640 transitions.
[2020-05-30 20:30:56,950 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:30:56,950 INFO  L728         BuchiCegarLoop]: Abstraction has 13030 states and 14640 transitions.
[2020-05-30 20:30:56,954 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 13030 states and 14640 transitions.
[2020-05-30 20:30:57,071 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 13030 to 12984.
[2020-05-30 20:30:57,072 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 12984 states.
[2020-05-30 20:30:57,088 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 12984 states to 12984 states and 14576 transitions.
[2020-05-30 20:30:57,088 INFO  L751         BuchiCegarLoop]: Abstraction has 12984 states and 14576 transitions.
[2020-05-30 20:30:57,088 INFO  L631         BuchiCegarLoop]: Abstraction has 12984 states and 14576 transitions.
[2020-05-30 20:30:57,088 INFO  L445         BuchiCegarLoop]: ======== Iteration 22============
[2020-05-30 20:30:57,088 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 12984 states and 14576 transitions.
[2020-05-30 20:30:57,101 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 14
[2020-05-30 20:30:57,101 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:30:57,101 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:30:57,103 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:30:57,103 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND FALSE  !(choice == 2)
[L3791]        COND TRUE   choice == 1
[L3793]                    gas := gas - 21000;
[L3794]        COND TRUE   gas >= 0
[L3796]                    assume msgvalue_MSG == 0;
[L3797]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3797]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND TRUE   choice == 1
[L3793]              gas := gas - 21000;
[L3794]  COND TRUE   gas >= 0
[L3796]              assume msgvalue_MSG == 0;
[L3797]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND TRUE   gas > 2300
[L2352]              gas := 2300;
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]              havoc __exception;
[L3245]  COND FALSE  !(__exception)
[L3270]  COND TRUE   Balance[from] >= amount
[L3272]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND FALSE  !(DType[to] == RefundEscrow)
[L2428]  COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]  COND FALSE  !(DType[to] == Escrow)
[L2436]  COND FALSE  !(DType[to] == Secondary)
[L2442]  CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]              assume Balance[from] >= amount;
[L2833]              Balance[from] := Balance[from] - amount;
[L2834]              Balance[to] := Balance[to] + amount;
[L2835]  COND FALSE  !(choice == 0)
[L2841]  COND TRUE   gas < 21000
[L2442]  RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]  COND FALSE  !(revert)
[L3272]  RET         call FallbackDispatch__success(from, to, amount);
[L3273]              success := true;
[L3280]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3797]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:30:57,111 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:30:57,111 INFO  L82        PathProgramCache]: Analyzing trace with hash 1414653549, now seen corresponding path program 1 times
[2020-05-30 20:30:57,112 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:30:57,125 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:30:57,224 INFO  L134       CoverageAnalysis]: Checked inductivity of 171 backedges. 2 proven. 35 refuted. 0 times theorem prover too weak. 134 trivial. 0 not checked.
[2020-05-30 20:30:57,224 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:30:57,225 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [12] total 12
[2020-05-30 20:30:57,225 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:30:57,225 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 12 interpolants.
[2020-05-30 20:30:57,225 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=22, Invalid=110, Unknown=0, NotChecked=0, Total=132
[2020-05-30 20:30:57,225 INFO  L87              Difference]: Start difference. First operand 12984 states and 14576 transitions. cyclomatic complexity: 1631 Second operand 12 states.
[2020-05-30 20:30:58,811 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:30:58,812 INFO  L93              Difference]: Finished difference Result 13057 states and 14654 transitions.
[2020-05-30 20:30:58,812 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 14 states. 
[2020-05-30 20:30:58,812 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 13057 states and 14654 transitions.
[2020-05-30 20:30:58,841 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 12
[2020-05-30 20:30:58,875 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 13057 states to 13057 states and 14651 transitions.
[2020-05-30 20:30:58,875 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2348
[2020-05-30 20:30:58,876 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2348
[2020-05-30 20:30:58,876 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 13057 states and 14651 transitions.
[2020-05-30 20:30:58,884 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:30:58,884 INFO  L728         BuchiCegarLoop]: Abstraction has 13057 states and 14651 transitions.
[2020-05-30 20:30:58,889 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 13057 states and 14651 transitions.
[2020-05-30 20:30:58,961 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 13057 to 12957.
[2020-05-30 20:30:58,961 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 12957 states.
[2020-05-30 20:30:58,978 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 12957 states to 12957 states and 14520 transitions.
[2020-05-30 20:30:58,978 INFO  L751         BuchiCegarLoop]: Abstraction has 12957 states and 14520 transitions.
[2020-05-30 20:30:58,978 INFO  L631         BuchiCegarLoop]: Abstraction has 12957 states and 14520 transitions.
[2020-05-30 20:30:58,978 INFO  L445         BuchiCegarLoop]: ======== Iteration 23============
[2020-05-30 20:30:58,978 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 12957 states and 14520 transitions.
[2020-05-30 20:30:58,992 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 12
[2020-05-30 20:30:58,992 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:30:58,992 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:30:58,993 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:30:58,993 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND FALSE  !(choice == 2)
[L3791]        COND TRUE   choice == 1
[L3793]                    gas := gas - 21000;
[L3794]        COND TRUE   gas >= 0
[L3796]                    assume msgvalue_MSG == 0;
[L3797]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3797]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND TRUE   choice == 1
[L3793]              gas := gas - 21000;
[L3794]  COND TRUE   gas >= 0
[L3796]              assume msgvalue_MSG == 0;
[L3797]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND TRUE   gas > 2300
[L2352]              gas := 2300;
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]              havoc __exception;
[L3245]  COND FALSE  !(__exception)
[L3270]  COND TRUE   Balance[from] >= amount
[L3272]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND FALSE  !(DType[to] == RefundEscrow)
[L2428]  COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]  COND FALSE  !(DType[to] == Escrow)
[L2436]  COND FALSE  !(DType[to] == Secondary)
[L2442]  CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]              assume Balance[from] >= amount;
[L2833]              Balance[from] := Balance[from] - amount;
[L2834]              Balance[to] := Balance[to] + amount;
[L2835]  COND FALSE  !(choice == 0)
[L2841]  COND TRUE   gas < 21000
[L2442]  RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]  COND FALSE  !(revert)
[L3272]  RET         call FallbackDispatch__success(from, to, amount);
[L3273]              success := true;
[L3280]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3797]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:30:58,997 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:30:58,997 INFO  L82        PathProgramCache]: Analyzing trace with hash -1486874910, now seen corresponding path program 1 times
[2020-05-30 20:30:58,997 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:30:59,033 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:30:59,347 INFO  L134       CoverageAnalysis]: Checked inductivity of 221 backedges. 50 proven. 1 refuted. 0 times theorem prover too weak. 170 trivial. 0 not checked.
[2020-05-30 20:30:59,347 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:30:59,347 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [35] total 35
[2020-05-30 20:30:59,348 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:30:59,348 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 36 interpolants.
[2020-05-30 20:30:59,348 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=102, Invalid=1158, Unknown=0, NotChecked=0, Total=1260
[2020-05-30 20:30:59,349 INFO  L87              Difference]: Start difference. First operand 12957 states and 14520 transitions. cyclomatic complexity: 1602 Second operand 36 states.
[2020-05-30 20:31:12,820 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:31:12,820 INFO  L93              Difference]: Finished difference Result 14415 states and 16459 transitions.
[2020-05-30 20:31:12,820 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 54 states. 
[2020-05-30 20:31:12,820 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 14415 states and 16459 transitions.
[2020-05-30 20:31:12,845 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 12
[2020-05-30 20:31:12,883 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 14415 states to 14409 states and 16449 transitions.
[2020-05-30 20:31:12,884 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2384
[2020-05-30 20:31:12,884 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2384
[2020-05-30 20:31:12,884 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 14409 states and 16449 transitions.
[2020-05-30 20:31:12,892 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:31:12,892 INFO  L728         BuchiCegarLoop]: Abstraction has 14409 states and 16449 transitions.
[2020-05-30 20:31:12,897 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 14409 states and 16449 transitions.
[2020-05-30 20:31:12,961 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 14409 to 12955.
[2020-05-30 20:31:12,961 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 12955 states.
[2020-05-30 20:31:12,978 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 12955 states to 12955 states and 14582 transitions.
[2020-05-30 20:31:12,978 INFO  L751         BuchiCegarLoop]: Abstraction has 12955 states and 14582 transitions.
[2020-05-30 20:31:12,978 INFO  L631         BuchiCegarLoop]: Abstraction has 12955 states and 14582 transitions.
[2020-05-30 20:31:12,979 INFO  L445         BuchiCegarLoop]: ======== Iteration 24============
[2020-05-30 20:31:12,979 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 12955 states and 14582 transitions.
[2020-05-30 20:31:12,993 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 12
[2020-05-30 20:31:12,993 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:31:12,993 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:31:12,994 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:31:12,994 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND FALSE  !(choice == 2)
[L3791]        COND TRUE   choice == 1
[L3793]                    gas := gas - 21000;
[L3794]        COND TRUE   gas >= 0
[L3796]                    assume msgvalue_MSG == 0;
[L3797]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3797]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND TRUE   choice == 1
[L3793]              gas := gas - 21000;
[L3794]  COND TRUE   gas >= 0
[L3796]              assume msgvalue_MSG == 0;
[L3797]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND TRUE   gas > 2300
[L2352]              gas := 2300;
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]              havoc __exception;
[L3245]  COND FALSE  !(__exception)
[L3270]  COND TRUE   Balance[from] >= amount
[L3272]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND TRUE   DType[to] == RefundEscrow
[L2426]              assume amount == 0;
[L3272]  RET         call FallbackDispatch__success(from, to, amount);
[L3273]              success := true;
[L3280]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3797]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:31:12,998 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:31:12,998 INFO  L82        PathProgramCache]: Analyzing trace with hash 2018036863, now seen corresponding path program 1 times
[2020-05-30 20:31:12,998 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:31:13,017 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:31:13,174 INFO  L134       CoverageAnalysis]: Checked inductivity of 244 backedges. 78 proven. 0 refuted. 0 times theorem prover too weak. 166 trivial. 0 not checked.
[2020-05-30 20:31:13,174 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:31:13,174 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [13] imperfect sequences [] total 13
[2020-05-30 20:31:13,175 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:31:13,175 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 13 interpolants.
[2020-05-30 20:31:13,175 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=26, Invalid=130, Unknown=0, NotChecked=0, Total=156
[2020-05-30 20:31:13,175 INFO  L87              Difference]: Start difference. First operand 12955 states and 14582 transitions. cyclomatic complexity: 1662 Second operand 13 states.
[2020-05-30 20:31:15,129 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:31:15,129 INFO  L93              Difference]: Finished difference Result 15389 states and 17687 transitions.
[2020-05-30 20:31:15,129 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 14 states. 
[2020-05-30 20:31:15,129 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 15389 states and 17687 transitions.
[2020-05-30 20:31:15,168 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 16
[2020-05-30 20:31:15,206 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 15389 states to 12308 states and 13806 transitions.
[2020-05-30 20:31:15,206 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2562
[2020-05-30 20:31:15,207 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2562
[2020-05-30 20:31:15,207 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 12308 states and 13806 transitions.
[2020-05-30 20:31:15,214 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:31:15,215 INFO  L728         BuchiCegarLoop]: Abstraction has 12308 states and 13806 transitions.
[2020-05-30 20:31:15,219 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 12308 states and 13806 transitions.
[2020-05-30 20:31:15,277 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 12308 to 12218.
[2020-05-30 20:31:15,277 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 12218 states.
[2020-05-30 20:31:15,291 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 12218 states to 12218 states and 13682 transitions.
[2020-05-30 20:31:15,291 INFO  L751         BuchiCegarLoop]: Abstraction has 12218 states and 13682 transitions.
[2020-05-30 20:31:15,291 INFO  L631         BuchiCegarLoop]: Abstraction has 12218 states and 13682 transitions.
[2020-05-30 20:31:15,291 INFO  L445         BuchiCegarLoop]: ======== Iteration 25============
[2020-05-30 20:31:15,291 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 12218 states and 13682 transitions.
[2020-05-30 20:31:15,303 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 16
[2020-05-30 20:31:15,303 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:31:15,303 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:31:15,304 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:31:15,304 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND TRUE   __exception
[L531]                     __tmp__Balance := Balance;
[L532]                     __tmp__DType := DType;
[L533]                     __tmp__Alloc := Alloc;
[L534]                     __tmp__balance_ADDR := balance_ADDR;
[L535]                     __tmp__M_Ref_int__deposits0 := M_Ref_int__deposits0;
[L536]                     __tmp__sum__deposits0 := sum__deposits0;
[L537]                     __tmp__Length := Length;
[L538]                     __tmp__now := now;
[L539]                     __tmp___primary_Secondary := _primary_Secondary;
[L540]                     __tmp___deposits_Escrow := _deposits_Escrow;
[L541]                     __tmp___state_RefundEscrow := _state_RefundEscrow;
[L542]                     __tmp___beneficiary_RefundEscrow := _beneficiary_RefundEscrow;
[L543]         CALL        call RefundEscrow_RefundEscrow__fail(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2058]        CALL        call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1355]        CALL        call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1334]                    assume msgsender_MSG != null;
[L1335]                    __tmp__Balance[this] := 0;
[L1336]                    __tmp___primary_Secondary[this] := null;
[L1337]                    __tmp___primary_Secondary[this] := msgsender_MSG;
[L1355]        RET         call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1356]        COND FALSE  !(revert)
[L2058]        RET         call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L2059]        COND FALSE  !(revert)
[L2064]        CALL        call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L1484]        CALL        call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1355]        CALL        call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1334]                    assume msgsender_MSG != null;
[L1335]                    __tmp__Balance[this] := 0;
[L1336]                    __tmp___primary_Secondary[this] := null;
[L1337]                    __tmp___primary_Secondary[this] := msgsender_MSG;
[L1355]        RET         call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1356]        COND FALSE  !(revert)
[L1484]        RET         call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1485]        COND FALSE  !(revert)
[L1490]        CALL        call Escrow_Escrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1448]                    assume msgsender_MSG != null;
[L1449]                    __tmp__Balance[this] := 0;
[L1450]        CALL        call __var_2 := FreshRefGenerator__fail();
[L1168]                    havoc newRef;
[L1169]                    assume __tmp__Alloc[newRef] == false;
[L1170]                    __tmp__Alloc[newRef] := true;
[L1171]                    assume newRef != null;
[L1450]        RET         call __var_2 := FreshRefGenerator__fail();
[L1451]        COND FALSE  !(revert)
[L1456]                    __tmp___deposits_Escrow[this] := __var_2;
[L1457]                    __tmp__M_Ref_int__deposits0[__tmp___deposits_Escrow[this]] := zeroRefIntArr();
[L1458]                    __tmp__sum__deposits0[__tmp___deposits_Escrow[this]] := 0;
[L1490]        RET         call Escrow_Escrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1491]        COND FALSE  !(revert)
[L2064]        RET         call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L2065]        COND FALSE  !(revert)
[L2070]        CALL        call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L1864]        CALL        call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1355]        CALL        call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1334]                    assume msgsender_MSG != null;
[L1335]                    __tmp__Balance[this] := 0;
[L1336]                    __tmp___primary_Secondary[this] := null;
[L1337]                    __tmp___primary_Secondary[this] := msgsender_MSG;
[L1355]        RET         call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1356]        COND FALSE  !(revert)
[L1864]        RET         call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1865]        COND FALSE  !(revert)
[L1870]        CALL        call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L1484]        CALL        call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1355]        CALL        call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1334]                    assume msgsender_MSG != null;
[L1335]                    __tmp__Balance[this] := 0;
[L1336]                    __tmp___primary_Secondary[this] := null;
[L1337]                    __tmp___primary_Secondary[this] := msgsender_MSG;
[L1355]        RET         call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1356]        COND FALSE  !(revert)
[L1484]        RET         call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1485]        COND FALSE  !(revert)
[L1490]        CALL        call Escrow_Escrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1448]                    assume msgsender_MSG != null;
[L1449]                    __tmp__Balance[this] := 0;
[L1450]        CALL        call __var_2 := FreshRefGenerator__fail();
[L1168]                    havoc newRef;
[L1169]                    assume __tmp__Alloc[newRef] == false;
[L1170]                    __tmp__Alloc[newRef] := true;
[L1171]                    assume newRef != null;
[L1450]        RET         call __var_2 := FreshRefGenerator__fail();
[L1451]        COND FALSE  !(revert)
[L1456]                    __tmp___deposits_Escrow[this] := __var_2;
[L1457]                    __tmp__M_Ref_int__deposits0[__tmp___deposits_Escrow[this]] := zeroRefIntArr();
[L1458]                    __tmp__sum__deposits0[__tmp___deposits_Escrow[this]] := 0;
[L1490]        RET         call Escrow_Escrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1491]        COND FALSE  !(revert)
[L1870]        RET         call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L1871]        COND FALSE  !(revert)
[L1876]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1848]                    assume msgsender_MSG != null;
[L1849]                    __tmp__Balance[this] := 0;
[L1876]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1877]        COND FALSE  !(revert)
[L2070]        RET         call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L2071]        COND FALSE  !(revert)
[L2076]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2018]                    assume msgsender_MSG != null;
[L2019]                    __tmp__Balance[this] := 0;
[L2020]                    __tmp___beneficiary_RefundEscrow[this] := null;
[L2021]                    __var_7 := null;
[L2022]        COND FALSE  !(!(beneficiary_s294 != null))
[L2028]                    __tmp___beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2029]                    __tmp___state_RefundEscrow[this] := 0;
[L2076]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2077]        COND FALSE  !(revert)
[L543]         RET         call RefundEscrow_RefundEscrow__fail(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L544]                     assume revert || gas < 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND FALSE  !(choice == 2)
[L3791]        COND TRUE   choice == 1
[L3793]                    gas := gas - 21000;
[L3794]        COND TRUE   gas >= 0
[L3796]                    assume msgvalue_MSG == 0;
[L3797]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3797]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND FALSE  !(choice == 1)
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:31:15,307 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:31:15,307 INFO  L82        PathProgramCache]: Analyzing trace with hash 1431758475, now seen corresponding path program 1 times
[2020-05-30 20:31:15,308 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:31:15,316 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:31:15,370 INFO  L134       CoverageAnalysis]: Checked inductivity of 99 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 99 trivial. 0 not checked.
[2020-05-30 20:31:15,370 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:31:15,370 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-05-30 20:31:15,371 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:31:15,371 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-05-30 20:31:15,371 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=6, Invalid=6, Unknown=0, NotChecked=0, Total=12
[2020-05-30 20:31:15,371 INFO  L87              Difference]: Start difference. First operand 12218 states and 13682 transitions. cyclomatic complexity: 1501 Second operand 4 states.
[2020-05-30 20:31:16,086 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:31:16,087 INFO  L93              Difference]: Finished difference Result 12544 states and 14859 transitions.
[2020-05-30 20:31:16,087 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 4 states. 
[2020-05-30 20:31:16,087 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 12544 states and 14859 transitions.
[2020-05-30 20:31:16,119 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 12
[2020-05-30 20:31:16,158 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 12544 states to 12148 states and 14429 transitions.
[2020-05-30 20:31:16,158 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1988
[2020-05-30 20:31:16,159 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1988
[2020-05-30 20:31:16,159 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 12148 states and 14429 transitions.
[2020-05-30 20:31:16,167 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:31:16,167 INFO  L728         BuchiCegarLoop]: Abstraction has 12148 states and 14429 transitions.
[2020-05-30 20:31:16,171 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 12148 states and 14429 transitions.
[2020-05-30 20:31:16,228 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 12148 to 8906.
[2020-05-30 20:31:16,228 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8906 states.
[2020-05-30 20:31:16,238 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8906 states to 8906 states and 9999 transitions.
[2020-05-30 20:31:16,238 INFO  L751         BuchiCegarLoop]: Abstraction has 8906 states and 9999 transitions.
[2020-05-30 20:31:16,238 INFO  L631         BuchiCegarLoop]: Abstraction has 8906 states and 9999 transitions.
[2020-05-30 20:31:16,238 INFO  L445         BuchiCegarLoop]: ======== Iteration 26============
[2020-05-30 20:31:16,238 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8906 states and 9999 transitions.
[2020-05-30 20:31:16,247 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:31:16,247 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:31:16,247 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:31:16,248 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:31:16,248 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND TRUE   choice == 10
[L3712]                    gas := gas - 21000;
[L3713]        COND TRUE   gas >= 0
[L3715]                    assume msgvalue_MSG == 0;
[L3716]        CALL        call transferPrimary_Secondary(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L230]                     havoc __exception;
[L231]                     revert := false;
[L232]         COND FALSE  !(__exception)
[L251]         CALL        call transferPrimary_Secondary__success(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L1423]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1423]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1424]        COND FALSE  !(revert)
[L1429]                    gas := gas - 88;
[L1430]                    __var_1 := null;
[L1431]        COND FALSE  !(!(recipient_s113 != null))
[L1437]                    gas := gas - 40534;
[L1438]                    _primary_Secondary[this] := recipient_s113;
[L1439]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L251]         RET         call transferPrimary_Secondary__success(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L252]                     assume !revert && gas >= 0;
[L3716]        RET         call transferPrimary_Secondary(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND FALSE  !(choice == 2)
[L3791]        COND TRUE   choice == 1
[L3793]                    gas := gas - 21000;
[L3794]        COND TRUE   gas >= 0
[L3796]                    assume msgvalue_MSG == 0;
[L3797]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3797]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND FALSE  !(choice == 1)
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:31:16,252 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:31:16,252 INFO  L82        PathProgramCache]: Analyzing trace with hash -294723510, now seen corresponding path program 1 times
[2020-05-30 20:31:16,252 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:31:16,271 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:31:16,687 INFO  L134       CoverageAnalysis]: Checked inductivity of 294 backedges. 49 proven. 47 refuted. 0 times theorem prover too weak. 198 trivial. 0 not checked.
[2020-05-30 20:31:16,687 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:31:16,687 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [47] total 47
[2020-05-30 20:31:16,687 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:31:16,688 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 48 interpolants.
[2020-05-30 20:31:16,689 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=156, Invalid=2100, Unknown=0, NotChecked=0, Total=2256
[2020-05-30 20:31:16,689 INFO  L87              Difference]: Start difference. First operand 8906 states and 9999 transitions. cyclomatic complexity: 1117 Second operand 48 states.
[2020-05-30 20:31:34,643 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:31:34,643 INFO  L93              Difference]: Finished difference Result 10226 states and 11833 transitions.
[2020-05-30 20:31:34,643 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 75 states. 
[2020-05-30 20:31:34,644 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 10226 states and 11833 transitions.
[2020-05-30 20:31:34,669 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 8
[2020-05-30 20:31:34,696 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 10226 states to 10226 states and 11833 transitions.
[2020-05-30 20:31:34,696 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1580
[2020-05-30 20:31:34,696 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1580
[2020-05-30 20:31:34,697 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 10226 states and 11833 transitions.
[2020-05-30 20:31:34,702 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:31:34,702 INFO  L728         BuchiCegarLoop]: Abstraction has 10226 states and 11833 transitions.
[2020-05-30 20:31:34,705 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 10226 states and 11833 transitions.
[2020-05-30 20:31:34,756 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 10226 to 9645.
[2020-05-30 20:31:34,757 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 9645 states.
[2020-05-30 20:31:34,769 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 9645 states to 9645 states and 10822 transitions.
[2020-05-30 20:31:34,769 INFO  L751         BuchiCegarLoop]: Abstraction has 9645 states and 10822 transitions.
[2020-05-30 20:31:34,769 INFO  L631         BuchiCegarLoop]: Abstraction has 9645 states and 10822 transitions.
[2020-05-30 20:31:34,769 INFO  L445         BuchiCegarLoop]: ======== Iteration 27============
[2020-05-30 20:31:34,769 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 9645 states and 10822 transitions.
[2020-05-30 20:31:34,778 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:31:34,778 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:31:34,778 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:31:34,779 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:31:34,779 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND FALSE  !(choice == 2)
[L3791]        COND TRUE   choice == 1
[L3793]                    gas := gas - 21000;
[L3794]        COND TRUE   gas >= 0
[L3796]                    assume msgvalue_MSG == 0;
[L3797]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3797]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND TRUE   choice == 1
[L3793]              gas := gas - 21000;
[L3794]  COND TRUE   gas >= 0
[L3796]              assume msgvalue_MSG == 0;
[L3797]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND TRUE   gas > 2300
[L2352]              gas := 2300;
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]              havoc __exception;
[L3245]  COND FALSE  !(__exception)
[L3270]  COND TRUE   Balance[from] >= amount
[L3272]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND FALSE  !(DType[to] == RefundEscrow)
[L2428]  COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]  COND FALSE  !(DType[to] == Escrow)
[L2436]  COND FALSE  !(DType[to] == Secondary)
[L2442]  CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]              assume Balance[from] >= amount;
[L2833]              Balance[from] := Balance[from] - amount;
[L2834]              Balance[to] := Balance[to] + amount;
[L2835]  COND FALSE  !(choice == 0)
[L2841]  COND TRUE   gas < 21000
[L2442]  RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]  COND FALSE  !(revert)
[L3272]  RET         call FallbackDispatch__success(from, to, amount);
[L3273]              success := true;
[L3280]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3797]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:31:34,783 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:31:34,783 INFO  L82        PathProgramCache]: Analyzing trace with hash -904260279, now seen corresponding path program 2 times
[2020-05-30 20:31:34,783 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:31:34,798 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:31:34,974 INFO  L134       CoverageAnalysis]: Checked inductivity of 244 backedges. 4 proven. 72 refuted. 0 times theorem prover too weak. 168 trivial. 0 not checked.
[2020-05-30 20:31:34,974 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:31:34,975 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [13] total 13
[2020-05-30 20:31:34,975 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:31:34,975 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 13 interpolants.
[2020-05-30 20:31:34,975 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=26, Invalid=130, Unknown=0, NotChecked=0, Total=156
[2020-05-30 20:31:34,975 INFO  L87              Difference]: Start difference. First operand 9645 states and 10822 transitions. cyclomatic complexity: 1218 Second operand 13 states.
[2020-05-30 20:31:35,931 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:31:35,931 INFO  L93              Difference]: Finished difference Result 5599 states and 6275 transitions.
[2020-05-30 20:31:35,931 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 12 states. 
[2020-05-30 20:31:35,932 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 5599 states and 6275 transitions.
[2020-05-30 20:31:35,941 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:31:35,950 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 5599 states to 5282 states and 5928 transitions.
[2020-05-30 20:31:35,950 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 781
[2020-05-30 20:31:35,951 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 781
[2020-05-30 20:31:35,951 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 5282 states and 5928 transitions.
[2020-05-30 20:31:35,953 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:31:35,953 INFO  L728         BuchiCegarLoop]: Abstraction has 5282 states and 5928 transitions.
[2020-05-30 20:31:35,955 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 5282 states and 5928 transitions.
[2020-05-30 20:31:35,975 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 5282 to 5231.
[2020-05-30 20:31:35,975 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 5231 states.
[2020-05-30 20:31:35,981 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 5231 states to 5231 states and 5838 transitions.
[2020-05-30 20:31:35,981 INFO  L751         BuchiCegarLoop]: Abstraction has 5231 states and 5838 transitions.
[2020-05-30 20:31:35,981 INFO  L631         BuchiCegarLoop]: Abstraction has 5231 states and 5838 transitions.
[2020-05-30 20:31:35,981 INFO  L445         BuchiCegarLoop]: ======== Iteration 28============
[2020-05-30 20:31:35,981 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 5231 states and 5838 transitions.
[2020-05-30 20:31:35,985 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:31:35,985 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:31:35,985 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:31:35,987 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:31:35,987 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND TRUE   choice == 10
[L3712]                    gas := gas - 21000;
[L3713]        COND TRUE   gas >= 0
[L3715]                    assume msgvalue_MSG == 0;
[L3716]        CALL        call transferPrimary_Secondary(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L230]                     havoc __exception;
[L231]                     revert := false;
[L232]         COND FALSE  !(__exception)
[L251]         CALL        call transferPrimary_Secondary__success(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L1423]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1423]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1424]        COND FALSE  !(revert)
[L1429]                    gas := gas - 88;
[L1430]                    __var_1 := null;
[L1431]        COND FALSE  !(!(recipient_s113 != null))
[L1437]                    gas := gas - 40534;
[L1438]                    _primary_Secondary[this] := recipient_s113;
[L1439]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L251]         RET         call transferPrimary_Secondary__success(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L252]                     assume !revert && gas >= 0;
[L3716]        RET         call transferPrimary_Secondary(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND FALSE  !(choice == 2)
[L3791]        COND TRUE   choice == 1
[L3793]                    gas := gas - 21000;
[L3794]        COND TRUE   gas >= 0
[L3796]                    assume msgvalue_MSG == 0;
[L3797]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3797]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND TRUE   choice == 1
[L3793]              gas := gas - 21000;
[L3794]  COND TRUE   gas >= 0
[L3796]              assume msgvalue_MSG == 0;
[L3797]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND TRUE   gas > 2300
[L2352]              gas := 2300;
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]              havoc __exception;
[L3245]  COND FALSE  !(__exception)
[L3270]  COND TRUE   Balance[from] >= amount
[L3272]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND TRUE   DType[to] == RefundEscrow
[L2426]              assume amount == 0;
[L3272]  RET         call FallbackDispatch__success(from, to, amount);
[L3273]              success := true;
[L3280]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3797]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:31:35,990 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:31:35,990 INFO  L82        PathProgramCache]: Analyzing trace with hash -388409617, now seen corresponding path program 1 times
[2020-05-30 20:31:35,990 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:31:36,018 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:31:36,398 INFO  L134       CoverageAnalysis]: Checked inductivity of 294 backedges. 48 proven. 32 refuted. 0 times theorem prover too weak. 214 trivial. 0 not checked.
[2020-05-30 20:31:36,398 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:31:36,398 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [43] total 43
[2020-05-30 20:31:36,398 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:31:36,398 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 44 interpolants.
[2020-05-30 20:31:36,399 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=146, Invalid=1746, Unknown=0, NotChecked=0, Total=1892
[2020-05-30 20:31:36,399 INFO  L87              Difference]: Start difference. First operand 5231 states and 5838 transitions. cyclomatic complexity: 638 Second operand 44 states.
[2020-05-30 20:31:41,972 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:31:41,973 INFO  L93              Difference]: Finished difference Result 5346 states and 6066 transitions.
[2020-05-30 20:31:41,973 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 62 states. 
[2020-05-30 20:31:41,973 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 5346 states and 6066 transitions.
[2020-05-30 20:31:41,982 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:31:41,992 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 5346 states to 5322 states and 5984 transitions.
[2020-05-30 20:31:41,992 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 786
[2020-05-30 20:31:41,992 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 786
[2020-05-30 20:31:41,992 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 5322 states and 5984 transitions.
[2020-05-30 20:31:41,995 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:31:41,995 INFO  L728         BuchiCegarLoop]: Abstraction has 5322 states and 5984 transitions.
[2020-05-30 20:31:41,997 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 5322 states and 5984 transitions.
[2020-05-30 20:31:42,017 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 5322 to 5236.
[2020-05-30 20:31:42,018 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 5236 states.
[2020-05-30 20:31:42,023 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 5236 states to 5236 states and 5828 transitions.
[2020-05-30 20:31:42,023 INFO  L751         BuchiCegarLoop]: Abstraction has 5236 states and 5828 transitions.
[2020-05-30 20:31:42,023 INFO  L631         BuchiCegarLoop]: Abstraction has 5236 states and 5828 transitions.
[2020-05-30 20:31:42,023 INFO  L445         BuchiCegarLoop]: ======== Iteration 29============
[2020-05-30 20:31:42,023 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 5236 states and 5828 transitions.
[2020-05-30 20:31:42,027 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:31:42,028 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:31:42,028 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:31:42,029 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:31:42,029 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND TRUE   choice == 10
[L3712]                    gas := gas - 21000;
[L3713]        COND TRUE   gas >= 0
[L3715]                    assume msgvalue_MSG == 0;
[L3716]        CALL        call transferPrimary_Secondary(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L230]                     havoc __exception;
[L231]                     revert := false;
[L232]         COND FALSE  !(__exception)
[L251]         CALL        call transferPrimary_Secondary__success(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L1423]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1423]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1424]        COND FALSE  !(revert)
[L1429]                    gas := gas - 88;
[L1430]                    __var_1 := null;
[L1431]        COND FALSE  !(!(recipient_s113 != null))
[L1437]                    gas := gas - 40534;
[L1438]                    _primary_Secondary[this] := recipient_s113;
[L1439]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L251]         RET         call transferPrimary_Secondary__success(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L252]                     assume !revert && gas >= 0;
[L3716]        RET         call transferPrimary_Secondary(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND FALSE  !(choice == 2)
[L3791]        COND TRUE   choice == 1
[L3793]                    gas := gas - 21000;
[L3794]        COND TRUE   gas >= 0
[L3796]                    assume msgvalue_MSG == 0;
[L3797]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3797]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND TRUE   choice == 1
[L3793]              gas := gas - 21000;
[L3794]  COND TRUE   gas >= 0
[L3796]              assume msgvalue_MSG == 0;
[L3797]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND TRUE   gas > 2300
[L2352]              gas := 2300;
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]              havoc __exception;
[L3245]  COND FALSE  !(__exception)
[L3270]  COND TRUE   Balance[from] >= amount
[L3272]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND TRUE   DType[to] == RefundEscrow
[L2426]              assume amount == 0;
[L3272]  RET         call FallbackDispatch__success(from, to, amount);
[L3273]              success := true;
[L3280]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3797]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:31:42,032 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:31:42,032 INFO  L82        PathProgramCache]: Analyzing trace with hash 920018210, now seen corresponding path program 1 times
[2020-05-30 20:31:42,033 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:31:42,059 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:31:42,439 INFO  L134       CoverageAnalysis]: Checked inductivity of 239 backedges. 39 proven. 41 refuted. 0 times theorem prover too weak. 159 trivial. 0 not checked.
[2020-05-30 20:31:42,439 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:31:42,439 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [43] total 43
[2020-05-30 20:31:42,440 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:31:42,440 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 44 interpolants.
[2020-05-30 20:31:42,440 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=146, Invalid=1746, Unknown=0, NotChecked=0, Total=1892
[2020-05-30 20:31:42,440 INFO  L87              Difference]: Start difference. First operand 5236 states and 5828 transitions. cyclomatic complexity: 620 Second operand 44 states.
[2020-05-30 20:31:50,416 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:31:50,416 INFO  L93              Difference]: Finished difference Result 5318 states and 5981 transitions.
[2020-05-30 20:31:50,416 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 58 states. 
[2020-05-30 20:31:50,416 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 5318 states and 5981 transitions.
[2020-05-30 20:31:50,428 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:31:50,436 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 5318 states to 5018 states and 5494 transitions.
[2020-05-30 20:31:50,436 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 786
[2020-05-30 20:31:50,436 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 786
[2020-05-30 20:31:50,436 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 5018 states and 5494 transitions.
[2020-05-30 20:31:50,438 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:31:50,438 INFO  L728         BuchiCegarLoop]: Abstraction has 5018 states and 5494 transitions.
[2020-05-30 20:31:50,441 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 5018 states and 5494 transitions.
[2020-05-30 20:31:50,456 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 5018 to 4897.
[2020-05-30 20:31:50,457 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 4897 states.
[2020-05-30 20:31:50,461 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 4897 states to 4897 states and 5358 transitions.
[2020-05-30 20:31:50,461 INFO  L751         BuchiCegarLoop]: Abstraction has 4897 states and 5358 transitions.
[2020-05-30 20:31:50,461 INFO  L631         BuchiCegarLoop]: Abstraction has 4897 states and 5358 transitions.
[2020-05-30 20:31:50,461 INFO  L445         BuchiCegarLoop]: ======== Iteration 30============
[2020-05-30 20:31:50,461 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 4897 states and 5358 transitions.
[2020-05-30 20:31:50,465 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:31:50,465 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:31:50,465 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:31:50,466 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:31:50,466 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND FALSE  !(choice == 2)
[L3791]        COND TRUE   choice == 1
[L3793]                    gas := gas - 21000;
[L3794]        COND TRUE   gas >= 0
[L3796]                    assume msgvalue_MSG == 0;
[L3797]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3797]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND TRUE   choice == 1
[L3793]              gas := gas - 21000;
[L3794]  COND TRUE   gas >= 0
[L3796]              assume msgvalue_MSG == 0;
[L3797]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND TRUE   gas > 2300
[L2352]              gas := 2300;
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]              havoc __exception;
[L3245]  COND FALSE  !(__exception)
[L3270]  COND TRUE   Balance[from] >= amount
[L3272]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND TRUE   DType[to] == RefundEscrow
[L2426]              assume amount == 0;
[L3272]  RET         call FallbackDispatch__success(from, to, amount);
[L3273]              success := true;
[L3280]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3797]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:31:50,470 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:31:50,470 INFO  L82        PathProgramCache]: Analyzing trace with hash -1783166544, now seen corresponding path program 1 times
[2020-05-30 20:31:50,470 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:31:50,485 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:31:50,604 INFO  L134       CoverageAnalysis]: Checked inductivity of 199 backedges. 1 proven. 32 refuted. 0 times theorem prover too weak. 166 trivial. 0 not checked.
[2020-05-30 20:31:50,604 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:31:50,604 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [13] total 13
[2020-05-30 20:31:50,604 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:31:50,605 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 13 interpolants.
[2020-05-30 20:31:50,605 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=26, Invalid=130, Unknown=0, NotChecked=0, Total=156
[2020-05-30 20:31:50,605 INFO  L87              Difference]: Start difference. First operand 4897 states and 5358 transitions. cyclomatic complexity: 471 Second operand 13 states.
[2020-05-30 20:31:50,859 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:31:50,859 INFO  L93              Difference]: Finished difference Result 1013 states and 1081 transitions.
[2020-05-30 20:31:50,859 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 12 states. 
[2020-05-30 20:31:50,859 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 1013 states and 1081 transitions.
[2020-05-30 20:31:50,861 INFO  L131   ngComponentsAnalysis]: Automaton has 0 accepting balls. 0
[2020-05-30 20:31:50,861 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 1013 states to 0 states and 0 transitions.
[2020-05-30 20:31:50,861 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 0
[2020-05-30 20:31:50,861 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 0
[2020-05-30 20:31:50,861 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 0 states and 0 transitions.
[2020-05-30 20:31:50,861 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:31:50,861 INFO  L728         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-05-30 20:31:50,861 INFO  L751         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-05-30 20:31:50,861 INFO  L631         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-05-30 20:31:50,861 INFO  L445         BuchiCegarLoop]: ======== Iteration 31============
[2020-05-30 20:31:50,861 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 0 states and 0 transitions.
[2020-05-30 20:31:50,861 INFO  L131   ngComponentsAnalysis]: Automaton has 0 accepting balls. 0
[2020-05-30 20:31:50,861 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is true
[2020-05-30 20:31:50,864 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer CFG 30.05 08:31:50 BasicIcfg
[2020-05-30 20:31:50,864 INFO  L132        PluginConnector]: ------------------------ END BuchiAutomizer----------------------------
[2020-05-30 20:31:50,864 INFO  L168              Benchmark]: Toolchain (without parser) took 199502.41 ms. Allocated memory was 514.9 MB in the beginning and 4.7 GB in the end (delta: 4.2 GB). Free memory was 457.5 MB in the beginning and 1.7 GB in the end (delta: -1.2 GB). Peak memory consumption was 2.9 GB. Max. memory is 15.3 GB.
[2020-05-30 20:31:50,865 INFO  L168              Benchmark]: Boogie PL CUP Parser took 0.13 ms. Allocated memory is still 514.9 MB. Free memory is still 468.2 MB. There was no memory consumed. Max. memory is 15.3 GB.
[2020-05-30 20:31:50,865 INFO  L168              Benchmark]: Boogie Preprocessor took 72.44 ms. Allocated memory is still 514.9 MB. Free memory was 457.5 MB in the beginning and 449.4 MB in the end (delta: 8.1 MB). Peak memory consumption was 8.1 MB. Max. memory is 15.3 GB.
[2020-05-30 20:31:50,866 INFO  L168              Benchmark]: UtopiaSpecLang took 45.67 ms. Allocated memory is still 514.9 MB. Free memory was 449.4 MB in the beginning and 444.0 MB in the end (delta: 5.4 MB). Peak memory consumption was 5.4 MB. Max. memory is 15.3 GB.
[2020-05-30 20:31:50,867 INFO  L168              Benchmark]: Boogie Printer took 11.85 ms. Allocated memory is still 514.9 MB. Free memory was 444.0 MB in the beginning and 442.6 MB in the end (delta: 1.3 MB). Peak memory consumption was 1.3 MB. Max. memory is 15.3 GB.
[2020-05-30 20:31:50,867 INFO  L168              Benchmark]: RCFGBuilder took 536.43 ms. Allocated memory is still 514.9 MB. Free memory was 442.6 MB in the beginning and 467.3 MB in the end (delta: -24.6 MB). Peak memory consumption was 100.0 MB. Max. memory is 15.3 GB.
[2020-05-30 20:31:50,867 INFO  L168              Benchmark]: UtopiaLTL2Aut took 43.58 ms. Allocated memory is still 514.9 MB. Free memory was 467.3 MB in the beginning and 462.6 MB in the end (delta: 4.7 MB). Peak memory consumption was 4.7 MB. Max. memory is 15.3 GB.
[2020-05-30 20:31:50,868 INFO  L168              Benchmark]: BÃ¼chi Program Product took 5454.53 ms. Allocated memory was 514.9 MB in the beginning and 1.3 GB in the end (delta: 755.5 MB). Free memory was 462.6 MB in the beginning and 351.5 MB in the end (delta: 111.1 MB). Peak memory consumption was 1.1 GB. Max. memory is 15.3 GB.
[2020-05-30 20:31:50,868 INFO  L168              Benchmark]: BlockEncodingV2 took 663.83 ms. Allocated memory was 1.3 GB in the beginning and 1.6 GB in the end (delta: 371.7 MB). Free memory was 351.5 MB in the beginning and 1.1 GB in the end (delta: -719.2 MB). Peak memory consumption was 255.0 MB. Max. memory is 15.3 GB.
[2020-05-30 20:31:50,868 INFO  L168              Benchmark]: BuchiAutomizer took 192671.46 ms. Allocated memory was 1.6 GB in the beginning and 4.7 GB in the end (delta: 3.1 GB). Free memory was 1.1 GB in the beginning and 1.7 GB in the end (delta: -632.1 MB). Peak memory consumption was 2.4 GB. Max. memory is 15.3 GB.
[2020-05-30 20:31:50,873 INFO  L337   ainManager$Toolchain]: #######################  End [Toolchain 1] #######################
 --- Results ---
 * Results from de.uni_freiburg.informatik.ultimate.plugins.blockencoding:
  - StatisticsResult: Initial Icfg
    15391 locations, 64141 edges
  - StatisticsResult: Encoded RCFG
    15167 locations, 62811 edges
 * Results from de.uni_freiburg.informatik.ultimate.core:
  - StatisticsResult: Toolchain Benchmarks
    Benchmark results are:
 * Boogie PL CUP Parser took 0.13 ms. Allocated memory is still 514.9 MB. Free memory is still 468.2 MB. There was no memory consumed. Max. memory is 15.3 GB.
 * Boogie Preprocessor took 72.44 ms. Allocated memory is still 514.9 MB. Free memory was 457.5 MB in the beginning and 449.4 MB in the end (delta: 8.1 MB). Peak memory consumption was 8.1 MB. Max. memory is 15.3 GB.
 * UtopiaSpecLang took 45.67 ms. Allocated memory is still 514.9 MB. Free memory was 449.4 MB in the beginning and 444.0 MB in the end (delta: 5.4 MB). Peak memory consumption was 5.4 MB. Max. memory is 15.3 GB.
 * Boogie Printer took 11.85 ms. Allocated memory is still 514.9 MB. Free memory was 444.0 MB in the beginning and 442.6 MB in the end (delta: 1.3 MB). Peak memory consumption was 1.3 MB. Max. memory is 15.3 GB.
 * RCFGBuilder took 536.43 ms. Allocated memory is still 514.9 MB. Free memory was 442.6 MB in the beginning and 467.3 MB in the end (delta: -24.6 MB). Peak memory consumption was 100.0 MB. Max. memory is 15.3 GB.
 * UtopiaLTL2Aut took 43.58 ms. Allocated memory is still 514.9 MB. Free memory was 467.3 MB in the beginning and 462.6 MB in the end (delta: 4.7 MB). Peak memory consumption was 4.7 MB. Max. memory is 15.3 GB.
 * BÃ¼chi Program Product took 5454.53 ms. Allocated memory was 514.9 MB in the beginning and 1.3 GB in the end (delta: 755.5 MB). Free memory was 462.6 MB in the beginning and 351.5 MB in the end (delta: 111.1 MB). Peak memory consumption was 1.1 GB. Max. memory is 15.3 GB.
 * BlockEncodingV2 took 663.83 ms. Allocated memory was 1.3 GB in the beginning and 1.6 GB in the end (delta: 371.7 MB). Free memory was 351.5 MB in the beginning and 1.1 GB in the end (delta: -719.2 MB). Peak memory consumption was 255.0 MB. Max. memory is 15.3 GB.
 * BuchiAutomizer took 192671.46 ms. Allocated memory was 1.6 GB in the beginning and 4.7 GB in the end (delta: 3.1 GB). Free memory was 1.1 GB in the beginning and 1.7 GB in the end (delta: -632.1 MB). Peak memory consumption was 2.4 GB. Max. memory is 15.3 GB.
 * Results from de.uni_freiburg.informatik.ultimate.buchiprogramproduct:
  - StatisticsResult: Initial property automaton
    8 locations, 27 edges
  - StatisticsResult: Initial RCFG
    1570 locations, 2187 edges
  - StatisticsResult: BuchiProgram size
    15391 locations, 64141 edges
 * Results from de.uni_freiburg.informatik.ultimate.plugins.generator.traceabstraction:
  - StatisticsResult: Constructed decomposition of program
    Your program was decomposed into 30 terminating modules (30 trivial, 0 deterministic, 0 nondeterministic). 30 modules have a trivial ranking function, the largest among these consists of 48 locations.
  - StatisticsResult: Timing statistics
    BÃ¼chiAutomizer plugin needed 192.6s and 31 iterations.  TraceHistogramMax:4. Analysis of lassos took 6.0s. Construction of modules took 142.5s. BÃ¼chi inclusion checks took 35.8s. Highest rank in rank-based complementation 0. Minimization of det autom 30. Minimization of nondet autom 0. Automata minimization 3.8s AutomataMinimizationTime, 29 MinimizatonAttempts, 15822 StatesRemovedByMinimization, 24 NontrivialMinimizations. Non-live state removal took 2.8s Buchi closure took 0.0s. Biggest automaton had 32680 states and ocurred in iteration 14.	Nontrivial modules had stage [0, 0, 0, 0, 0].	InterpolantCoveringCapabilityFinite: 0/0	InterpolantCoveringCapabilityBuchi: 0/0	HoareTripleCheckerStatistics: 265130 SDtfs, 339083 SDslu, 590222 SDs, 0 SdLazy, 1524355 SolverSat, 73050 SolverUnsat, 0 SolverUnknown, 0 SolverNotchecked, 142.5s Time	LassoAnalysisResults: nont0 unkn0 SFLI0 SFLT0 conc0 concLT0 SILN0 SILU30 SILI0 SILT0 lasso0 LassoPreprocessingBenchmarks: LassoTerminationAnalysisBenchmarks: not availableLassoTerminationAnalysisBenchmarks: LassoNonterminationAnalysisSatFixpoint: 0	LassoNonterminationAnalysisSatUnbounded: 0	LassoNonterminationAnalysisUnsat: 0	LassoNonterminationAnalysisUnknown: 0	LassoNonterminationAnalysisTime: 0.0s	
  - AllSpecificationsHoldResult: All specifications hold
    Buchi Automizer proved that the LTL property ( ( <>(success_deposit_RefundEscrow0) ) && ( <>(success_beneficiaryWithdraw_RefundEscrow0) ) )&& ! ( ( []( (success_close_RefundEscrow0) ==> ( <>(success_send__success0) ) ) )) holds
RESULT: Ultimate proved your program to be correct!
Received shutdown request...
