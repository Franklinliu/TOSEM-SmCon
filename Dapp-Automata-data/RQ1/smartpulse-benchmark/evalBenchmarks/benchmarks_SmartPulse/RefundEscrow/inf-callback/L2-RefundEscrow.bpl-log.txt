This is Ultimate 0.1.24-9993c5c-m
[2020-05-30 20:46:22,493 INFO  L170        SettingsManager]: Resetting all preferences to default values...
[2020-05-30 20:46:22,494 INFO  L174        SettingsManager]: Resetting UltimateCore preferences to default values
[2020-05-30 20:46:22,505 INFO  L177        SettingsManager]: Ultimate Commandline Interface provides no preferences, ignoring...
[2020-05-30 20:46:22,505 INFO  L174        SettingsManager]: Resetting Boogie Preprocessor preferences to default values
[2020-05-30 20:46:22,506 INFO  L174        SettingsManager]: Resetting Boogie Procedure Inliner preferences to default values
[2020-05-30 20:46:22,508 INFO  L174        SettingsManager]: Resetting Abstract Interpretation preferences to default values
[2020-05-30 20:46:22,509 INFO  L174        SettingsManager]: Resetting LassoRanker preferences to default values
[2020-05-30 20:46:22,511 INFO  L174        SettingsManager]: Resetting Reaching Definitions preferences to default values
[2020-05-30 20:46:22,512 INFO  L174        SettingsManager]: Resetting SyntaxChecker preferences to default values
[2020-05-30 20:46:22,513 INFO  L177        SettingsManager]: BÃ¼chi Program Product provides no preferences, ignoring...
[2020-05-30 20:46:22,528 INFO  L174        SettingsManager]: Resetting LTL2Aut preferences to default values
[2020-05-30 20:46:22,530 INFO  L174        SettingsManager]: Resetting PEA to Boogie preferences to default values
[2020-05-30 20:46:22,531 INFO  L174        SettingsManager]: Resetting BlockEncodingV2 preferences to default values
[2020-05-30 20:46:22,533 INFO  L174        SettingsManager]: Resetting ChcToBoogie preferences to default values
[2020-05-30 20:46:22,534 INFO  L174        SettingsManager]: Resetting AutomataScriptInterpreter preferences to default values
[2020-05-30 20:46:22,534 INFO  L174        SettingsManager]: Resetting BuchiAutomizer preferences to default values
[2020-05-30 20:46:22,536 INFO  L174        SettingsManager]: Resetting CACSL2BoogieTranslator preferences to default values
[2020-05-30 20:46:22,537 INFO  L174        SettingsManager]: Resetting CodeCheck preferences to default values
[2020-05-30 20:46:22,538 INFO  L174        SettingsManager]: Resetting InvariantSynthesis preferences to default values
[2020-05-30 20:46:22,539 INFO  L174        SettingsManager]: Resetting RCFGBuilder preferences to default values
[2020-05-30 20:46:22,540 INFO  L174        SettingsManager]: Resetting TraceAbstraction preferences to default values
[2020-05-30 20:46:22,542 INFO  L177        SettingsManager]: TraceAbstractionConcurrent provides no preferences, ignoring...
[2020-05-30 20:46:22,542 INFO  L177        SettingsManager]: TraceAbstractionWithAFAs provides no preferences, ignoring...
[2020-05-30 20:46:22,543 INFO  L174        SettingsManager]: Resetting TreeAutomizer preferences to default values
[2020-05-30 20:46:22,544 INFO  L174        SettingsManager]: Resetting IcfgToChc preferences to default values
[2020-05-30 20:46:22,544 INFO  L174        SettingsManager]: Resetting IcfgTransformer preferences to default values
[2020-05-30 20:46:22,545 INFO  L177        SettingsManager]: ReqToTest provides no preferences, ignoring...
[2020-05-30 20:46:22,545 INFO  L174        SettingsManager]: Resetting UtopiaLiveness preferences to default values
[2020-05-30 20:46:22,545 INFO  L174        SettingsManager]: Resetting UtopiaLTL2Aut preferences to default values
[2020-05-30 20:46:22,545 INFO  L174        SettingsManager]: Resetting UtopiaSpecLang preferences to default values
[2020-05-30 20:46:22,546 INFO  L174        SettingsManager]: Resetting Boogie Printer preferences to default values
[2020-05-30 20:46:22,547 INFO  L174        SettingsManager]: Resetting ChcSmtPrinter preferences to default values
[2020-05-30 20:46:22,548 INFO  L174        SettingsManager]: Resetting ReqPrinter preferences to default values
[2020-05-30 20:46:22,550 INFO  L174        SettingsManager]: Resetting Witness Printer preferences to default values
[2020-05-30 20:46:22,551 INFO  L177        SettingsManager]: Boogie PL CUP Parser provides no preferences, ignoring...
[2020-05-30 20:46:22,551 INFO  L174        SettingsManager]: Resetting CDTParser preferences to default values
[2020-05-30 20:46:22,552 INFO  L177        SettingsManager]: AutomataScriptParser provides no preferences, ignoring...
[2020-05-30 20:46:22,552 INFO  L177        SettingsManager]: ReqParser provides no preferences, ignoring...
[2020-05-30 20:46:22,552 INFO  L174        SettingsManager]: Resetting SmtParser preferences to default values
[2020-05-30 20:46:22,553 INFO  L174        SettingsManager]: Resetting Witness Parser preferences to default values
[2020-05-30 20:46:22,554 INFO  L181        SettingsManager]: Finished resetting all preferences to default values...
[2020-05-30 20:46:22,554 INFO  L98         SettingsManager]: Beginning loading settings from /Users/jon/Documents/Research/masterUltimate/SmartPulse/settings.epf
[2020-05-30 20:46:22,563 INFO  L110        SettingsManager]: Loading preferences was successful
[2020-05-30 20:46:22,563 INFO  L112        SettingsManager]: Preferences different from defaults after loading the file:
[2020-05-30 20:46:22,564 INFO  L131        SettingsManager]: Preferences of LTL2Aut differ from their defaults:
[2020-05-30 20:46:22,564 INFO  L133        SettingsManager]:  * Read property from file=true
[2020-05-30 20:46:22,564 INFO  L133        SettingsManager]:  * Path to LTL*BA executable (LTL2BA, LTL3BA)=/Users/jon/Documents/Research/devUltimate/ltl2ba
[2020-05-30 20:46:22,564 INFO  L131        SettingsManager]: Preferences of BlockEncodingV2 differ from their defaults:
[2020-05-30 20:46:22,565 INFO  L133        SettingsManager]:  * Maximize final states=false
[2020-05-30 20:46:22,565 INFO  L133        SettingsManager]:  * Minimize states even if more edges are added than removed.=true
[2020-05-30 20:46:22,565 INFO  L133        SettingsManager]:  * Minimize states using LBE with the strategy=NONE
[2020-05-30 20:46:22,565 INFO  L131        SettingsManager]: Preferences of BuchiAutomizer differ from their defaults:
[2020-05-30 20:46:22,565 INFO  L133        SettingsManager]:  * Compute Interpolants along a Counterexample=Craig_TreeInterpolation
[2020-05-30 20:46:22,565 INFO  L133        SettingsManager]:  * Use old map elimination=false
[2020-05-30 20:46:22,565 INFO  L133        SettingsManager]:  * Try twofold refinement=false
[2020-05-30 20:46:22,566 INFO  L131        SettingsManager]: Preferences of CACSL2BoogieTranslator differ from their defaults:
[2020-05-30 20:46:22,566 INFO  L133        SettingsManager]:  * Check unreachability of error function in SV-COMP mode=false
[2020-05-30 20:46:22,566 INFO  L133        SettingsManager]:  * Overapproximate operations on floating types=true
[2020-05-30 20:46:22,566 INFO  L133        SettingsManager]:  * Check division by zero=IGNORE
[2020-05-30 20:46:22,566 INFO  L133        SettingsManager]:  * Pointer to allocated memory at dereference=ASSUME
[2020-05-30 20:46:22,566 INFO  L133        SettingsManager]:  * If two pointers are subtracted or compared they have the same base address=ASSUME
[2020-05-30 20:46:22,566 INFO  L133        SettingsManager]:  * Check array bounds for arrays that are off heap=ASSUME
[2020-05-30 20:46:22,566 INFO  L133        SettingsManager]:  * Check if freed pointer was valid=false
[2020-05-30 20:46:22,566 INFO  L133        SettingsManager]:  * Use constant arrays=true
[2020-05-30 20:46:22,566 INFO  L133        SettingsManager]:  * Pointer base address is valid at dereference=ASSUME
[2020-05-30 20:46:22,567 INFO  L131        SettingsManager]: Preferences of RCFGBuilder differ from their defaults:
[2020-05-30 20:46:22,567 INFO  L133        SettingsManager]:  * Size of a code block=SingleStatement
[2020-05-30 20:46:22,567 INFO  L133        SettingsManager]:  * SMT solver=Internal_SMTInterpol
[2020-05-30 20:46:22,585 INFO  L81    nceAwareModelManager]: Repository-Root is: /var/folders/t6/mxckf6w17qb907fknyrxnkyc0000gp/T
[2020-05-30 20:46:22,595 INFO  L259   ainManager$Toolchain]: [Toolchain 1]: Applicable parser(s) successfully (re)initialized
[2020-05-30 20:46:22,597 INFO  L215   ainManager$Toolchain]: [Toolchain 1]: Toolchain selected.
[2020-05-30 20:46:22,598 INFO  L271        PluginConnector]: Initializing Boogie PL CUP Parser...
[2020-05-30 20:46:22,598 INFO  L276        PluginConnector]: Boogie PL CUP Parser initialized
[2020-05-30 20:46:22,599 INFO  L430   ainManager$Toolchain]: [Toolchain 1]: Parsing single file: /Users/jon/Documents/Research/masterUltimate/benchmarks/evalBenchmarks/benchmarks/RefundEscrow/inf-callback/L2-RefundEscrow.bpl
[2020-05-30 20:46:22,599 INFO  L111           BoogieParser]: Parsing: '/Users/jon/Documents/Research/masterUltimate/benchmarks/evalBenchmarks/benchmarks/RefundEscrow/inf-callback/L2-RefundEscrow.bpl'
[2020-05-30 20:46:22,657 INFO  L297   ainManager$Toolchain]: ####################### [Toolchain 1] #######################
[2020-05-30 20:46:22,659 INFO  L131        ToolchainWalker]: Walking toolchain with 8 elements.
[2020-05-30 20:46:22,659 INFO  L113        PluginConnector]: ------------------------Boogie Preprocessor----------------------------
[2020-05-30 20:46:22,659 INFO  L271        PluginConnector]: Initializing Boogie Preprocessor...
[2020-05-30 20:46:22,659 INFO  L276        PluginConnector]: Boogie Preprocessor initialized
[2020-05-30 20:46:22,672 INFO  L185        PluginConnector]: Executing the observer EnsureBoogieModelObserver from plugin Boogie Preprocessor for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:46:22" (1/1) ...
[2020-05-30 20:46:22,673 INFO  L185        PluginConnector]: Executing the observer TypeChecker from plugin Boogie Preprocessor for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:46:22" (1/1) ...
[2020-05-30 20:46:22,695 INFO  L185        PluginConnector]: Executing the observer ConstExpander from plugin Boogie Preprocessor for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:46:22" (1/1) ...
[2020-05-30 20:46:22,695 INFO  L185        PluginConnector]: Executing the observer StructExpander from plugin Boogie Preprocessor for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:46:22" (1/1) ...
[2020-05-30 20:46:22,708 INFO  L185        PluginConnector]: Executing the observer UnstructureCode from plugin Boogie Preprocessor for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:46:22" (1/1) ...
[2020-05-30 20:46:22,717 INFO  L185        PluginConnector]: Executing the observer FunctionInliner from plugin Boogie Preprocessor for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:46:22" (1/1) ...
[2020-05-30 20:46:22,722 INFO  L185        PluginConnector]: Executing the observer BoogieSymbolTableConstructor from plugin Boogie Preprocessor for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:46:22" (1/1) ...
[2020-05-30 20:46:22,730 INFO  L132        PluginConnector]: ------------------------ END Boogie Preprocessor----------------------------
[2020-05-30 20:46:22,730 INFO  L113        PluginConnector]: ------------------------UtopiaSpecLang----------------------------
[2020-05-30 20:46:22,730 INFO  L271        PluginConnector]: Initializing UtopiaSpecLang...
[2020-05-30 20:46:22,732 INFO  L276        PluginConnector]: UtopiaSpecLang initialized
[2020-05-30 20:46:22,734 INFO  L185        PluginConnector]: Executing the observer UtopiaSpecLangObserver from plugin UtopiaSpecLang for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:46:22" (1/1) ...
[2020-05-30 20:46:22,746 INFO  L975   opiaSpecLangObserver]: Parsing LTLPlus Formula to AstNode: [](finished(RefundEscrow.close, (ben == RefundEscrow.beneficiary())) ==> <>(finished(send(from, to, amt), (to == ben && amt == fsum(RefundEscrow.deposit, 2)))))
[2020-05-30 20:46:22,752 INFO  L979   opiaSpecLangObserver]: Successfully lexed: [](finished(RefundEscrow.close, (ben == RefundEscrow.beneficiary())) ==> <>(finished(send(from, to, amt), (to == ben && amt == fsum(RefundEscrow.deposit, 2)))))
[2020-05-30 20:46:22,758 INFO  L981   opiaSpecLangObserver]: Successfully parsed: [](finished(RefundEscrow.close, (ben == RefundEscrow.beneficiary())) ==> <>(finished(send(from, to, amt), (to == ben && amt == fsum(RefundEscrow.deposit, 2)))))
[2020-05-30 20:46:22,760 INFO  L677   opiaSpecLangObserver]: Parsed call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msg.sender, msg.value);  to CallStatement[false,[VariableLHS[__beneficiary_RefundEscrow0,<LOCAL,close_RefundEscrow>]],beneficiary_RefundEscrow__success,[IdentifierExpression[this,<IMPLEMENTATION_INPARAM,close_RefundEscrow>],IdentifierExpression[msgsender_MSG,<IMPLEMENTATION_INPARAM,close_RefundEscrow>],IdentifierExpression[msgvalue_MSG,<IMPLEMENTATION_INPARAM,close_RefundEscrow>]]]
[2020-05-30 20:46:22,761 INFO  L658   opiaSpecLangObserver]: Parsed var __beneficiary_RefundEscrow0: int;  to VariableDeclaration[[VarList[BPL: /Users/jon/Documents/Research/masterUltimate/benchmarks/evalBenchmarks/benchmarks/RefundEscrow/inf-callback/L2-RefundEscrow.bpl:7/0-7/4,[__beneficiary_RefundEscrow0],PrimitiveType[int],null]]]
[2020-05-30 20:46:22,761 INFO  L599   opiaSpecLangObserver]: Parsed ben==__beneficiary_RefundEscrow to BinaryExpression[COMPEQ,IdentifierExpression[ben,GLOBAL],IdentifierExpression[__beneficiary_RefundEscrow0,<LOCAL,close_RefundEscrow>]]
[2020-05-30 20:46:22,764 INFO  L599   opiaSpecLangObserver]: Parsed ( to==ben && amount==fsum_deposit_RefundEscrow_2_0 ) to BinaryExpression[LOGICAND,BinaryExpression[COMPEQ,IdentifierExpression[to,<IMPLEMENTATION_INPARAM,send__success>],IdentifierExpression[ben,GLOBAL]],BinaryExpression[COMPEQ,IdentifierExpression[amount,<IMPLEMENTATION_INPARAM,send__success>],IdentifierExpression[fsum_deposit_RefundEscrow_2_0,GLOBAL]]]
[2020-05-30 20:46:22,764 INFO  L968   opiaSpecLangObserver]: Compiling: [](finished(RefundEscrow.close, (ben == RefundEscrow.beneficiary())) ==> <>(finished(send(from, to, amt), (to == ben && amt == fsum(RefundEscrow.deposit, 2)))))
[2020-05-30 20:46:22,764 INFO  L970   opiaSpecLangObserver]: Compiled to ( []( AP(success_close_RefundEscrow0) ==> ( <>AP(success_send__success0) ) ) )
[2020-05-30 20:46:22,764 INFO  L975   opiaSpecLangObserver]: Parsing LTLPlus Formula to AstNode: <>(finished(RefundEscrow.deposit)) && <>(finished(RefundEscrow.beneficiaryWithdraw))
[2020-05-30 20:46:22,765 INFO  L979   opiaSpecLangObserver]: Successfully lexed: <>(finished(RefundEscrow.deposit)) && <>(finished(RefundEscrow.beneficiaryWithdraw))
[2020-05-30 20:46:22,765 INFO  L981   opiaSpecLangObserver]: Successfully parsed: <>(finished(RefundEscrow.deposit)) && <>(finished(RefundEscrow.beneficiaryWithdraw))
[2020-05-30 20:46:22,766 INFO  L968   opiaSpecLangObserver]: Compiling: <>(finished(RefundEscrow.deposit)) && <>(finished(RefundEscrow.beneficiaryWithdraw))
[2020-05-30 20:46:22,766 INFO  L970   opiaSpecLangObserver]: Compiled to ( ( <>AP(success_deposit_RefundEscrow0) ) && ( <>AP(success_beneficiaryWithdraw_RefundEscrow0) ) )
Executed UtopiaSpecLang
[2020-05-30 20:46:22,774 INFO  L202        PluginConnector]: Adding new model Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:46:22 PropertyContainer
[2020-05-30 20:46:22,774 INFO  L132        PluginConnector]: ------------------------ END UtopiaSpecLang----------------------------
[2020-05-30 20:46:22,774 INFO  L113        PluginConnector]: ------------------------Boogie Printer----------------------------
[2020-05-30 20:46:22,774 INFO  L271        PluginConnector]: Initializing Boogie Printer...
[2020-05-30 20:46:22,774 INFO  L276        PluginConnector]: Boogie Printer initialized
[2020-05-30 20:46:22,775 INFO  L185        PluginConnector]: Executing the observer BoogiePrinterObserver from plugin Boogie Printer for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:46:22" (1/2) ...
[2020-05-30 20:46:22,776 INFO  L116   oogiePrinterObserver]: File already exists and will be overwritten: /var/folders/t6/mxckf6w17qb907fknyrxnkyc0000gp/T/boogiePrinter.bpl
[2020-05-30 20:46:22,776 INFO  L120   oogiePrinterObserver]: Writing to file /var/folders/t6/mxckf6w17qb907fknyrxnkyc0000gp/T/boogiePrinter.bpl
[2020-05-30 20:46:22,786 INFO  L185        PluginConnector]: Executing the observer BoogiePrinterObserver from plugin Boogie Printer for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:46:22" (2/2) ...
[2020-05-30 20:46:22,786 INFO  L132        PluginConnector]: ------------------------ END Boogie Printer----------------------------
[2020-05-30 20:46:22,786 INFO  L113        PluginConnector]: ------------------------RCFGBuilder----------------------------
[2020-05-30 20:46:22,786 INFO  L271        PluginConnector]: Initializing RCFGBuilder...
[2020-05-30 20:46:22,786 INFO  L276        PluginConnector]: RCFGBuilder initialized
[2020-05-30 20:46:22,787 INFO  L185        PluginConnector]: Executing the observer RCFGBuilderObserver from plugin RCFGBuilder for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:46:22" (1/2) ...
[2020-05-30 20:46:22,829 INFO  L130     BoogieDeclarations]: Found specification of procedure FreshRefGenerator__success
[2020-05-30 20:46:22,829 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath_NoBaseCtor__success
[2020-05-30 20:46:22,829 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath
[2020-05-30 20:46:22,829 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath
[2020-05-30 20:46:22,830 INFO  L130     BoogieDeclarations]: Found specification of procedure sub_SafeMath__success
[2020-05-30 20:46:22,830 INFO  L130     BoogieDeclarations]: Found specification of procedure add_SafeMath__success
[2020-05-30 20:46:22,830 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary_NoBaseCtor__success
[2020-05-30 20:46:22,830 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary
[2020-05-30 20:46:22,830 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary
[2020-05-30 20:46:22,830 INFO  L130     BoogieDeclarations]: Found specification of procedure primary_Secondary
[2020-05-30 20:46:22,831 INFO  L138     BoogieDeclarations]: Found implementation of procedure primary_Secondary
[2020-05-30 20:46:22,831 INFO  L130     BoogieDeclarations]: Found specification of procedure transferPrimary_Secondary
[2020-05-30 20:46:22,831 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferPrimary_Secondary
[2020-05-30 20:46:22,831 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow_NoBaseCtor__success
[2020-05-30 20:46:22,831 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow
[2020-05-30 20:46:22,831 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow
[2020-05-30 20:46:22,831 INFO  L130     BoogieDeclarations]: Found specification of procedure depositsOf_Escrow
[2020-05-30 20:46:22,831 INFO  L138     BoogieDeclarations]: Found implementation of procedure depositsOf_Escrow
[2020-05-30 20:46:22,832 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow
[2020-05-30 20:46:22,832 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow
[2020-05-30 20:46:22,832 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow_Escrow__success
[2020-05-30 20:46:22,832 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow
[2020-05-30 20:46:22,832 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow
[2020-05-30 20:46:22,832 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow_Escrow__success
[2020-05-30 20:46:22,832 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success
[2020-05-30 20:46:22,832 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow
[2020-05-30 20:46:22,832 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow
[2020-05-30 20:46:22,832 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawalAllowed_ConditionalEscrow
[2020-05-30 20:46:22,832 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_ConditionalEscrow
[2020-05-30 20:46:22,832 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_ConditionalEscrow
[2020-05-30 20:46:22,832 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow_NoBaseCtor__success
[2020-05-30 20:46:22,833 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow
[2020-05-30 20:46:22,833 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow
[2020-05-30 20:46:22,833 INFO  L130     BoogieDeclarations]: Found specification of procedure state_RefundEscrow
[2020-05-30 20:46:22,833 INFO  L138     BoogieDeclarations]: Found implementation of procedure state_RefundEscrow
[2020-05-30 20:46:22,833 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiary_RefundEscrow
[2020-05-30 20:46:22,833 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiary_RefundEscrow
[2020-05-30 20:46:22,833 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_RefundEscrow
[2020-05-30 20:46:22,833 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_RefundEscrow
[2020-05-30 20:46:22,833 INFO  L130     BoogieDeclarations]: Found specification of procedure close_RefundEscrow
[2020-05-30 20:46:22,833 INFO  L138     BoogieDeclarations]: Found implementation of procedure close_RefundEscrow
[2020-05-30 20:46:22,833 INFO  L130     BoogieDeclarations]: Found specification of procedure enableRefunds_RefundEscrow
[2020-05-30 20:46:22,833 INFO  L138     BoogieDeclarations]: Found implementation of procedure enableRefunds_RefundEscrow
[2020-05-30 20:46:22,834 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiaryWithdraw_RefundEscrow
[2020-05-30 20:46:22,834 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiaryWithdraw_RefundEscrow
[2020-05-30 20:46:22,834 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawalAllowed_RefundEscrow
[2020-05-30 20:46:22,834 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdrawalAllowed_RefundEscrow
[2020-05-30 20:46:22,834 INFO  L130     BoogieDeclarations]: Found specification of procedure FallbackDispatch__success
[2020-05-30 20:46:22,834 INFO  L130     BoogieDeclarations]: Found specification of procedure Fallback_UnknownType__success
[2020-05-30 20:46:22,834 INFO  L130     BoogieDeclarations]: Found specification of procedure send__success
[2020-05-30 20:46:22,834 INFO  L130     BoogieDeclarations]: Found specification of procedure onlyPrimary_pre__success
[2020-05-30 20:46:22,834 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_SafeMath
[2020-05-30 20:46:22,834 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_SafeMath
[2020-05-30 20:46:22,834 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_Secondary
[2020-05-30 20:46:22,834 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_Secondary
[2020-05-30 20:46:22,834 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_Escrow
[2020-05-30 20:46:22,834 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_Escrow
[2020-05-30 20:46:22,834 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_ConditionalEscrow
[2020-05-30 20:46:22,835 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_ConditionalEscrow
[2020-05-30 20:46:22,835 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_RefundEscrow
[2020-05-30 20:46:22,835 INFO  L130     BoogieDeclarations]: Found specification of procedure main
[2020-05-30 20:46:22,835 INFO  L130     BoogieDeclarations]: Found specification of procedure FreshRefGenerator__fail
[2020-05-30 20:46:22,835 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath_NoBaseCtor__fail
[2020-05-30 20:46:22,835 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath__success
[2020-05-30 20:46:22,835 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath__fail
[2020-05-30 20:46:22,835 INFO  L130     BoogieDeclarations]: Found specification of procedure sub_SafeMath__fail
[2020-05-30 20:46:22,835 INFO  L130     BoogieDeclarations]: Found specification of procedure add_SafeMath__fail
[2020-05-30 20:46:22,835 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary_NoBaseCtor__fail
[2020-05-30 20:46:22,835 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary__success
[2020-05-30 20:46:22,836 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary__fail
[2020-05-30 20:46:22,836 INFO  L130     BoogieDeclarations]: Found specification of procedure primary_Secondary__success
[2020-05-30 20:46:22,836 INFO  L130     BoogieDeclarations]: Found specification of procedure primary_Secondary__fail
[2020-05-30 20:46:22,836 INFO  L130     BoogieDeclarations]: Found specification of procedure transferPrimary_Secondary__success
[2020-05-30 20:46:22,836 INFO  L130     BoogieDeclarations]: Found specification of procedure transferPrimary_Secondary__fail
[2020-05-30 20:46:22,836 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow_NoBaseCtor__fail
[2020-05-30 20:46:22,836 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow__success
[2020-05-30 20:46:22,836 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow__fail
[2020-05-30 20:46:22,837 INFO  L130     BoogieDeclarations]: Found specification of procedure depositsOf_Escrow__success
[2020-05-30 20:46:22,837 INFO  L130     BoogieDeclarations]: Found specification of procedure depositsOf_Escrow__fail
[2020-05-30 20:46:22,837 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow__success
[2020-05-30 20:46:22,837 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow__fail
[2020-05-30 20:46:22,837 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow_Escrow__fail
[2020-05-30 20:46:22,837 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow__success
[2020-05-30 20:46:22,837 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow__fail
[2020-05-30 20:46:22,837 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow_Escrow__fail
[2020-05-30 20:46:22,837 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow_NoBaseCtor__fail
[2020-05-30 20:46:22,837 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow__success
[2020-05-30 20:46:22,838 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow__fail
[2020-05-30 20:46:22,838 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_ConditionalEscrow__success
[2020-05-30 20:46:22,838 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_ConditionalEscrow__fail
[2020-05-30 20:46:22,838 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow_NoBaseCtor__fail
[2020-05-30 20:46:22,838 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow__success
[2020-05-30 20:46:22,838 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow__fail
[2020-05-30 20:46:22,838 INFO  L130     BoogieDeclarations]: Found specification of procedure state_RefundEscrow__success
[2020-05-30 20:46:22,838 INFO  L130     BoogieDeclarations]: Found specification of procedure state_RefundEscrow__fail
[2020-05-30 20:46:22,838 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiary_RefundEscrow__success
[2020-05-30 20:46:22,838 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiary_RefundEscrow__fail
[2020-05-30 20:46:22,838 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_RefundEscrow__success
[2020-05-30 20:46:22,838 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_RefundEscrow__fail
[2020-05-30 20:46:22,838 INFO  L130     BoogieDeclarations]: Found specification of procedure close_RefundEscrow__success
[2020-05-30 20:46:22,839 INFO  L130     BoogieDeclarations]: Found specification of procedure close_RefundEscrow__fail
[2020-05-30 20:46:22,839 INFO  L130     BoogieDeclarations]: Found specification of procedure enableRefunds_RefundEscrow__success
[2020-05-30 20:46:22,839 INFO  L130     BoogieDeclarations]: Found specification of procedure enableRefunds_RefundEscrow__fail
[2020-05-30 20:46:22,839 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiaryWithdraw_RefundEscrow__success
[2020-05-30 20:46:22,839 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiaryWithdraw_RefundEscrow__fail
[2020-05-30 20:46:22,839 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawalAllowed_RefundEscrow__success
[2020-05-30 20:46:22,839 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawalAllowed_RefundEscrow__fail
[2020-05-30 20:46:22,839 INFO  L130     BoogieDeclarations]: Found specification of procedure FallbackDispatch__fail
[2020-05-30 20:46:22,840 INFO  L130     BoogieDeclarations]: Found specification of procedure Fallback_UnknownType__fail
[2020-05-30 20:46:22,840 INFO  L130     BoogieDeclarations]: Found specification of procedure send__fail
[2020-05-30 20:46:22,840 INFO  L130     BoogieDeclarations]: Found specification of procedure onlyPrimary_pre__fail
[2020-05-30 20:46:22,840 INFO  L138     BoogieDeclarations]: Found implementation of procedure FreshRefGenerator__fail
[2020-05-30 20:46:22,840 INFO  L138     BoogieDeclarations]: Found implementation of procedure FreshRefGenerator__success
[2020-05-30 20:46:22,840 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath_NoBaseCtor__fail
[2020-05-30 20:46:22,840 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath_NoBaseCtor__success
[2020-05-30 20:46:22,840 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath__fail
[2020-05-30 20:46:22,840 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath__success
[2020-05-30 20:46:22,840 INFO  L138     BoogieDeclarations]: Found implementation of procedure sub_SafeMath__fail
[2020-05-30 20:46:22,840 INFO  L138     BoogieDeclarations]: Found implementation of procedure sub_SafeMath__success
[2020-05-30 20:46:22,841 INFO  L138     BoogieDeclarations]: Found implementation of procedure add_SafeMath__fail
[2020-05-30 20:46:22,841 INFO  L138     BoogieDeclarations]: Found implementation of procedure add_SafeMath__success
[2020-05-30 20:46:22,841 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary_NoBaseCtor__fail
[2020-05-30 20:46:22,841 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary_NoBaseCtor__success
[2020-05-30 20:46:22,841 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary__fail
[2020-05-30 20:46:22,841 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary__success
[2020-05-30 20:46:22,841 INFO  L138     BoogieDeclarations]: Found implementation of procedure primary_Secondary__fail
[2020-05-30 20:46:22,842 INFO  L138     BoogieDeclarations]: Found implementation of procedure primary_Secondary__success
[2020-05-30 20:46:22,842 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferPrimary_Secondary__fail
[2020-05-30 20:46:22,842 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferPrimary_Secondary__success
[2020-05-30 20:46:22,842 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow_NoBaseCtor__fail
[2020-05-30 20:46:22,842 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow_NoBaseCtor__success
[2020-05-30 20:46:22,842 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow__fail
[2020-05-30 20:46:22,842 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow__success
[2020-05-30 20:46:22,842 INFO  L138     BoogieDeclarations]: Found implementation of procedure depositsOf_Escrow__fail
[2020-05-30 20:46:22,842 INFO  L138     BoogieDeclarations]: Found implementation of procedure depositsOf_Escrow__success
[2020-05-30 20:46:22,843 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow__fail
[2020-05-30 20:46:22,843 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow__success
[2020-05-30 20:46:22,843 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow_Escrow__fail
[2020-05-30 20:46:22,843 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow_Escrow__success
[2020-05-30 20:46:22,843 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow__fail
[2020-05-30 20:46:22,843 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow__success
[2020-05-30 20:46:22,844 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow_Escrow__fail
[2020-05-30 20:46:22,844 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow_Escrow__success
[2020-05-30 20:46:22,844 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow_NoBaseCtor__fail
[2020-05-30 20:46:22,844 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success
[2020-05-30 20:46:22,844 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow__fail
[2020-05-30 20:46:22,844 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow__success
[2020-05-30 20:46:22,844 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_ConditionalEscrow__fail
[2020-05-30 20:46:22,844 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_ConditionalEscrow__success
[2020-05-30 20:46:22,844 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow_NoBaseCtor__fail
[2020-05-30 20:46:22,844 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow_NoBaseCtor__success
[2020-05-30 20:46:22,844 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow__fail
[2020-05-30 20:46:22,845 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow__success
[2020-05-30 20:46:22,845 INFO  L138     BoogieDeclarations]: Found implementation of procedure state_RefundEscrow__fail
[2020-05-30 20:46:22,845 INFO  L138     BoogieDeclarations]: Found implementation of procedure state_RefundEscrow__success
[2020-05-30 20:46:22,845 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiary_RefundEscrow__fail
[2020-05-30 20:46:22,845 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiary_RefundEscrow__success
[2020-05-30 20:46:22,845 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_RefundEscrow__fail
[2020-05-30 20:46:22,845 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_RefundEscrow__success
[2020-05-30 20:46:22,845 INFO  L138     BoogieDeclarations]: Found implementation of procedure close_RefundEscrow__fail
[2020-05-30 20:46:22,845 INFO  L138     BoogieDeclarations]: Found implementation of procedure close_RefundEscrow__success
[2020-05-30 20:46:22,845 INFO  L138     BoogieDeclarations]: Found implementation of procedure enableRefunds_RefundEscrow__fail
[2020-05-30 20:46:22,845 INFO  L138     BoogieDeclarations]: Found implementation of procedure enableRefunds_RefundEscrow__success
[2020-05-30 20:46:22,845 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiaryWithdraw_RefundEscrow__fail
[2020-05-30 20:46:22,845 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiaryWithdraw_RefundEscrow__success
[2020-05-30 20:46:22,845 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdrawalAllowed_RefundEscrow__fail
[2020-05-30 20:46:22,845 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdrawalAllowed_RefundEscrow__success
[2020-05-30 20:46:22,845 INFO  L138     BoogieDeclarations]: Found implementation of procedure FallbackDispatch__fail
[2020-05-30 20:46:22,846 INFO  L138     BoogieDeclarations]: Found implementation of procedure FallbackDispatch__success
[2020-05-30 20:46:22,846 INFO  L138     BoogieDeclarations]: Found implementation of procedure Fallback_UnknownType__fail
[2020-05-30 20:46:22,846 INFO  L138     BoogieDeclarations]: Found implementation of procedure Fallback_UnknownType__success
[2020-05-30 20:46:22,846 INFO  L138     BoogieDeclarations]: Found implementation of procedure send__fail
[2020-05-30 20:46:22,846 INFO  L138     BoogieDeclarations]: Found implementation of procedure send__success
[2020-05-30 20:46:22,846 INFO  L138     BoogieDeclarations]: Found implementation of procedure onlyPrimary_pre__fail
[2020-05-30 20:46:22,846 INFO  L138     BoogieDeclarations]: Found implementation of procedure onlyPrimary_pre__success
[2020-05-30 20:46:22,846 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_SafeMath
[2020-05-30 20:46:22,846 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_SafeMath
[2020-05-30 20:46:22,846 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_Secondary
[2020-05-30 20:46:22,846 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_Secondary
[2020-05-30 20:46:22,846 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_Escrow
[2020-05-30 20:46:22,846 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_Escrow
[2020-05-30 20:46:22,846 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_ConditionalEscrow
[2020-05-30 20:46:22,846 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_ConditionalEscrow
[2020-05-30 20:46:22,847 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_RefundEscrow
[2020-05-30 20:46:22,847 INFO  L138     BoogieDeclarations]: Found implementation of procedure main
[2020-05-30 20:46:22,847 INFO  L130     BoogieDeclarations]: Found specification of procedure ULTIMATE.start
[2020-05-30 20:46:22,847 INFO  L138     BoogieDeclarations]: Found implementation of procedure ULTIMATE.start
[2020-05-30 20:46:22,968 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 20:46:22,981 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 20:46:23,131 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 20:46:23,317 INFO  L281             CfgBuilder]: Using the 1 location(s) as analysis (start of procedure ULTIMATE.start)
[2020-05-30 20:46:23,317 INFO  L286             CfgBuilder]: Removed 5 assue(true) statements.
[2020-05-30 20:46:23,318 INFO  L202        PluginConnector]: Adding new model L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 08:46:23 BoogieIcfgContainer
[2020-05-30 20:46:23,318 INFO  L185        PluginConnector]: Executing the observer RCFGBuilderObserver from plugin RCFGBuilder for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:46:22" (2/2) ...
[2020-05-30 20:46:23,319 INFO  L85     RCFGBuilderObserver]: No WrapperNode. Let Ultimate process with next node
[2020-05-30 20:46:23,319 INFO  L205        PluginConnector]: Invalid model from RCFGBuilder for observer de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder.RCFGBuilderObserver@e5018c1 and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 08:46:23, skipping insertion in model container
[2020-05-30 20:46:23,319 INFO  L132        PluginConnector]: ------------------------ END RCFGBuilder----------------------------
[2020-05-30 20:46:23,319 INFO  L113        PluginConnector]: ------------------------UtopiaLTL2Aut----------------------------
[2020-05-30 20:46:23,319 INFO  L271        PluginConnector]: Initializing UtopiaLTL2Aut...
[2020-05-30 20:46:23,321 INFO  L276        PluginConnector]: UtopiaLTL2Aut initialized
[2020-05-30 20:46:23,321 INFO  L185        PluginConnector]: Executing the observer UtopiaLTL2AutObserver from plugin UtopiaLTL2Aut for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:46:22" (1/3) ...
[2020-05-30 20:46:23,322 INFO  L205        PluginConnector]: Invalid model from UtopiaLTL2Aut for observer edu.utexas.cs.utopia.ltl2aut.UtopiaLTL2AutObserver@1e3337fd and model type Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 08:46:23, skipping insertion in model container
[2020-05-30 20:46:23,322 INFO  L185        PluginConnector]: Executing the observer UtopiaLTL2AutObserver from plugin UtopiaLTL2Aut for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:46:22" (2/3) ...
No working directory specified, using /Users/jon/Documents/Research/devUltimate/ltl2ba
Starting monitored process 1 with /Users/jon/Documents/Research/devUltimate/ltl2ba -f  ( ( <>a ) && ( <>b ) ) && ! ( ( [] ( c -> ( <>d ) ) ) )  (exit command is null, workingDir is null)
[2020-05-30 20:46:23,362 INFO  L202        PluginConnector]: Adding new model Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 08:46:23 NWAContainer
[2020-05-30 20:46:23,362 INFO  L132        PluginConnector]: ------------------------ END UtopiaLTL2Aut----------------------------
[2020-05-30 20:46:23,362 INFO  L113        PluginConnector]: ------------------------BÃ¼chi Program Product----------------------------
[2020-05-30 20:46:23,362 INFO  L271        PluginConnector]: Initializing BÃ¼chi Program Product...
[2020-05-30 20:46:23,363 INFO  L276        PluginConnector]: BÃ¼chi Program Product initialized
[2020-05-30 20:46:23,364 INFO  L185        PluginConnector]: Executing the observer BuchiProductObserver from plugin BÃ¼chi Program Product for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 08:46:23" (3/4) ...
[2020-05-30 20:46:23,364 INFO  L205        PluginConnector]: Invalid model from BÃ¼chi Program Product for observer de.uni_freiburg.informatik.ultimate.buchiprogramproduct.BuchiProductObserver@4bb7f7ba and model type LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 08:46:23, skipping insertion in model container
[2020-05-30 20:46:23,364 INFO  L185        PluginConnector]: Executing the observer BuchiProductObserver from plugin BÃ¼chi Program Product for "Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 08:46:23" (4/4) ...
[2020-05-30 20:46:23,367 INFO  L104   BuchiProductObserver]: Initial property automaton 8 locations, 27 edges
[2020-05-30 20:46:23,370 INFO  L110   BuchiProductObserver]: Initial RCFG 1608 locations, 2227 edges
[2020-05-30 20:46:23,370 INFO  L93    BuchiProductObserver]: Beginning generation of product automaton
[2020-05-30 20:46:23,379 INFO  L136       ProductGenerator]: The program has no step specification, so we assume maximum atomicity
[2020-05-30 20:46:28,930 INFO  L97    BuchiProductObserver]: Finished generation of product automaton successfully
[2020-05-30 20:46:28,954 INFO  L110   BuchiProductObserver]: BuchiProgram size 15695 locations, 65221 edges
[2020-05-30 20:46:28,955 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 08:46:28 BoogieIcfgContainer
[2020-05-30 20:46:28,955 INFO  L132        PluginConnector]: ------------------------ END BÃ¼chi Program Product----------------------------
[2020-05-30 20:46:28,955 INFO  L113        PluginConnector]: ------------------------BlockEncodingV2----------------------------
[2020-05-30 20:46:28,955 INFO  L271        PluginConnector]: Initializing BlockEncodingV2...
[2020-05-30 20:46:28,957 INFO  L276        PluginConnector]: BlockEncodingV2 initialized
[2020-05-30 20:46:28,957 INFO  L185        PluginConnector]: Executing the observer BlockEncodingObserver from plugin BlockEncodingV2 for "LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 08:46:28" (1/1) ...
[2020-05-30 20:46:29,489 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,489 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,489 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,489 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,489 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,489 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,492 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,493 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,493 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,493 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,493 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,493 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,496 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,496 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,496 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,496 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,496 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:46:29,496 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:46:29,497 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:46:29,497 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:46:29,497 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:46:29,497 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,497 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,497 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:46:29,498 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:46:29,498 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:46:29,498 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:46:29,498 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:46:29,498 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:46:29,498 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:46:29,501 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:46:29,501 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:46:29,501 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:46:29,501 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:46:29,501 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:46:29,501 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:46:29,502 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:46:29,502 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:46:29,502 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:46:29,502 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:46:29,503 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:46:29,503 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:46:29,503 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,504 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,504 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,504 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,504 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,504 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,505 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,505 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,505 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,505 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,505 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,505 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,512 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,512 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,512 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,512 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,513 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,513 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,530 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,530 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,530 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,530 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,530 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,530 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:46:29,565 INFO  L313           BlockEncoder]: Initial Icfg 15695 locations, 65221 edges
[2020-05-30 20:46:29,565 INFO  L258           BlockEncoder]: Using Remove infeasible edges
[2020-05-30 20:46:29,566 INFO  L270           BlockEncoder]: Using Minimize states even if more edges are added than removed.=true
[2020-05-30 20:46:29,566 INFO  L296           BlockEncoder]: Using Remove sink states
[2020-05-30 20:46:29,566 INFO  L171           BlockEncoder]: Using Apply optimizations until nothing changes=true
[2020-05-30 20:46:29,600 INFO  L70    emoveInfeasibleEdges]: Removed 764 edges and 52 locations because of local infeasibility
[2020-05-30 20:46:29,622 INFO  L70        RemoveSinkStates]: Removed 288 edges and 84 locations by removing sink states
[2020-05-30 20:46:29,667 INFO  L70    emoveInfeasibleEdges]: Removed 0 edges and 0 locations because of local infeasibility
[2020-05-30 20:46:29,682 INFO  L70        RemoveSinkStates]: Removed 0 edges and 0 locations by removing sink states
[2020-05-30 20:46:29,697 INFO  L237           BlockEncoder]: Using Create parallel compositions if possible
[2020-05-30 20:46:29,697 INFO  L66        ParallelComposer]: Creating parallel compositions
[2020-05-30 20:46:29,711 INFO  L313           BlockEncoder]: Encoded RCFG 15471 locations, 63891 edges
[2020-05-30 20:46:29,711 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.blockencoding CFG 30.05 08:46:29 BasicIcfg
[2020-05-30 20:46:29,712 INFO  L132        PluginConnector]: ------------------------ END BlockEncodingV2----------------------------
[2020-05-30 20:46:29,712 INFO  L113        PluginConnector]: ------------------------BuchiAutomizer----------------------------
[2020-05-30 20:46:29,712 INFO  L271        PluginConnector]: Initializing BuchiAutomizer...
[2020-05-30 20:46:29,714 INFO  L276        PluginConnector]: BuchiAutomizer initialized
[2020-05-30 20:46:29,714 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:46:29,714 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:46:22" (1/6) ...
[2020-05-30 20:46:29,715 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@366706fe and model type L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 30.05 08:46:29, skipping insertion in model container
[2020-05-30 20:46:29,716 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:46:29,716 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:46:22" (2/6) ...
[2020-05-30 20:46:29,716 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@366706fe and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 30.05 08:46:29, skipping insertion in model container
[2020-05-30 20:46:29,716 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:46:29,716 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 08:46:23" (3/6) ...
[2020-05-30 20:46:29,716 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@366706fe and model type L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer CFG 30.05 08:46:29, skipping insertion in model container
[2020-05-30 20:46:29,716 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:46:29,716 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 08:46:23" (4/6) ...
[2020-05-30 20:46:29,716 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@366706fe and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 30.05 08:46:29, skipping insertion in model container
[2020-05-30 20:46:29,716 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:46:29,717 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 08:46:28" (5/6) ...
[2020-05-30 20:46:29,717 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@366706fe and model type LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer OTHER 30.05 08:46:29, skipping insertion in model container
[2020-05-30 20:46:29,717 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:46:29,717 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.blockencoding CFG 30.05 08:46:29" (6/6) ...
[2020-05-30 20:46:29,718 INFO  L404   chiAutomizerObserver]: Analyzing ICFG L2-RefundEscrow.bpl_BEv2
[2020-05-30 20:46:29,748 INFO  L133   ementStrategyFactory]: Using default assertion order modulation
[2020-05-30 20:46:29,749 INFO  L377         BuchiCegarLoop]: Interprodecural is true
[2020-05-30 20:46:29,749 INFO  L378         BuchiCegarLoop]: Hoare is false
[2020-05-30 20:46:29,749 INFO  L379         BuchiCegarLoop]: Compute interpolants for Craig_TreeInterpolation
[2020-05-30 20:46:29,749 INFO  L380         BuchiCegarLoop]: Backedges is STRAIGHT_LINE
[2020-05-30 20:46:29,749 INFO  L381         BuchiCegarLoop]: Determinization is PREDICATE_ABSTRACTION
[2020-05-30 20:46:29,749 INFO  L382         BuchiCegarLoop]: Difference is false
[2020-05-30 20:46:29,749 INFO  L383         BuchiCegarLoop]: Minimize is MINIMIZE_SEVPA
[2020-05-30 20:46:29,749 INFO  L386         BuchiCegarLoop]: ======== Iteration 0==of CEGAR loop == BuchiCegarLoop========
[2020-05-30 20:46:29,886 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 15471 states.
[2020-05-30 20:46:30,064 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 267
[2020-05-30 20:46:30,065 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:46:30,065 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:46:30,074 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:46:30,075 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:46:30,075 INFO  L445         BuchiCegarLoop]: ======== Iteration 1============
[2020-05-30 20:46:30,075 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 15471 states.
[2020-05-30 20:46:30,165 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 267
[2020-05-30 20:46:30,165 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:46:30,165 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:46:30,167 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:46:30,167 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_close_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc ben;
[L3855]              assume null == 0;
[L3856]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3856]  RET         call this := FreshRefGenerator__success();
[L3857]              assume now >= 0;
[L3858]              assume DType[this] == RefundEscrow;
[L3859]              gas := gas - 53000;
[L3860]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND TRUE   revert
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3860]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]              assume !revert && gas >= 0;

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND TRUE   choice == 11
[L3747]              gas := gas - 21000;
[L3748]  COND FALSE  !(gas >= 0)
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:46:30,181 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:46:30,181 INFO  L82        PathProgramCache]: Analyzing trace with hash -1047853317, now seen corresponding path program 1 times
[2020-05-30 20:46:30,185 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:46:30,203 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:46:30,242 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 20:46:30,244 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:46:30,245 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:46:31,103 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:46:31,120 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:46:31,121 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:46:31,123 INFO  L87              Difference]: Start difference. First operand 15471 states. Second operand 3 states.
[2020-05-30 20:46:32,361 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:46:32,361 INFO  L93              Difference]: Finished difference Result 12067 states and 30947 transitions.
[2020-05-30 20:46:32,361 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:46:32,363 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 12067 states and 30947 transitions.
[2020-05-30 20:46:32,451 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 267
[2020-05-30 20:46:32,568 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 12067 states to 12067 states and 30947 transitions.
[2020-05-30 20:46:32,569 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 8
[2020-05-30 20:46:32,571 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 118
[2020-05-30 20:46:32,571 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 12067 states and 30947 transitions.
[2020-05-30 20:46:32,618 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:46:32,618 INFO  L728         BuchiCegarLoop]: Abstraction has 12067 states and 30947 transitions.
[2020-05-30 20:46:32,649 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 12067 states and 30947 transitions.
[2020-05-30 20:46:32,868 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 12067 to 12067.
[2020-05-30 20:46:32,869 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 12067 states.
[2020-05-30 20:46:32,901 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 12067 states to 12067 states and 30947 transitions.
[2020-05-30 20:46:32,902 INFO  L751         BuchiCegarLoop]: Abstraction has 12067 states and 30947 transitions.
[2020-05-30 20:46:32,903 INFO  L631         BuchiCegarLoop]: Abstraction has 12067 states and 30947 transitions.
[2020-05-30 20:46:32,903 INFO  L445         BuchiCegarLoop]: ======== Iteration 2============
[2020-05-30 20:46:32,903 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 12067 states and 30947 transitions.
[2020-05-30 20:46:32,932 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 267
[2020-05-30 20:46:32,933 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:46:32,933 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:46:32,935 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:46:32,936 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_close_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc ben;
[L3855]              assume null == 0;
[L3856]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3856]  RET         call this := FreshRefGenerator__success();
[L3857]              assume now >= 0;
[L3858]              assume DType[this] == RefundEscrow;
[L3859]              gas := gas - 53000;
[L3860]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND TRUE   revert
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3860]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]              assume !revert && gas >= 0;
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND TRUE   choice == 3
[L3819]              gas := gas - 21000;
[L3820]  COND TRUE   gas >= 0
[L3822]              assume msgvalue_MSG == 0;
[L3823]  CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]               havoc __exception;
[L676]               revert := false;
[L677]   COND FALSE  !(__exception)
[L696]   CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]              gas := gas - 2208;
[L3345]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]  COND TRUE   revert
[L696]   RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L1]     CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]              gas := gas - 3;
[L2149]              gas := gas - 294;
[L2150]              __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]     RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                 assume ben == __beneficiary_RefundEscrow0;
[L7]                 success_close_RefundEscrow0 := true;
[L7]                 success_close_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3823]  RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND TRUE   choice == 3
[L3819]              gas := gas - 21000;
[L3820]  COND TRUE   gas >= 0
[L3822]              assume msgvalue_MSG == 0;
[L3823]  CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]               havoc __exception;
[L676]               revert := false;
[L677]   COND FALSE  !(__exception)
[L696]   CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]              gas := gas - 2208;
[L3345]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]  COND TRUE   revert
[L696]   RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L1]     CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]              gas := gas - 3;
[L2149]              gas := gas - 294;
[L2150]              __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]     RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                 assume ben == __beneficiary_RefundEscrow0;
[L7]                 success_close_RefundEscrow0 := true;
[L7]                 success_close_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3823]  RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:46:32,940 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:46:32,941 INFO  L82        PathProgramCache]: Analyzing trace with hash 924200221, now seen corresponding path program 1 times
[2020-05-30 20:46:32,942 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:46:32,948 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:46:32,967 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 20:46:32,967 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:46:32,967 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-05-30 20:46:32,969 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:46:32,969 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-05-30 20:46:32,969 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=5, Invalid=7, Unknown=0, NotChecked=0, Total=12
[2020-05-30 20:46:32,969 INFO  L87              Difference]: Start difference. First operand 12067 states and 30947 transitions. cyclomatic complexity: 18904 Second operand 4 states.
[2020-05-30 20:46:39,112 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:46:39,112 INFO  L93              Difference]: Finished difference Result 11653 states and 20715 transitions.
[2020-05-30 20:46:39,112 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 4 states. 
[2020-05-30 20:46:39,113 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 11653 states and 20715 transitions.
[2020-05-30 20:46:39,166 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 267
[2020-05-30 20:46:39,236 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 11653 states to 11653 states and 20715 transitions.
[2020-05-30 20:46:39,237 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 118
[2020-05-30 20:46:39,237 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 118
[2020-05-30 20:46:39,237 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 11653 states and 20715 transitions.
[2020-05-30 20:46:39,253 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:46:39,253 INFO  L728         BuchiCegarLoop]: Abstraction has 11653 states and 20715 transitions.
[2020-05-30 20:46:39,269 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 11653 states and 20715 transitions.
[2020-05-30 20:46:39,491 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 11653 to 11653.
[2020-05-30 20:46:39,491 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 11653 states.
[2020-05-30 20:46:39,510 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 11653 states to 11653 states and 20715 transitions.
[2020-05-30 20:46:39,510 INFO  L751         BuchiCegarLoop]: Abstraction has 11653 states and 20715 transitions.
[2020-05-30 20:46:39,510 INFO  L631         BuchiCegarLoop]: Abstraction has 11653 states and 20715 transitions.
[2020-05-30 20:46:39,510 INFO  L445         BuchiCegarLoop]: ======== Iteration 3============
[2020-05-30 20:46:39,510 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 11653 states and 20715 transitions.
[2020-05-30 20:46:39,524 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 267
[2020-05-30 20:46:39,525 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:46:39,525 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:46:39,527 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:46:39,527 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_close_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc ben;
[L3855]              assume null == 0;
[L3856]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3856]  RET         call this := FreshRefGenerator__success();
[L3857]              assume now >= 0;
[L3858]              assume DType[this] == RefundEscrow;
[L3859]              gas := gas - 53000;
[L3860]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND TRUE   revert
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3860]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]              assume !revert && gas >= 0;
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND TRUE   choice == 8
[L3774]              gas := gas - 21000;
[L3775]  COND TRUE   gas >= 0
[L3777]              assume msgvalue_MSG >= 0;
[L3778]  CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]               havoc __exception;
[L639]               revert := false;
[L640]   COND FALSE  !(__exception)
[L659]   CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]              assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]              Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]              Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]              gas := gas - 317;
[L2191]  COND TRUE   !(_state_RefundEscrow[this] == 0)
[L2193]              revert := true;
[L659]   RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_deposit_RefundEscrow0 := true;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L7]                 fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]  RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]  RET         call CorralChoice_RefundEscrow(this);
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND TRUE   choice == 3
[L3819]              gas := gas - 21000;
[L3820]  COND TRUE   gas >= 0
[L3822]              assume msgvalue_MSG == 0;
[L3823]  CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]               havoc __exception;
[L676]               revert := false;
[L677]   COND FALSE  !(__exception)
[L696]   CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]              gas := gas - 2208;
[L3345]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]  COND TRUE   revert
[L696]   RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L1]     CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]              gas := gas - 3;
[L2149]              gas := gas - 294;
[L2150]              __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]     RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                 assume ben == __beneficiary_RefundEscrow0;
[L7]                 success_close_RefundEscrow0 := true;
[L7]                 success_close_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3823]  RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND TRUE   choice == 8
[L3774]              gas := gas - 21000;
[L3775]  COND TRUE   gas >= 0
[L3777]              assume msgvalue_MSG >= 0;
[L3778]  CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]               havoc __exception;
[L639]               revert := false;
[L640]   COND FALSE  !(__exception)
[L659]   CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]              assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]              Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]              Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]              gas := gas - 317;
[L2191]  COND TRUE   !(_state_RefundEscrow[this] == 0)
[L2193]              revert := true;
[L659]   RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_deposit_RefundEscrow0 := true;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L7]                 fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]  RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:46:39,560 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:46:39,561 INFO  L82        PathProgramCache]: Analyzing trace with hash -761491599, now seen corresponding path program 1 times
[2020-05-30 20:46:39,561 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:46:39,568 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:46:39,592 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 20:46:39,592 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:46:39,592 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-05-30 20:46:39,593 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:46:39,593 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-05-30 20:46:39,593 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=5, Invalid=7, Unknown=0, NotChecked=0, Total=12
[2020-05-30 20:46:39,593 INFO  L87              Difference]: Start difference. First operand 11653 states and 20715 transitions. cyclomatic complexity: 9086 Second operand 4 states.
[2020-05-30 20:46:41,468 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:46:41,469 INFO  L93              Difference]: Finished difference Result 11446 states and 14278 transitions.
[2020-05-30 20:46:41,469 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 4 states. 
[2020-05-30 20:46:41,469 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 11446 states and 14278 transitions.
[2020-05-30 20:46:41,494 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 267
[2020-05-30 20:46:41,525 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 11446 states to 11446 states and 14278 transitions.
[2020-05-30 20:46:41,525 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 118
[2020-05-30 20:46:41,526 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 118
[2020-05-30 20:46:41,526 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 11446 states and 14278 transitions.
[2020-05-30 20:46:41,535 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:46:41,535 INFO  L728         BuchiCegarLoop]: Abstraction has 11446 states and 14278 transitions.
[2020-05-30 20:46:41,547 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 11446 states and 14278 transitions.
[2020-05-30 20:46:41,614 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 11446 to 11446.
[2020-05-30 20:46:41,615 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 11446 states.
[2020-05-30 20:46:41,626 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 11446 states to 11446 states and 14278 transitions.
[2020-05-30 20:46:41,626 INFO  L751         BuchiCegarLoop]: Abstraction has 11446 states and 14278 transitions.
[2020-05-30 20:46:41,627 INFO  L631         BuchiCegarLoop]: Abstraction has 11446 states and 14278 transitions.
[2020-05-30 20:46:41,627 INFO  L445         BuchiCegarLoop]: ======== Iteration 4============
[2020-05-30 20:46:41,627 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 11446 states and 14278 transitions.
[2020-05-30 20:46:41,636 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 267
[2020-05-30 20:46:41,636 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:46:41,636 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:46:41,638 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:46:41,638 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_close_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc ben;
[L3855]              assume null == 0;
[L3856]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3856]  RET         call this := FreshRefGenerator__success();
[L3857]              assume now >= 0;
[L3858]              assume DType[this] == RefundEscrow;
[L3859]              gas := gas - 53000;
[L3860]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND TRUE   revert
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND TRUE   revert
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3860]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]              assume !revert && gas >= 0;
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND TRUE   choice == 8
[L3774]              gas := gas - 21000;
[L3775]  COND TRUE   gas >= 0
[L3777]              assume msgvalue_MSG >= 0;
[L3778]  CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]               havoc __exception;
[L639]               revert := false;
[L640]   COND FALSE  !(__exception)
[L659]   CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]              assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]              Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]              Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]              gas := gas - 317;
[L2191]  COND TRUE   !(_state_RefundEscrow[this] == 0)
[L2193]              revert := true;
[L659]   RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_deposit_RefundEscrow0 := true;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L7]                 fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]  RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]  RET         call CorralChoice_RefundEscrow(this);
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND TRUE   choice == 1
[L3837]              gas := gas - 21000;
[L3838]  COND TRUE   gas >= 0
[L3840]              assume msgvalue_MSG == 0;
[L3841]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND TRUE   !(_state_RefundEscrow[this] == 2)
[L2344]              revert := true;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3841]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]  RET         call CorralChoice_RefundEscrow(this);
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND TRUE   choice == 3
[L3819]              gas := gas - 21000;
[L3820]  COND TRUE   gas >= 0
[L3822]              assume msgvalue_MSG == 0;
[L3823]  CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]               havoc __exception;
[L676]               revert := false;
[L677]   COND FALSE  !(__exception)
[L696]   CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]              gas := gas - 2208;
[L3345]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]  COND TRUE   revert
[L696]   RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L1]     CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]              gas := gas - 3;
[L2149]              gas := gas - 294;
[L2150]              __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]     RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                 assume ben == __beneficiary_RefundEscrow0;
[L7]                 success_close_RefundEscrow0 := true;
[L7]                 success_close_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3823]  RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND TRUE   choice == 1
[L3837]              gas := gas - 21000;
[L3838]  COND TRUE   gas >= 0
[L3840]              assume msgvalue_MSG == 0;
[L3841]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND TRUE   !(_state_RefundEscrow[this] == 2)
[L2344]              revert := true;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3841]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:46:41,640 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:46:41,641 INFO  L82        PathProgramCache]: Analyzing trace with hash -1221058116, now seen corresponding path program 1 times
[2020-05-30 20:46:41,641 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:46:41,647 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:46:41,673 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 20:46:41,673 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:46:41,673 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:46:41,673 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:46:41,673 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:46:41,674 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:46:41,674 INFO  L87              Difference]: Start difference. First operand 11446 states and 14278 transitions. cyclomatic complexity: 2856 Second operand 3 states.
[2020-05-30 20:46:41,876 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:46:41,876 INFO  L93              Difference]: Finished difference Result 14390 states and 17882 transitions.
[2020-05-30 20:46:41,876 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:46:41,876 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 14390 states and 17882 transitions.
[2020-05-30 20:46:41,909 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 269
[2020-05-30 20:46:41,958 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 14390 states to 13404 states and 16340 transitions.
[2020-05-30 20:46:41,959 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 155
[2020-05-30 20:46:41,959 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 155
[2020-05-30 20:46:41,959 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 13404 states and 16340 transitions.
[2020-05-30 20:46:41,974 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:46:41,975 INFO  L728         BuchiCegarLoop]: Abstraction has 13404 states and 16340 transitions.
[2020-05-30 20:46:41,989 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 13404 states and 16340 transitions.
[2020-05-30 20:46:42,108 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 13404 to 12709.
[2020-05-30 20:46:42,109 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 12709 states.
[2020-05-30 20:46:42,126 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 12709 states to 12709 states and 15470 transitions.
[2020-05-30 20:46:42,126 INFO  L751         BuchiCegarLoop]: Abstraction has 12709 states and 15470 transitions.
[2020-05-30 20:46:42,126 INFO  L631         BuchiCegarLoop]: Abstraction has 12709 states and 15470 transitions.
[2020-05-30 20:46:42,126 INFO  L445         BuchiCegarLoop]: ======== Iteration 5============
[2020-05-30 20:46:42,126 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 12709 states and 15470 transitions.
[2020-05-30 20:46:42,141 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 269
[2020-05-30 20:46:42,141 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:46:42,141 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:46:42,143 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:46:42,143 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND TRUE   __exception
[L531]                     __tmp__Balance := Balance;
[L532]                     __tmp__DType := DType;
[L533]                     __tmp__Alloc := Alloc;
[L534]                     __tmp__balance_ADDR := balance_ADDR;
[L535]                     __tmp__M_Ref_int__deposits0 := M_Ref_int__deposits0;
[L536]                     __tmp__sum__deposits0 := sum__deposits0;
[L537]                     __tmp__Length := Length;
[L538]                     __tmp__now := now;
[L539]                     __tmp___primary_Secondary := _primary_Secondary;
[L540]                     __tmp___deposits_Escrow := _deposits_Escrow;
[L541]                     __tmp___state_RefundEscrow := _state_RefundEscrow;
[L542]                     __tmp___beneficiary_RefundEscrow := _beneficiary_RefundEscrow;
[L543]         CALL        call RefundEscrow_RefundEscrow__fail(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2058]        CALL        call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1355]        CALL        call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1334]                    assume msgsender_MSG != null;
[L1335]                    __tmp__Balance[this] := 0;
[L1336]                    __tmp___primary_Secondary[this] := null;
[L1337]                    __tmp___primary_Secondary[this] := msgsender_MSG;
[L1355]        RET         call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1356]        COND FALSE  !(revert)
[L2058]        RET         call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L2059]        COND FALSE  !(revert)
[L2064]        CALL        call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L1484]        CALL        call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1355]        CALL        call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1334]                    assume msgsender_MSG != null;
[L1335]                    __tmp__Balance[this] := 0;
[L1336]                    __tmp___primary_Secondary[this] := null;
[L1337]                    __tmp___primary_Secondary[this] := msgsender_MSG;
[L1355]        RET         call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1356]        COND FALSE  !(revert)
[L1484]        RET         call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1485]        COND FALSE  !(revert)
[L1490]        CALL        call Escrow_Escrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1448]                    assume msgsender_MSG != null;
[L1449]                    __tmp__Balance[this] := 0;
[L1450]        CALL        call __var_2 := FreshRefGenerator__fail();
[L1168]                    havoc newRef;
[L1169]                    assume __tmp__Alloc[newRef] == false;
[L1170]                    __tmp__Alloc[newRef] := true;
[L1171]                    assume newRef != null;
[L1450]        RET         call __var_2 := FreshRefGenerator__fail();
[L1451]        COND FALSE  !(revert)
[L1456]                    __tmp___deposits_Escrow[this] := __var_2;
[L1457]                    __tmp__M_Ref_int__deposits0[__tmp___deposits_Escrow[this]] := zeroRefIntArr();
[L1458]                    __tmp__sum__deposits0[__tmp___deposits_Escrow[this]] := 0;
[L1490]        RET         call Escrow_Escrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1491]        COND FALSE  !(revert)
[L2064]        RET         call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L2065]        COND FALSE  !(revert)
[L2070]        CALL        call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L1864]        CALL        call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1355]        CALL        call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1334]                    assume msgsender_MSG != null;
[L1335]                    __tmp__Balance[this] := 0;
[L1336]                    __tmp___primary_Secondary[this] := null;
[L1337]                    __tmp___primary_Secondary[this] := msgsender_MSG;
[L1355]        RET         call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1356]        COND FALSE  !(revert)
[L1864]        RET         call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1865]        COND FALSE  !(revert)
[L1870]        CALL        call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L1484]        CALL        call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1355]        CALL        call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1334]                    assume msgsender_MSG != null;
[L1335]                    __tmp__Balance[this] := 0;
[L1336]                    __tmp___primary_Secondary[this] := null;
[L1337]                    __tmp___primary_Secondary[this] := msgsender_MSG;
[L1355]        RET         call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1356]        COND FALSE  !(revert)
[L1484]        RET         call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1485]        COND FALSE  !(revert)
[L1490]        CALL        call Escrow_Escrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1448]                    assume msgsender_MSG != null;
[L1449]                    __tmp__Balance[this] := 0;
[L1450]        CALL        call __var_2 := FreshRefGenerator__fail();
[L1168]                    havoc newRef;
[L1169]                    assume __tmp__Alloc[newRef] == false;
[L1170]                    __tmp__Alloc[newRef] := true;
[L1171]                    assume newRef != null;
[L1450]        RET         call __var_2 := FreshRefGenerator__fail();
[L1451]        COND FALSE  !(revert)
[L1456]                    __tmp___deposits_Escrow[this] := __var_2;
[L1457]                    __tmp__M_Ref_int__deposits0[__tmp___deposits_Escrow[this]] := zeroRefIntArr();
[L1458]                    __tmp__sum__deposits0[__tmp___deposits_Escrow[this]] := 0;
[L1490]        RET         call Escrow_Escrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1491]        COND FALSE  !(revert)
[L1870]        RET         call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L1871]        COND FALSE  !(revert)
[L1876]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1848]                    assume msgsender_MSG != null;
[L1849]                    __tmp__Balance[this] := 0;
[L1876]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1877]        COND FALSE  !(revert)
[L2070]        RET         call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L2071]        COND FALSE  !(revert)
[L2076]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2018]                    assume msgsender_MSG != null;
[L2019]                    __tmp__Balance[this] := 0;
[L2020]                    __tmp___beneficiary_RefundEscrow[this] := null;
[L2021]                    __var_7 := null;
[L2022]        COND FALSE  !(!(beneficiary_s294 != null))
[L2028]                    __tmp___beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2029]                    __tmp___state_RefundEscrow[this] := 0;
[L2076]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2077]        COND FALSE  !(revert)
[L543]         RET         call RefundEscrow_RefundEscrow__fail(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L544]                     assume revert || gas < 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND FALSE  !(choice == 2)
[L3835]        COND TRUE   choice == 1
[L3837]                    gas := gas - 21000;
[L3838]        COND TRUE   gas >= 0
[L3840]                    assume msgvalue_MSG == 0;
[L3841]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND FALSE  !(gas > 2300)
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND FALSE  !(Balance[from] >= amount)
[L3321]                    success := false;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3841]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND TRUE   choice == 3
[L3819]                    gas := gas - 21000;
[L3820]        COND TRUE   gas >= 0
[L3822]                    assume msgvalue_MSG == 0;
[L3823]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3823]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND TRUE   choice == 1
[L3837]              gas := gas - 21000;
[L3838]  COND TRUE   gas >= 0
[L3840]              assume msgvalue_MSG == 0;
[L3841]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND FALSE  !(gas > 2300)
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]              havoc __exception;
[L3289]  COND FALSE  !(__exception)
[L3314]  COND FALSE  !(Balance[from] >= amount)
[L3321]              success := false;
[L3324]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3841]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:46:42,149 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:46:42,149 INFO  L82        PathProgramCache]: Analyzing trace with hash 1657938732, now seen corresponding path program 1 times
[2020-05-30 20:46:42,150 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:46:42,163 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:46:42,248 INFO  L134       CoverageAnalysis]: Checked inductivity of 99 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 99 trivial. 0 not checked.
[2020-05-30 20:46:42,248 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:46:42,248 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-05-30 20:46:42,249 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:46:42,249 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-05-30 20:46:42,249 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=6, Invalid=6, Unknown=0, NotChecked=0, Total=12
[2020-05-30 20:46:42,250 INFO  L87              Difference]: Start difference. First operand 12709 states and 15470 transitions. cyclomatic complexity: 2785 Second operand 4 states.
[2020-05-30 20:46:45,238 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:46:45,238 INFO  L93              Difference]: Finished difference Result 14620 states and 17596 transitions.
[2020-05-30 20:46:45,238 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 4 states. 
[2020-05-30 20:46:45,238 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 14620 states and 17596 transitions.
[2020-05-30 20:46:45,263 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 273
[2020-05-30 20:46:45,299 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 14620 states to 14412 states and 17201 transitions.
[2020-05-30 20:46:45,300 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 203
[2020-05-30 20:46:45,300 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 203
[2020-05-30 20:46:45,300 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 14412 states and 17201 transitions.
[2020-05-30 20:46:45,308 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:46:45,308 INFO  L728         BuchiCegarLoop]: Abstraction has 14412 states and 17201 transitions.
[2020-05-30 20:46:45,319 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 14412 states and 17201 transitions.
[2020-05-30 20:46:45,428 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 14412 to 12508.
[2020-05-30 20:46:45,428 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 12508 states.
[2020-05-30 20:46:45,442 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 12508 states to 12508 states and 14752 transitions.
[2020-05-30 20:46:45,443 INFO  L751         BuchiCegarLoop]: Abstraction has 12508 states and 14752 transitions.
[2020-05-30 20:46:45,443 INFO  L631         BuchiCegarLoop]: Abstraction has 12508 states and 14752 transitions.
[2020-05-30 20:46:45,443 INFO  L445         BuchiCegarLoop]: ======== Iteration 6============
[2020-05-30 20:46:45,443 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 12508 states and 14752 transitions.
[2020-05-30 20:46:45,456 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 269
[2020-05-30 20:46:45,457 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:46:45,457 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:46:45,459 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:46:45,459 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND FALSE  !(choice == 2)
[L3835]        COND TRUE   choice == 1
[L3837]                    gas := gas - 21000;
[L3838]        COND TRUE   gas >= 0
[L3840]                    assume msgvalue_MSG == 0;
[L3841]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND FALSE  !(gas > 2300)
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND FALSE  !(Balance[from] >= amount)
[L3321]                    success := false;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3841]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND TRUE   choice == 3
[L3819]                    gas := gas - 21000;
[L3820]        COND TRUE   gas >= 0
[L3822]                    assume msgvalue_MSG == 0;
[L3823]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3823]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND TRUE   choice == 1
[L3837]              gas := gas - 21000;
[L3838]  COND TRUE   gas >= 0
[L3840]              assume msgvalue_MSG == 0;
[L3841]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND FALSE  !(gas > 2300)
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]              havoc __exception;
[L3289]  COND FALSE  !(__exception)
[L3314]  COND FALSE  !(Balance[from] >= amount)
[L3321]              success := false;
[L3324]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3841]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:46:45,464 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:46:45,464 INFO  L82        PathProgramCache]: Analyzing trace with hash -864934024, now seen corresponding path program 1 times
[2020-05-30 20:46:45,464 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:46:45,481 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:46:45,545 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:46:45,545 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:46:45,545 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-05-30 20:46:45,546 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:46:45,546 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-05-30 20:46:45,546 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=5, Invalid=7, Unknown=0, NotChecked=0, Total=12
[2020-05-30 20:46:45,546 INFO  L87              Difference]: Start difference. First operand 12508 states and 14752 transitions. cyclomatic complexity: 2268 Second operand 4 states.
[2020-05-30 20:46:45,675 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:46:45,675 INFO  L93              Difference]: Finished difference Result 12588 states and 14836 transitions.
[2020-05-30 20:46:45,675 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 4 states. 
[2020-05-30 20:46:45,675 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 12588 states and 14836 transitions.
[2020-05-30 20:46:45,697 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 269
[2020-05-30 20:46:45,726 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 12588 states to 12572 states and 14820 transitions.
[2020-05-30 20:46:45,726 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 135
[2020-05-30 20:46:45,726 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 135
[2020-05-30 20:46:45,726 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 12572 states and 14820 transitions.
[2020-05-30 20:46:45,736 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:46:45,736 INFO  L728         BuchiCegarLoop]: Abstraction has 12572 states and 14820 transitions.
[2020-05-30 20:46:45,750 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 12572 states and 14820 transitions.
[2020-05-30 20:46:45,837 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 12572 to 12572.
[2020-05-30 20:46:45,837 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 12572 states.
[2020-05-30 20:46:45,853 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 12572 states to 12572 states and 14820 transitions.
[2020-05-30 20:46:45,853 INFO  L751         BuchiCegarLoop]: Abstraction has 12572 states and 14820 transitions.
[2020-05-30 20:46:45,853 INFO  L631         BuchiCegarLoop]: Abstraction has 12572 states and 14820 transitions.
[2020-05-30 20:46:45,853 INFO  L445         BuchiCegarLoop]: ======== Iteration 7============
[2020-05-30 20:46:45,854 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 12572 states and 14820 transitions.
[2020-05-30 20:46:45,867 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 269
[2020-05-30 20:46:45,867 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:46:45,867 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:46:45,869 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:46:45,870 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND FALSE  !(choice == 2)
[L3835]        COND TRUE   choice == 1
[L3837]                    gas := gas - 21000;
[L3838]        COND TRUE   gas >= 0
[L3840]                    assume msgvalue_MSG == 0;
[L3841]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND FALSE  !(gas > 2300)
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3841]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND TRUE   choice == 3
[L3819]                    gas := gas - 21000;
[L3820]        COND TRUE   gas >= 0
[L3822]                    assume msgvalue_MSG == 0;
[L3823]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3823]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND TRUE   choice == 1
[L3837]              gas := gas - 21000;
[L3838]  COND TRUE   gas >= 0
[L3840]              assume msgvalue_MSG == 0;
[L3841]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND FALSE  !(gas > 2300)
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]              havoc __exception;
[L3289]  COND FALSE  !(__exception)
[L3314]  COND TRUE   Balance[from] >= amount
[L3316]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND TRUE   DType[to] == RefundEscrow
[L2426]              assume amount == 0;
[L3316]  RET         call FallbackDispatch__success(from, to, amount);
[L3317]              success := true;
[L3324]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3841]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:46:45,874 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:46:45,874 INFO  L82        PathProgramCache]: Analyzing trace with hash -259357584, now seen corresponding path program 1 times
[2020-05-30 20:46:45,875 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:46:45,891 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:46:46,004 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:46:46,004 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:46:46,004 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [11] imperfect sequences [] total 11
[2020-05-30 20:46:46,005 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:46:46,005 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-05-30 20:46:46,005 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=21, Invalid=89, Unknown=0, NotChecked=0, Total=110
[2020-05-30 20:46:46,005 INFO  L87              Difference]: Start difference. First operand 12572 states and 14820 transitions. cyclomatic complexity: 2272 Second operand 11 states.
[2020-05-30 20:46:53,184 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:46:53,185 INFO  L93              Difference]: Finished difference Result 14598 states and 17419 transitions.
[2020-05-30 20:46:53,185 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-30 20:46:53,185 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 14598 states and 17419 transitions.
[2020-05-30 20:46:53,218 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 454
[2020-05-30 20:46:53,263 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 14598 states to 14598 states and 17419 transitions.
[2020-05-30 20:46:53,263 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 174
[2020-05-30 20:46:53,264 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 174
[2020-05-30 20:46:53,264 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 14598 states and 17419 transitions.
[2020-05-30 20:46:53,274 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:46:53,274 INFO  L728         BuchiCegarLoop]: Abstraction has 14598 states and 17419 transitions.
[2020-05-30 20:46:53,285 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 14598 states and 17419 transitions.
[2020-05-30 20:46:53,369 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 14598 to 12858.
[2020-05-30 20:46:53,370 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 12858 states.
[2020-05-30 20:46:53,384 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 12858 states to 12858 states and 15178 transitions.
[2020-05-30 20:46:53,384 INFO  L751         BuchiCegarLoop]: Abstraction has 12858 states and 15178 transitions.
[2020-05-30 20:46:53,384 INFO  L631         BuchiCegarLoop]: Abstraction has 12858 states and 15178 transitions.
[2020-05-30 20:46:53,384 INFO  L445         BuchiCegarLoop]: ======== Iteration 8============
[2020-05-30 20:46:53,384 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 12858 states and 15178 transitions.
[2020-05-30 20:46:53,396 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 269
[2020-05-30 20:46:53,396 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:46:53,396 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:46:53,397 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:46:53,398 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND TRUE   choice == 3
[L3819]                    gas := gas - 21000;
[L3820]        COND TRUE   gas >= 0
[L3822]                    assume msgvalue_MSG == 0;
[L3823]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3823]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND FALSE  !(choice == 2)
[L3835]        COND TRUE   choice == 1
[L3837]                    gas := gas - 21000;
[L3838]        COND TRUE   gas >= 0
[L3840]                    assume msgvalue_MSG == 0;
[L3841]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND FALSE  !(gas > 2300)
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3841]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND TRUE   choice == 1
[L3837]              gas := gas - 21000;
[L3838]  COND TRUE   gas >= 0
[L3840]              assume msgvalue_MSG == 0;
[L3841]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND FALSE  !(gas > 2300)
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]              havoc __exception;
[L3289]  COND FALSE  !(__exception)
[L3314]  COND TRUE   Balance[from] >= amount
[L3316]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND TRUE   DType[to] == RefundEscrow
[L2426]              assume amount == 0;
[L3316]  RET         call FallbackDispatch__success(from, to, amount);
[L3317]              success := true;
[L3324]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3841]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:46:53,401 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:46:53,401 INFO  L82        PathProgramCache]: Analyzing trace with hash -278410477, now seen corresponding path program 1 times
[2020-05-30 20:46:53,402 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:46:53,416 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:46:53,506 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:46:53,506 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:46:53,506 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [9] imperfect sequences [] total 9
[2020-05-30 20:46:53,507 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:46:53,507 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 10 interpolants.
[2020-05-30 20:46:53,507 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=17, Invalid=73, Unknown=0, NotChecked=0, Total=90
[2020-05-30 20:46:53,507 INFO  L87              Difference]: Start difference. First operand 12858 states and 15178 transitions. cyclomatic complexity: 2346 Second operand 10 states.
[2020-05-30 20:47:05,332 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:47:05,333 INFO  L93              Difference]: Finished difference Result 15657 states and 18893 transitions.
[2020-05-30 20:47:05,333 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 10 states. 
[2020-05-30 20:47:05,333 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 15657 states and 18893 transitions.
[2020-05-30 20:47:05,371 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 458
[2020-05-30 20:47:05,416 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 15657 states to 15657 states and 18893 transitions.
[2020-05-30 20:47:05,417 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 199
[2020-05-30 20:47:05,417 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 199
[2020-05-30 20:47:05,417 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 15657 states and 18893 transitions.
[2020-05-30 20:47:05,427 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:47:05,428 INFO  L728         BuchiCegarLoop]: Abstraction has 15657 states and 18893 transitions.
[2020-05-30 20:47:05,439 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 15657 states and 18893 transitions.
[2020-05-30 20:47:05,528 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 15657 to 15021.
[2020-05-30 20:47:05,528 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 15021 states.
[2020-05-30 20:47:05,546 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 15021 states to 15021 states and 17982 transitions.
[2020-05-30 20:47:05,546 INFO  L751         BuchiCegarLoop]: Abstraction has 15021 states and 17982 transitions.
[2020-05-30 20:47:05,546 INFO  L631         BuchiCegarLoop]: Abstraction has 15021 states and 17982 transitions.
[2020-05-30 20:47:05,546 INFO  L445         BuchiCegarLoop]: ======== Iteration 9============
[2020-05-30 20:47:05,546 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 15021 states and 17982 transitions.
[2020-05-30 20:47:05,560 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 446
[2020-05-30 20:47:05,560 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:47:05,560 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:47:05,561 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:47:05,562 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND TRUE   choice == 3
[L3819]                    gas := gas - 21000;
[L3820]        COND TRUE   gas >= 0
[L3822]                    assume msgvalue_MSG == 0;
[L3823]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3823]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND FALSE  !(choice == 2)
[L3835]        COND TRUE   choice == 1
[L3837]                    gas := gas - 21000;
[L3838]        COND TRUE   gas >= 0
[L3840]                    assume msgvalue_MSG == 0;
[L3841]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND FALSE  !(gas > 2300)
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3841]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND TRUE   choice == 1
[L3837]              gas := gas - 21000;
[L3838]  COND TRUE   gas >= 0
[L3840]              assume msgvalue_MSG == 0;
[L3841]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND FALSE  !(gas > 2300)
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]              havoc __exception;
[L3289]  COND FALSE  !(__exception)
[L3314]  COND TRUE   Balance[from] >= amount
[L3316]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND TRUE   DType[to] == RefundEscrow
[L2426]              assume amount == 0;
[L3316]  RET         call FallbackDispatch__success(from, to, amount);
[L3317]              success := true;
[L3324]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3841]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:47:05,565 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:47:05,565 INFO  L82        PathProgramCache]: Analyzing trace with hash 2135396873, now seen corresponding path program 1 times
[2020-05-30 20:47:05,566 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:47:05,581 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:47:05,685 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:47:05,685 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:47:05,685 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [8] imperfect sequences [] total 8
[2020-05-30 20:47:05,685 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:47:05,686 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 8 interpolants.
[2020-05-30 20:47:05,686 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=17, Invalid=39, Unknown=0, NotChecked=0, Total=56
[2020-05-30 20:47:05,686 INFO  L87              Difference]: Start difference. First operand 15021 states and 17982 transitions. cyclomatic complexity: 2987 Second operand 8 states.
[2020-05-30 20:47:15,344 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:47:15,344 INFO  L93              Difference]: Finished difference Result 21441 states and 26717 transitions.
[2020-05-30 20:47:15,345 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 12 states. 
[2020-05-30 20:47:15,345 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 21441 states and 26717 transitions.
[2020-05-30 20:47:15,400 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 674
[2020-05-30 20:47:15,469 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 21441 states to 21441 states and 26717 transitions.
[2020-05-30 20:47:15,469 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 298
[2020-05-30 20:47:15,470 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 298
[2020-05-30 20:47:15,470 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 21441 states and 26717 transitions.
[2020-05-30 20:47:15,484 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:47:15,484 INFO  L728         BuchiCegarLoop]: Abstraction has 21441 states and 26717 transitions.
[2020-05-30 20:47:15,497 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 21441 states and 26717 transitions.
[2020-05-30 20:47:15,605 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 21441 to 15237.
[2020-05-30 20:47:15,605 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 15237 states.
[2020-05-30 20:47:15,624 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 15237 states to 15237 states and 18072 transitions.
[2020-05-30 20:47:15,624 INFO  L751         BuchiCegarLoop]: Abstraction has 15237 states and 18072 transitions.
[2020-05-30 20:47:15,625 INFO  L631         BuchiCegarLoop]: Abstraction has 15237 states and 18072 transitions.
[2020-05-30 20:47:15,625 INFO  L445         BuchiCegarLoop]: ======== Iteration 10============
[2020-05-30 20:47:15,625 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 15237 states and 18072 transitions.
[2020-05-30 20:47:15,638 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 450
[2020-05-30 20:47:15,638 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:47:15,638 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:47:15,640 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:47:15,640 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND TRUE   choice == 3
[L3819]                    gas := gas - 21000;
[L3820]        COND TRUE   gas >= 0
[L3822]                    assume msgvalue_MSG == 0;
[L3823]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3823]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND FALSE  !(choice == 2)
[L3835]        COND TRUE   choice == 1
[L3837]                    gas := gas - 21000;
[L3838]        COND TRUE   gas >= 0
[L3840]                    assume msgvalue_MSG == 0;
[L3841]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3841]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND FALSE  !(choice == 1)
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:47:15,643 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:47:15,643 INFO  L82        PathProgramCache]: Analyzing trace with hash -1675976937, now seen corresponding path program 1 times
[2020-05-30 20:47:15,644 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:47:15,662 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:47:16,006 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:47:16,006 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:47:16,006 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [34] imperfect sequences [] total 34
[2020-05-30 20:47:16,007 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:47:16,007 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 35 interpolants.
[2020-05-30 20:47:16,007 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=101, Invalid=1089, Unknown=0, NotChecked=0, Total=1190
[2020-05-30 20:47:16,008 INFO  L87              Difference]: Start difference. First operand 15237 states and 18072 transitions. cyclomatic complexity: 2861 Second operand 35 states.
[2020-05-30 20:48:05,626 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:48:05,626 INFO  L93              Difference]: Finished difference Result 31968 states and 39650 transitions.
[2020-05-30 20:48:05,627 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 66 states. 
[2020-05-30 20:48:05,627 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 31968 states and 39650 transitions.
[2020-05-30 20:48:05,706 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 908
[2020-05-30 20:48:05,817 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 31968 states to 31968 states and 39650 transitions.
[2020-05-30 20:48:05,817 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 487
[2020-05-30 20:48:05,817 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 487
[2020-05-30 20:48:05,818 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 31968 states and 39650 transitions.
[2020-05-30 20:48:05,843 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:48:05,843 INFO  L728         BuchiCegarLoop]: Abstraction has 31968 states and 39650 transitions.
[2020-05-30 20:48:05,860 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 31968 states and 39650 transitions.
[2020-05-30 20:48:06,251 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 31968 to 31494.
[2020-05-30 20:48:06,251 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 31494 states.
[2020-05-30 20:48:06,301 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 31494 states to 31494 states and 38790 transitions.
[2020-05-30 20:48:06,301 INFO  L751         BuchiCegarLoop]: Abstraction has 31494 states and 38790 transitions.
[2020-05-30 20:48:06,301 INFO  L631         BuchiCegarLoop]: Abstraction has 31494 states and 38790 transitions.
[2020-05-30 20:48:06,301 INFO  L445         BuchiCegarLoop]: ======== Iteration 11============
[2020-05-30 20:48:06,301 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 31494 states and 38790 transitions.
[2020-05-30 20:48:06,333 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 908
[2020-05-30 20:48:06,333 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:48:06,333 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:48:06,334 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:48:06,335 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND TRUE   choice == 3
[L3819]                    gas := gas - 21000;
[L3820]        COND TRUE   gas >= 0
[L3822]                    assume msgvalue_MSG == 0;
[L3823]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3823]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND FALSE  !(choice == 2)
[L3835]        COND TRUE   choice == 1
[L3837]                    gas := gas - 21000;
[L3838]        COND TRUE   gas >= 0
[L3840]                    assume msgvalue_MSG == 0;
[L3841]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3841]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND FALSE  !(choice == 1)
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:48:06,341 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:48:06,342 INFO  L82        PathProgramCache]: Analyzing trace with hash -661041016, now seen corresponding path program 1 times
[2020-05-30 20:48:06,342 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:48:06,355 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:48:06,426 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:48:06,426 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:48:06,427 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [10] imperfect sequences [] total 10
[2020-05-30 20:48:06,427 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:48:06,427 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 10 interpolants.
[2020-05-30 20:48:06,427 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=18, Invalid=72, Unknown=0, NotChecked=0, Total=90
[2020-05-30 20:48:06,428 INFO  L87              Difference]: Start difference. First operand 31494 states and 38790 transitions. cyclomatic complexity: 7366 Second operand 10 states.
[2020-05-30 20:48:24,694 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:48:24,694 INFO  L93              Difference]: Finished difference Result 35630 states and 45024 transitions.
[2020-05-30 20:48:24,694 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-30 20:48:24,694 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 35630 states and 45024 transitions.
[2020-05-30 20:48:24,806 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 940
[2020-05-30 20:48:24,965 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 35630 states to 35518 states and 44896 transitions.
[2020-05-30 20:48:24,965 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 559
[2020-05-30 20:48:24,966 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 559
[2020-05-30 20:48:24,966 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 35518 states and 44896 transitions.
[2020-05-30 20:48:24,999 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:48:24,999 INFO  L728         BuchiCegarLoop]: Abstraction has 35518 states and 44896 transitions.
[2020-05-30 20:48:25,021 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 35518 states and 44896 transitions.
[2020-05-30 20:48:25,361 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 35518 to 35390.
[2020-05-30 20:48:25,361 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 35390 states.
[2020-05-30 20:48:25,433 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 35390 states to 35390 states and 44736 transitions.
[2020-05-30 20:48:25,433 INFO  L751         BuchiCegarLoop]: Abstraction has 35390 states and 44736 transitions.
[2020-05-30 20:48:25,433 INFO  L631         BuchiCegarLoop]: Abstraction has 35390 states and 44736 transitions.
[2020-05-30 20:48:25,433 INFO  L445         BuchiCegarLoop]: ======== Iteration 12============
[2020-05-30 20:48:25,433 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 35390 states and 44736 transitions.
[2020-05-30 20:48:25,472 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 924
[2020-05-30 20:48:25,472 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:48:25,472 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:48:25,474 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:48:25,474 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND TRUE   choice == 3
[L3819]                    gas := gas - 21000;
[L3820]        COND TRUE   gas >= 0
[L3822]                    assume msgvalue_MSG == 0;
[L3823]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3823]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND FALSE  !(choice == 2)
[L3835]        COND TRUE   choice == 1
[L3837]                    gas := gas - 21000;
[L3838]        COND TRUE   gas >= 0
[L3840]                    assume msgvalue_MSG == 0;
[L3841]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3841]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND TRUE   choice == 10
[L3756]              gas := gas - 21000;
[L3757]  COND TRUE   gas >= 0
[L3759]              assume msgvalue_MSG == 0;
[L3760]  CALL        call transferPrimary_Secondary(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L230]               havoc __exception;
[L231]               revert := false;
[L232]   COND FALSE  !(__exception)
[L251]   CALL        call transferPrimary_Secondary__success(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L1423]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]              gas := gas - 2208;
[L3345]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1423]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1424]  COND FALSE  !(revert)
[L1429]              gas := gas - 88;
[L1430]              __var_1 := null;
[L1431]  COND FALSE  !(!(recipient_s113 != null))
[L1437]              gas := gas - 40534;
[L1438]              _primary_Secondary[this] := recipient_s113;
[L1439]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L251]   RET         call transferPrimary_Secondary__success(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L252]               assume !revert && gas >= 0;
[L3760]  RET         call transferPrimary_Secondary(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:48:25,478 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:48:25,478 INFO  L82        PathProgramCache]: Analyzing trace with hash 484910603, now seen corresponding path program 1 times
[2020-05-30 20:48:25,479 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:48:25,500 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:48:25,827 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:48:25,828 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:48:25,828 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [31] imperfect sequences [] total 31
[2020-05-30 20:48:25,828 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:48:25,828 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 32 interpolants.
[2020-05-30 20:48:25,829 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=91, Invalid=901, Unknown=0, NotChecked=0, Total=992
[2020-05-30 20:48:25,829 INFO  L87              Difference]: Start difference. First operand 35390 states and 44736 transitions. cyclomatic complexity: 9416 Second operand 32 states.
[2020-05-30 20:49:27,637 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:49:27,637 INFO  L93              Difference]: Finished difference Result 45382 states and 58884 transitions.
[2020-05-30 20:49:27,638 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 61 states. 
[2020-05-30 20:49:27,638 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 45382 states and 58884 transitions.
[2020-05-30 20:49:27,770 INFO  L131   ngComponentsAnalysis]: Automaton has 9 accepting balls. 940
[2020-05-30 20:49:27,971 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 45382 states to 45382 states and 58884 transitions.
[2020-05-30 20:49:27,971 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 602
[2020-05-30 20:49:27,972 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 602
[2020-05-30 20:49:27,972 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 45382 states and 58884 transitions.
[2020-05-30 20:49:28,014 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:49:28,014 INFO  L728         BuchiCegarLoop]: Abstraction has 45382 states and 58884 transitions.
[2020-05-30 20:49:28,037 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 45382 states and 58884 transitions.
[2020-05-30 20:49:28,415 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 45382 to 44754.
[2020-05-30 20:49:28,415 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 44754 states.
[2020-05-30 20:49:28,511 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 44754 states to 44754 states and 57978 transitions.
[2020-05-30 20:49:28,511 INFO  L751         BuchiCegarLoop]: Abstraction has 44754 states and 57978 transitions.
[2020-05-30 20:49:28,511 INFO  L631         BuchiCegarLoop]: Abstraction has 44754 states and 57978 transitions.
[2020-05-30 20:49:28,512 INFO  L445         BuchiCegarLoop]: ======== Iteration 13============
[2020-05-30 20:49:28,512 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 44754 states and 57978 transitions.
[2020-05-30 20:49:28,560 INFO  L131   ngComponentsAnalysis]: Automaton has 9 accepting balls. 940
[2020-05-30 20:49:28,561 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:49:28,561 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:49:28,563 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:49:28,563 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND FALSE  !(DType[this] == RefundEscrow)
[L1974]        COND TRUE   DType[this] == ConditionalEscrow
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND FALSE  !(DType[this] == RefundEscrow)
[L1998]        COND TRUE   DType[this] == ConditionalEscrow
[L2000]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND FALSE  !(gas < 21000)
[L2869]        COND TRUE   iterate && gas >= 21000
[L2871]                    havoc msgsender_MSG;
[L2872]                    havoc msgvalue_MSG;
[L2873]                    havoc choice;
[L2874]                    havoc __ret_0_primary;
[L2875]                    havoc recipient_s113;
[L2876]                    havoc payee_s148;
[L2877]                    havoc __ret_0_depositsOf;
[L2878]                    havoc payee_s158;
[L2879]                    havoc payee_s197;
[L2880]                    havoc payee_s255;
[L2881]                    havoc payee_s239;
[L2882]                    havoc __ret_0_withdrawalAllowed;
[L2883]                    havoc refundee_s327;
[L2884]                    havoc __arg_0_withdrawalAllowed;
[L2885]                    havoc beneficiary_s294;
[L2886]                    havoc __ret_0_state;
[L2887]                    havoc __ret_0_beneficiary;
[L2888]                    havoc iterate;
[L2889]        COND TRUE   DType[from] == RefundEscrow
[L2891]        COND FALSE  !(choice == 11)
[L2904]        COND FALSE  !(choice == 10)
[L2917]        COND FALSE  !(choice == 9)
[L2930]        COND FALSE  !(choice == 8)
[L2943]        COND FALSE  !(choice == 7)
[L2956]        COND FALSE  !(choice == 6)
[L2969]        COND FALSE  !(choice == 5)
[L2982]        COND FALSE  !(choice == 4)
[L2995]        COND FALSE  !(choice == 3)
[L3008]        COND FALSE  !(choice == 2)
[L3021]        COND TRUE   choice == 1
[L3023]                    gas := gas - 21000;
[L3024]        COND TRUE   gas >= 0
[L3026]                    assume msgvalue_MSG == 0;
[L3027]        CALL        call beneficiaryWithdraw_RefundEscrow__success(from, to, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND FALSE  !(gas > 2300)
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == ben && amount == fsum_deposit_RefundEscrow_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L3027]        RET         call beneficiaryWithdraw_RefundEscrow__success(from, to, msgvalue_MSG);
[L3028]        COND FALSE  !(revert)
[L2869]        COND FALSE  !(iterate && gas >= 21000)
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L2000]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2001]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND TRUE   choice == 3
[L3819]                    gas := gas - 21000;
[L3820]        COND TRUE   gas >= 0
[L3822]                    assume msgvalue_MSG == 0;
[L3823]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3823]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND FALSE  !(choice == 2)
[L3835]        COND TRUE   choice == 1
[L3837]                    gas := gas - 21000;
[L3838]        COND TRUE   gas >= 0
[L3840]                    assume msgvalue_MSG == 0;
[L3841]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3841]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND TRUE   choice == 1
[L3837]              gas := gas - 21000;
[L3838]  COND TRUE   gas >= 0
[L3840]              assume msgvalue_MSG == 0;
[L3841]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND TRUE   gas > 2300
[L2352]              gas := 2300;
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]              havoc __exception;
[L3289]  COND FALSE  !(__exception)
[L3314]  COND TRUE   Balance[from] >= amount
[L3316]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND FALSE  !(DType[to] == RefundEscrow)
[L2428]  COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]  COND FALSE  !(DType[to] == Escrow)
[L2436]  COND FALSE  !(DType[to] == Secondary)
[L2442]  CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]              assume Balance[from] >= amount;
[L2856]              Balance[from] := Balance[from] - amount;
[L2857]              Balance[to] := Balance[to] + amount;
[L2858]  COND FALSE  !(choice == 0)
[L2864]  COND TRUE   gas < 21000
[L2442]  RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]  COND FALSE  !(revert)
[L3316]  RET         call FallbackDispatch__success(from, to, amount);
[L3317]              success := true;
[L3324]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3841]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:49:28,569 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:49:28,569 INFO  L82        PathProgramCache]: Analyzing trace with hash -820944085, now seen corresponding path program 1 times
[2020-05-30 20:49:28,570 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:49:28,588 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:49:28,711 INFO  L134       CoverageAnalysis]: Checked inductivity of 176 backedges. 15 proven. 7 refuted. 0 times theorem prover too weak. 154 trivial. 0 not checked.
[2020-05-30 20:49:28,711 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:49:28,711 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [6] total 6
[2020-05-30 20:49:28,712 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:49:28,712 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 6 interpolants.
[2020-05-30 20:49:28,712 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=11, Invalid=19, Unknown=0, NotChecked=0, Total=30
[2020-05-30 20:49:28,712 INFO  L87              Difference]: Start difference. First operand 44754 states and 57978 transitions. cyclomatic complexity: 13338 Second operand 6 states.
[2020-05-30 20:49:31,921 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:49:31,921 INFO  L93              Difference]: Finished difference Result 31482 states and 41477 transitions.
[2020-05-30 20:49:31,921 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 5 states. 
[2020-05-30 20:49:31,921 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 31482 states and 41477 transitions.
[2020-05-30 20:49:32,044 INFO  L131   ngComponentsAnalysis]: Automaton has 7 accepting balls. 96
[2020-05-30 20:49:32,220 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 31482 states to 31042 states and 40961 transitions.
[2020-05-30 20:49:32,220 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 615
[2020-05-30 20:49:32,223 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 3013
[2020-05-30 20:49:32,223 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 31042 states and 40961 transitions.
[2020-05-30 20:49:32,259 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:49:32,259 INFO  L728         BuchiCegarLoop]: Abstraction has 31042 states and 40961 transitions.
[2020-05-30 20:49:32,274 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 31042 states and 40961 transitions.
[2020-05-30 20:49:32,547 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 31042 to 28174.
[2020-05-30 20:49:32,547 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 28174 states.
[2020-05-30 20:49:32,612 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 28174 states to 28174 states and 34405 transitions.
[2020-05-30 20:49:32,612 INFO  L751         BuchiCegarLoop]: Abstraction has 28174 states and 34405 transitions.
[2020-05-30 20:49:32,612 INFO  L631         BuchiCegarLoop]: Abstraction has 28174 states and 34405 transitions.
[2020-05-30 20:49:32,612 INFO  L445         BuchiCegarLoop]: ======== Iteration 14============
[2020-05-30 20:49:32,612 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 28174 states and 34405 transitions.
[2020-05-30 20:49:32,646 INFO  L131   ngComponentsAnalysis]: Automaton has 7 accepting balls. 48
[2020-05-30 20:49:32,647 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:49:32,647 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:49:32,649 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:49:32,649 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND TRUE   choice == 3
[L3819]                    gas := gas - 21000;
[L3820]        COND TRUE   gas >= 0
[L3822]                    assume msgvalue_MSG == 0;
[L3823]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume !(ben == __beneficiary_RefundEscrow0);
[L7]                       revert := revert_hold;
[L3823]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND FALSE  !(choice == 2)
[L3835]        COND TRUE   choice == 1
[L3837]                    gas := gas - 21000;
[L3838]        COND TRUE   gas >= 0
[L3840]                    assume msgvalue_MSG == 0;
[L3841]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == ben && amount == fsum_deposit_RefundEscrow_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3841]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND TRUE   choice == 3
[L3819]                    gas := gas - 21000;
[L3820]        COND TRUE   gas >= 0
[L3822]                    assume msgvalue_MSG == 0;
[L3823]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3823]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND FALSE  !(choice == 1)
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:49:32,653 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:49:32,653 INFO  L82        PathProgramCache]: Analyzing trace with hash 647337413, now seen corresponding path program 1 times
[2020-05-30 20:49:32,654 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:49:32,671 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:49:32,773 INFO  L134       CoverageAnalysis]: Checked inductivity of 203 backedges. 4 proven. 2 refuted. 0 times theorem prover too weak. 197 trivial. 0 not checked.
[2020-05-30 20:49:32,773 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:49:32,773 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [11] total 11
[2020-05-30 20:49:32,774 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:49:32,774 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-05-30 20:49:32,774 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=19, Invalid=91, Unknown=0, NotChecked=0, Total=110
[2020-05-30 20:49:32,774 INFO  L87              Difference]: Start difference. First operand 28174 states and 34405 transitions. cyclomatic complexity: 6305 Second operand 11 states.
[2020-05-30 20:49:36,092 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:49:36,092 INFO  L93              Difference]: Finished difference Result 38064 states and 47943 transitions.
[2020-05-30 20:49:36,092 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 12 states. 
[2020-05-30 20:49:36,092 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 38064 states and 47943 transitions.
[2020-05-30 20:49:36,225 INFO  L131   ngComponentsAnalysis]: Automaton has 15 accepting balls. 88
[2020-05-30 20:49:36,378 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 38064 states to 32934 states and 40489 transitions.
[2020-05-30 20:49:36,379 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 3696
[2020-05-30 20:49:36,382 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 3696
[2020-05-30 20:49:36,382 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 32934 states and 40489 transitions.
[2020-05-30 20:49:36,413 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:49:36,413 INFO  L728         BuchiCegarLoop]: Abstraction has 32934 states and 40489 transitions.
[2020-05-30 20:49:36,429 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 32934 states and 40489 transitions.
[2020-05-30 20:49:36,683 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 32934 to 32696.
[2020-05-30 20:49:36,683 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 32696 states.
[2020-05-30 20:49:36,766 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 32696 states to 32696 states and 39911 transitions.
[2020-05-30 20:49:36,766 INFO  L751         BuchiCegarLoop]: Abstraction has 32696 states and 39911 transitions.
[2020-05-30 20:49:36,766 INFO  L631         BuchiCegarLoop]: Abstraction has 32696 states and 39911 transitions.
[2020-05-30 20:49:36,766 INFO  L445         BuchiCegarLoop]: ======== Iteration 15============
[2020-05-30 20:49:36,766 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 32696 states and 39911 transitions.
[2020-05-30 20:49:36,809 INFO  L131   ngComponentsAnalysis]: Automaton has 13 accepting balls. 72
[2020-05-30 20:49:36,809 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:49:36,809 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:49:36,811 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:49:36,811 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND TRUE   choice == 3
[L3819]                    gas := gas - 21000;
[L3820]        COND TRUE   gas >= 0
[L3822]                    assume msgvalue_MSG == 0;
[L3823]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3823]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND FALSE  !(choice == 2)
[L3835]        COND TRUE   choice == 1
[L3837]                    gas := gas - 21000;
[L3838]        COND TRUE   gas >= 0
[L3840]                    assume msgvalue_MSG == 0;
[L3841]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == ben && amount == fsum_deposit_RefundEscrow_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3841]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND TRUE   choice == 3
[L3819]                    gas := gas - 21000;
[L3820]        COND TRUE   gas >= 0
[L3822]                    assume msgvalue_MSG == 0;
[L3823]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3823]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND FALSE  !(choice == 1)
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:49:36,816 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:49:36,816 INFO  L82        PathProgramCache]: Analyzing trace with hash 1915332478, now seen corresponding path program 1 times
[2020-05-30 20:49:36,817 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:49:36,836 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:49:36,979 INFO  L134       CoverageAnalysis]: Checked inductivity of 307 backedges. 2 proven. 39 refuted. 0 times theorem prover too weak. 266 trivial. 0 not checked.
[2020-05-30 20:49:36,979 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:49:36,979 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [11] total 11
[2020-05-30 20:49:36,980 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:49:36,980 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-05-30 20:49:36,980 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=21, Invalid=89, Unknown=0, NotChecked=0, Total=110
[2020-05-30 20:49:36,981 INFO  L87              Difference]: Start difference. First operand 32696 states and 39911 transitions. cyclomatic complexity: 7325 Second operand 11 states.
[2020-05-30 20:49:47,286 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:49:47,286 INFO  L93              Difference]: Finished difference Result 32766 states and 39798 transitions.
[2020-05-30 20:49:47,286 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 11 states. 
[2020-05-30 20:49:47,286 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 32766 states and 39798 transitions.
[2020-05-30 20:49:47,403 INFO  L131   ngComponentsAnalysis]: Automaton has 19 accepting balls. 72
[2020-05-30 20:49:47,533 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 32766 states to 30336 states and 36272 transitions.
[2020-05-30 20:49:47,533 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 3667
[2020-05-30 20:49:47,536 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 3667
[2020-05-30 20:49:47,536 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 30336 states and 36272 transitions.
[2020-05-30 20:49:47,563 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:49:47,563 INFO  L728         BuchiCegarLoop]: Abstraction has 30336 states and 36272 transitions.
[2020-05-30 20:49:47,579 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 30336 states and 36272 transitions.
[2020-05-30 20:49:47,804 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 30336 to 30256.
[2020-05-30 20:49:47,805 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 30256 states.
[2020-05-30 20:49:47,869 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 30256 states to 30256 states and 36132 transitions.
[2020-05-30 20:49:47,870 INFO  L751         BuchiCegarLoop]: Abstraction has 30256 states and 36132 transitions.
[2020-05-30 20:49:47,870 INFO  L631         BuchiCegarLoop]: Abstraction has 30256 states and 36132 transitions.
[2020-05-30 20:49:47,870 INFO  L445         BuchiCegarLoop]: ======== Iteration 16============
[2020-05-30 20:49:47,870 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 30256 states and 36132 transitions.
[2020-05-30 20:49:47,907 INFO  L131   ngComponentsAnalysis]: Automaton has 19 accepting balls. 72
[2020-05-30 20:49:47,907 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:49:47,907 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:49:47,909 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:49:47,909 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND FALSE  !(choice == 2)
[L3835]        COND TRUE   choice == 1
[L3837]                    gas := gas - 21000;
[L3838]        COND TRUE   gas >= 0
[L3840]                    assume msgvalue_MSG == 0;
[L3841]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == ben && amount == fsum_deposit_RefundEscrow_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3841]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND TRUE   choice == 3
[L3819]                    gas := gas - 21000;
[L3820]        COND TRUE   gas >= 0
[L3822]                    assume msgvalue_MSG == 0;
[L3823]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3823]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND FALSE  !(choice == 1)
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:49:47,913 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:49:47,913 INFO  L82        PathProgramCache]: Analyzing trace with hash -227862988, now seen corresponding path program 1 times
[2020-05-30 20:49:47,913 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:49:47,927 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:49:48,104 INFO  L134       CoverageAnalysis]: Checked inductivity of 154 backedges. 33 proven. 0 refuted. 0 times theorem prover too weak. 121 trivial. 0 not checked.
[2020-05-30 20:49:48,104 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:49:48,104 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [10] imperfect sequences [] total 10
[2020-05-30 20:49:48,105 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:49:48,105 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 10 interpolants.
[2020-05-30 20:49:48,105 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=18, Invalid=72, Unknown=0, NotChecked=0, Total=90
[2020-05-30 20:49:48,105 INFO  L87              Difference]: Start difference. First operand 30256 states and 36132 transitions. cyclomatic complexity: 6013 Second operand 10 states.
[2020-05-30 20:49:58,017 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:49:58,017 INFO  L93              Difference]: Finished difference Result 31305 states and 36580 transitions.
[2020-05-30 20:49:58,017 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-30 20:49:58,017 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 31305 states and 36580 transitions.
[2020-05-30 20:49:58,110 INFO  L131   ngComponentsAnalysis]: Automaton has 13 accepting balls. 56
[2020-05-30 20:49:58,158 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 31305 states to 15378 states and 17835 transitions.
[2020-05-30 20:49:58,158 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 3561
[2020-05-30 20:49:58,160 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 3561
[2020-05-30 20:49:58,160 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 15378 states and 17835 transitions.
[2020-05-30 20:49:58,170 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:49:58,170 INFO  L728         BuchiCegarLoop]: Abstraction has 15378 states and 17835 transitions.
[2020-05-30 20:49:58,177 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 15378 states and 17835 transitions.
[2020-05-30 20:49:58,267 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 15378 to 14307.
[2020-05-30 20:49:58,267 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 14307 states.
[2020-05-30 20:49:58,290 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 14307 states to 14307 states and 16604 transitions.
[2020-05-30 20:49:58,290 INFO  L751         BuchiCegarLoop]: Abstraction has 14307 states and 16604 transitions.
[2020-05-30 20:49:58,290 INFO  L631         BuchiCegarLoop]: Abstraction has 14307 states and 16604 transitions.
[2020-05-30 20:49:58,290 INFO  L445         BuchiCegarLoop]: ======== Iteration 17============
[2020-05-30 20:49:58,290 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 14307 states and 16604 transitions.
[2020-05-30 20:49:58,307 INFO  L131   ngComponentsAnalysis]: Automaton has 13 accepting balls. 56
[2020-05-30 20:49:58,308 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:49:58,308 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:49:58,309 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:49:58,309 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND FALSE  !(choice == 2)
[L3835]        COND TRUE   choice == 1
[L3837]                    gas := gas - 21000;
[L3838]        COND TRUE   gas >= 0
[L3840]                    assume msgvalue_MSG == 0;
[L3841]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == ben && amount == fsum_deposit_RefundEscrow_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3841]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND TRUE   choice == 3
[L3819]                    gas := gas - 21000;
[L3820]        COND TRUE   gas >= 0
[L3822]                    assume msgvalue_MSG == 0;
[L3823]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3823]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND FALSE  !(DType[this] == RefundEscrow)
[L1974]        COND TRUE   DType[this] == ConditionalEscrow
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND FALSE  !(DType[this] == RefundEscrow)
[L1998]        COND TRUE   DType[this] == ConditionalEscrow
[L2000]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L2000]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2001]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:49:58,313 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:49:58,313 INFO  L82        PathProgramCache]: Analyzing trace with hash 1209402883, now seen corresponding path program 1 times
[2020-05-30 20:49:58,313 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:49:58,325 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:49:58,414 INFO  L134       CoverageAnalysis]: Checked inductivity of 159 backedges. 42 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:49:58,414 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:49:58,414 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [11] imperfect sequences [] total 11
[2020-05-30 20:49:58,414 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:49:58,414 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-05-30 20:49:58,415 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=21, Invalid=89, Unknown=0, NotChecked=0, Total=110
[2020-05-30 20:49:58,415 INFO  L87              Difference]: Start difference. First operand 14307 states and 16604 transitions. cyclomatic complexity: 2343 Second operand 11 states.
[2020-05-30 20:50:04,309 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:50:04,309 INFO  L93              Difference]: Finished difference Result 9610 states and 10789 transitions.
[2020-05-30 20:50:04,309 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 12 states. 
[2020-05-30 20:50:04,310 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9610 states and 10789 transitions.
[2020-05-30 20:50:04,334 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 8
[2020-05-30 20:50:04,356 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9610 states to 9424 states and 10597 transitions.
[2020-05-30 20:50:04,356 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1984
[2020-05-30 20:50:04,357 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1984
[2020-05-30 20:50:04,357 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9424 states and 10597 transitions.
[2020-05-30 20:50:04,362 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:50:04,362 INFO  L728         BuchiCegarLoop]: Abstraction has 9424 states and 10597 transitions.
[2020-05-30 20:50:04,366 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9424 states and 10597 transitions.
[2020-05-30 20:50:04,413 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9424 to 9365.
[2020-05-30 20:50:04,413 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 9365 states.
[2020-05-30 20:50:04,423 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 9365 states to 9365 states and 10523 transitions.
[2020-05-30 20:50:04,423 INFO  L751         BuchiCegarLoop]: Abstraction has 9365 states and 10523 transitions.
[2020-05-30 20:50:04,423 INFO  L631         BuchiCegarLoop]: Abstraction has 9365 states and 10523 transitions.
[2020-05-30 20:50:04,423 INFO  L445         BuchiCegarLoop]: ======== Iteration 18============
[2020-05-30 20:50:04,423 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 9365 states and 10523 transitions.
[2020-05-30 20:50:04,432 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 8
[2020-05-30 20:50:04,432 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:50:04,432 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:50:04,433 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:50:04,433 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND TRUE   choice == 3
[L3819]                    gas := gas - 21000;
[L3820]        COND TRUE   gas >= 0
[L3822]                    assume msgvalue_MSG == 0;
[L3823]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3823]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND FALSE  !(choice == 2)
[L3835]        COND TRUE   choice == 1
[L3837]                    gas := gas - 21000;
[L3838]        COND TRUE   gas >= 0
[L3840]                    assume msgvalue_MSG == 0;
[L3841]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3841]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND FALSE  !(choice == 1)
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:50:04,436 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:50:04,437 INFO  L82        PathProgramCache]: Analyzing trace with hash 2128425068, now seen corresponding path program 1 times
[2020-05-30 20:50:04,437 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:50:04,455 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:50:04,886 INFO  L134       CoverageAnalysis]: Checked inductivity of 221 backedges. 36 proven. 15 refuted. 0 times theorem prover too weak. 170 trivial. 0 not checked.
[2020-05-30 20:50:04,886 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:50:04,886 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [39] total 39
[2020-05-30 20:50:04,887 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:50:04,887 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 40 interpolants.
[2020-05-30 20:50:04,887 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=116, Invalid=1444, Unknown=0, NotChecked=0, Total=1560
[2020-05-30 20:50:04,887 INFO  L87              Difference]: Start difference. First operand 9365 states and 10523 transitions. cyclomatic complexity: 1187 Second operand 40 states.
[2020-05-30 20:50:32,688 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:50:32,688 INFO  L93              Difference]: Finished difference Result 10640 states and 12109 transitions.
[2020-05-30 20:50:32,688 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 68 states. 
[2020-05-30 20:50:32,689 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 10640 states and 12109 transitions.
[2020-05-30 20:50:32,712 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 8
[2020-05-30 20:50:32,736 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 10640 states to 10640 states and 12109 transitions.
[2020-05-30 20:50:32,736 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2040
[2020-05-30 20:50:32,736 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2040
[2020-05-30 20:50:32,737 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 10640 states and 12109 transitions.
[2020-05-30 20:50:32,742 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:50:32,742 INFO  L728         BuchiCegarLoop]: Abstraction has 10640 states and 12109 transitions.
[2020-05-30 20:50:32,745 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 10640 states and 12109 transitions.
[2020-05-30 20:50:32,798 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 10640 to 9477.
[2020-05-30 20:50:32,798 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 9477 states.
[2020-05-30 20:50:32,810 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 9477 states to 9477 states and 10691 transitions.
[2020-05-30 20:50:32,811 INFO  L751         BuchiCegarLoop]: Abstraction has 9477 states and 10691 transitions.
[2020-05-30 20:50:32,811 INFO  L631         BuchiCegarLoop]: Abstraction has 9477 states and 10691 transitions.
[2020-05-30 20:50:32,811 INFO  L445         BuchiCegarLoop]: ======== Iteration 19============
[2020-05-30 20:50:32,811 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 9477 states and 10691 transitions.
[2020-05-30 20:50:32,820 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 8
[2020-05-30 20:50:32,821 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:50:32,821 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:50:32,822 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:50:32,822 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND FALSE  !(DType[this] == RefundEscrow)
[L1974]        COND TRUE   DType[this] == ConditionalEscrow
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND FALSE  !(DType[this] == RefundEscrow)
[L1998]        COND TRUE   DType[this] == ConditionalEscrow
[L2000]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L2000]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2001]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND TRUE   choice == 3
[L3819]                    gas := gas - 21000;
[L3820]        COND TRUE   gas >= 0
[L3822]                    assume msgvalue_MSG == 0;
[L3823]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3823]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND FALSE  !(choice == 2)
[L3835]        COND TRUE   choice == 1
[L3837]                    gas := gas - 21000;
[L3838]        COND TRUE   gas >= 0
[L3840]                    assume msgvalue_MSG == 0;
[L3841]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3841]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND TRUE   choice == 1
[L3837]              gas := gas - 21000;
[L3838]  COND TRUE   gas >= 0
[L3840]              assume msgvalue_MSG == 0;
[L3841]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND TRUE   gas > 2300
[L2352]              gas := 2300;
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]              havoc __exception;
[L3289]  COND FALSE  !(__exception)
[L3314]  COND TRUE   Balance[from] >= amount
[L3316]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND FALSE  !(DType[to] == RefundEscrow)
[L2428]  COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]  COND FALSE  !(DType[to] == Escrow)
[L2436]  COND FALSE  !(DType[to] == Secondary)
[L2442]  CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]              assume Balance[from] >= amount;
[L2856]              Balance[from] := Balance[from] - amount;
[L2857]              Balance[to] := Balance[to] + amount;
[L2858]  COND FALSE  !(choice == 0)
[L2864]  COND TRUE   gas < 21000
[L2442]  RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]  COND FALSE  !(revert)
[L3316]  RET         call FallbackDispatch__success(from, to, amount);
[L3317]              success := true;
[L3324]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3841]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:50:32,825 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:50:32,826 INFO  L82        PathProgramCache]: Analyzing trace with hash -410001370, now seen corresponding path program 1 times
[2020-05-30 20:50:32,826 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:50:32,840 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:50:32,927 INFO  L134       CoverageAnalysis]: Checked inductivity of 158 backedges. 4 proven. 0 refuted. 0 times theorem prover too weak. 154 trivial. 0 not checked.
[2020-05-30 20:50:32,927 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:50:32,927 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [6] imperfect sequences [] total 6
[2020-05-30 20:50:32,927 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:50:32,927 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 6 interpolants.
[2020-05-30 20:50:32,928 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=9, Invalid=21, Unknown=0, NotChecked=0, Total=30
[2020-05-30 20:50:32,928 INFO  L87              Difference]: Start difference. First operand 9477 states and 10691 transitions. cyclomatic complexity: 1248 Second operand 6 states.
[2020-05-30 20:50:33,220 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:50:33,221 INFO  L93              Difference]: Finished difference Result 9705 states and 10913 transitions.
[2020-05-30 20:50:33,221 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 6 states. 
[2020-05-30 20:50:33,221 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9705 states and 10913 transitions.
[2020-05-30 20:50:33,244 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 8
[2020-05-30 20:50:33,266 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9705 states to 9409 states and 10592 transitions.
[2020-05-30 20:50:33,266 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1958
[2020-05-30 20:50:33,267 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1958
[2020-05-30 20:50:33,267 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9409 states and 10592 transitions.
[2020-05-30 20:50:33,272 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:50:33,272 INFO  L728         BuchiCegarLoop]: Abstraction has 9409 states and 10592 transitions.
[2020-05-30 20:50:33,275 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9409 states and 10592 transitions.
[2020-05-30 20:50:33,323 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9409 to 9409.
[2020-05-30 20:50:33,323 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 9409 states.
[2020-05-30 20:50:33,334 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 9409 states to 9409 states and 10592 transitions.
[2020-05-30 20:50:33,334 INFO  L751         BuchiCegarLoop]: Abstraction has 9409 states and 10592 transitions.
[2020-05-30 20:50:33,334 INFO  L631         BuchiCegarLoop]: Abstraction has 9409 states and 10592 transitions.
[2020-05-30 20:50:33,334 INFO  L445         BuchiCegarLoop]: ======== Iteration 20============
[2020-05-30 20:50:33,334 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 9409 states and 10592 transitions.
[2020-05-30 20:50:33,343 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 8
[2020-05-30 20:50:33,343 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:50:33,343 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:50:33,345 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:50:33,345 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND TRUE   choice == 3
[L3819]                    gas := gas - 21000;
[L3820]        COND TRUE   gas >= 0
[L3822]                    assume msgvalue_MSG == 0;
[L3823]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3823]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND FALSE  !(choice == 2)
[L3835]        COND TRUE   choice == 1
[L3837]                    gas := gas - 21000;
[L3838]        COND TRUE   gas >= 0
[L3840]                    assume msgvalue_MSG == 0;
[L3841]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3841]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND TRUE   choice == 1
[L3837]              gas := gas - 21000;
[L3838]  COND TRUE   gas >= 0
[L3840]              assume msgvalue_MSG == 0;
[L3841]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND TRUE   gas > 2300
[L2352]              gas := 2300;
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]              havoc __exception;
[L3289]  COND FALSE  !(__exception)
[L3314]  COND TRUE   Balance[from] >= amount
[L3316]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND FALSE  !(DType[to] == RefundEscrow)
[L2428]  COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]  COND FALSE  !(DType[to] == Escrow)
[L2436]  COND FALSE  !(DType[to] == Secondary)
[L2442]  CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]              assume Balance[from] >= amount;
[L2856]              Balance[from] := Balance[from] - amount;
[L2857]              Balance[to] := Balance[to] + amount;
[L2858]  COND FALSE  !(choice == 0)
[L2864]  COND TRUE   gas < 21000
[L2442]  RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]  COND FALSE  !(revert)
[L3316]  RET         call FallbackDispatch__success(from, to, amount);
[L3317]              success := true;
[L3324]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3841]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:50:33,349 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:50:33,349 INFO  L82        PathProgramCache]: Analyzing trace with hash -1838047817, now seen corresponding path program 1 times
[2020-05-30 20:50:33,349 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:50:33,368 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:50:33,506 INFO  L134       CoverageAnalysis]: Checked inductivity of 244 backedges. 78 proven. 0 refuted. 0 times theorem prover too weak. 166 trivial. 0 not checked.
[2020-05-30 20:50:33,507 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:50:33,507 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [13] imperfect sequences [] total 13
[2020-05-30 20:50:33,508 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:50:33,508 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 13 interpolants.
[2020-05-30 20:50:33,508 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=26, Invalid=130, Unknown=0, NotChecked=0, Total=156
[2020-05-30 20:50:33,508 INFO  L87              Difference]: Start difference. First operand 9409 states and 10592 transitions. cyclomatic complexity: 1217 Second operand 13 states.
[2020-05-30 20:50:37,948 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:50:37,948 INFO  L93              Difference]: Finished difference Result 12061 states and 14072 transitions.
[2020-05-30 20:50:37,948 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-30 20:50:37,949 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 12061 states and 14072 transitions.
[2020-05-30 20:50:37,983 INFO  L131   ngComponentsAnalysis]: Automaton has 8 accepting balls. 16
[2020-05-30 20:50:38,020 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 12061 states to 11419 states and 13193 transitions.
[2020-05-30 20:50:38,020 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2440
[2020-05-30 20:50:38,021 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2440
[2020-05-30 20:50:38,021 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 11419 states and 13193 transitions.
[2020-05-30 20:50:38,029 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:50:38,029 INFO  L728         BuchiCegarLoop]: Abstraction has 11419 states and 13193 transitions.
[2020-05-30 20:50:38,033 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 11419 states and 13193 transitions.
[2020-05-30 20:50:38,094 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 11419 to 11307.
[2020-05-30 20:50:38,094 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 11307 states.
[2020-05-30 20:50:38,111 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 11307 states to 11307 states and 13054 transitions.
[2020-05-30 20:50:38,111 INFO  L751         BuchiCegarLoop]: Abstraction has 11307 states and 13054 transitions.
[2020-05-30 20:50:38,111 INFO  L631         BuchiCegarLoop]: Abstraction has 11307 states and 13054 transitions.
[2020-05-30 20:50:38,111 INFO  L445         BuchiCegarLoop]: ======== Iteration 21============
[2020-05-30 20:50:38,111 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 11307 states and 13054 transitions.
[2020-05-30 20:50:38,123 INFO  L131   ngComponentsAnalysis]: Automaton has 8 accepting balls. 16
[2020-05-30 20:50:38,123 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:50:38,123 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:50:38,124 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:50:38,124 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND TRUE   choice == 3
[L3819]                    gas := gas - 21000;
[L3820]        COND TRUE   gas >= 0
[L3822]                    assume msgvalue_MSG == 0;
[L3823]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3823]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND FALSE  !(choice == 2)
[L3835]        COND TRUE   choice == 1
[L3837]                    gas := gas - 21000;
[L3838]        COND TRUE   gas >= 0
[L3840]                    assume msgvalue_MSG == 0;
[L3841]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3841]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND TRUE   choice == 1
[L3837]              gas := gas - 21000;
[L3838]  COND TRUE   gas >= 0
[L3840]              assume msgvalue_MSG == 0;
[L3841]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND TRUE   gas > 2300
[L2352]              gas := 2300;
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]              havoc __exception;
[L3289]  COND FALSE  !(__exception)
[L3314]  COND TRUE   Balance[from] >= amount
[L3316]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND TRUE   DType[to] == RefundEscrow
[L2426]              assume amount == 0;
[L3316]  RET         call FallbackDispatch__success(from, to, amount);
[L3317]              success := true;
[L3324]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3841]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:50:38,128 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:50:38,128 INFO  L82        PathProgramCache]: Analyzing trace with hash -735921058, now seen corresponding path program 1 times
[2020-05-30 20:50:38,128 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:50:38,142 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:50:38,321 INFO  L134       CoverageAnalysis]: Checked inductivity of 171 backedges. 2 proven. 35 refuted. 0 times theorem prover too weak. 134 trivial. 0 not checked.
[2020-05-30 20:50:38,321 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:50:38,321 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [12] total 12
[2020-05-30 20:50:38,321 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:50:38,321 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 12 interpolants.
[2020-05-30 20:50:38,322 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=22, Invalid=110, Unknown=0, NotChecked=0, Total=132
[2020-05-30 20:50:38,322 INFO  L87              Difference]: Start difference. First operand 11307 states and 13054 transitions. cyclomatic complexity: 1795 Second operand 12 states.
[2020-05-30 20:50:41,644 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:50:41,644 INFO  L93              Difference]: Finished difference Result 9784 states and 11007 transitions.
[2020-05-30 20:50:41,644 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 14 states. 
[2020-05-30 20:50:41,644 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9784 states and 11007 transitions.
[2020-05-30 20:50:41,668 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 8
[2020-05-30 20:50:41,693 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9784 states to 9432 states and 10579 transitions.
[2020-05-30 20:50:41,693 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1812
[2020-05-30 20:50:41,694 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1812
[2020-05-30 20:50:41,694 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9432 states and 10579 transitions.
[2020-05-30 20:50:41,699 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:50:41,699 INFO  L728         BuchiCegarLoop]: Abstraction has 9432 states and 10579 transitions.
[2020-05-30 20:50:41,703 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9432 states and 10579 transitions.
[2020-05-30 20:50:41,749 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9432 to 9403.
[2020-05-30 20:50:41,749 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 9403 states.
[2020-05-30 20:50:41,759 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 9403 states to 9403 states and 10543 transitions.
[2020-05-30 20:50:41,759 INFO  L751         BuchiCegarLoop]: Abstraction has 9403 states and 10543 transitions.
[2020-05-30 20:50:41,760 INFO  L631         BuchiCegarLoop]: Abstraction has 9403 states and 10543 transitions.
[2020-05-30 20:50:41,760 INFO  L445         BuchiCegarLoop]: ======== Iteration 22============
[2020-05-30 20:50:41,760 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 9403 states and 10543 transitions.
[2020-05-30 20:50:41,769 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 8
[2020-05-30 20:50:41,769 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:50:41,769 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:50:41,770 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:50:41,770 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND TRUE   choice == 3
[L3819]                    gas := gas - 21000;
[L3820]        COND TRUE   gas >= 0
[L3822]                    assume msgvalue_MSG == 0;
[L3823]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3823]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND FALSE  !(choice == 2)
[L3835]        COND TRUE   choice == 1
[L3837]                    gas := gas - 21000;
[L3838]        COND TRUE   gas >= 0
[L3840]                    assume msgvalue_MSG == 0;
[L3841]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3841]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND TRUE   choice == 1
[L3837]              gas := gas - 21000;
[L3838]  COND TRUE   gas >= 0
[L3840]              assume msgvalue_MSG == 0;
[L3841]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND TRUE   gas > 2300
[L2352]              gas := 2300;
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]              havoc __exception;
[L3289]  COND FALSE  !(__exception)
[L3314]  COND TRUE   Balance[from] >= amount
[L3316]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND FALSE  !(DType[to] == RefundEscrow)
[L2428]  COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]  COND FALSE  !(DType[to] == Escrow)
[L2436]  COND FALSE  !(DType[to] == Secondary)
[L2442]  CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]              assume Balance[from] >= amount;
[L2856]              Balance[from] := Balance[from] - amount;
[L2857]              Balance[to] := Balance[to] + amount;
[L2858]  COND FALSE  !(choice == 0)
[L2864]  COND TRUE   gas < 21000
[L2442]  RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]  COND FALSE  !(revert)
[L3316]  RET         call FallbackDispatch__success(from, to, amount);
[L3317]              success := true;
[L3324]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3841]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:50:41,774 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:50:41,774 INFO  L82        PathProgramCache]: Analyzing trace with hash -482597162, now seen corresponding path program 1 times
[2020-05-30 20:50:41,774 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:50:41,810 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:50:42,126 INFO  L134       CoverageAnalysis]: Checked inductivity of 221 backedges. 50 proven. 1 refuted. 0 times theorem prover too weak. 170 trivial. 0 not checked.
[2020-05-30 20:50:42,126 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:50:42,126 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [35] total 35
[2020-05-30 20:50:42,127 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:50:42,127 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 36 interpolants.
[2020-05-30 20:50:42,127 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=102, Invalid=1158, Unknown=0, NotChecked=0, Total=1260
[2020-05-30 20:50:42,127 INFO  L87              Difference]: Start difference. First operand 9403 states and 10543 transitions. cyclomatic complexity: 1173 Second operand 36 states.
[2020-05-30 20:50:55,017 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:50:55,017 INFO  L93              Difference]: Finished difference Result 10600 states and 12114 transitions.
[2020-05-30 20:50:55,017 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 53 states. 
[2020-05-30 20:50:55,018 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 10600 states and 12114 transitions.
[2020-05-30 20:50:55,043 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 8
[2020-05-30 20:50:55,067 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 10600 states to 9526 states and 10723 transitions.
[2020-05-30 20:50:55,067 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1828
[2020-05-30 20:50:55,067 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1828
[2020-05-30 20:50:55,068 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9526 states and 10723 transitions.
[2020-05-30 20:50:55,073 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:50:55,073 INFO  L728         BuchiCegarLoop]: Abstraction has 9526 states and 10723 transitions.
[2020-05-30 20:50:55,076 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9526 states and 10723 transitions.
[2020-05-30 20:50:55,118 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9526 to 9323.
[2020-05-30 20:50:55,118 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 9323 states.
[2020-05-30 20:50:55,128 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 9323 states to 9323 states and 10424 transitions.
[2020-05-30 20:50:55,128 INFO  L751         BuchiCegarLoop]: Abstraction has 9323 states and 10424 transitions.
[2020-05-30 20:50:55,128 INFO  L631         BuchiCegarLoop]: Abstraction has 9323 states and 10424 transitions.
[2020-05-30 20:50:55,129 INFO  L445         BuchiCegarLoop]: ======== Iteration 23============
[2020-05-30 20:50:55,129 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 9323 states and 10424 transitions.
[2020-05-30 20:50:55,137 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 8
[2020-05-30 20:50:55,138 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:50:55,138 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:50:55,139 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:50:55,139 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND TRUE   choice == 10
[L3756]                    gas := gas - 21000;
[L3757]        COND TRUE   gas >= 0
[L3759]                    assume msgvalue_MSG == 0;
[L3760]        CALL        call transferPrimary_Secondary(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L230]                     havoc __exception;
[L231]                     revert := false;
[L232]         COND FALSE  !(__exception)
[L251]         CALL        call transferPrimary_Secondary__success(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L1423]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1423]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1424]        COND FALSE  !(revert)
[L1429]                    gas := gas - 88;
[L1430]                    __var_1 := null;
[L1431]        COND FALSE  !(!(recipient_s113 != null))
[L1437]                    gas := gas - 40534;
[L1438]                    _primary_Secondary[this] := recipient_s113;
[L1439]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L251]         RET         call transferPrimary_Secondary__success(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L252]                     assume !revert && gas >= 0;
[L3760]        RET         call transferPrimary_Secondary(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND TRUE   choice == 3
[L3819]                    gas := gas - 21000;
[L3820]        COND TRUE   gas >= 0
[L3822]                    assume msgvalue_MSG == 0;
[L3823]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3823]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND FALSE  !(choice == 2)
[L3835]        COND TRUE   choice == 1
[L3837]                    gas := gas - 21000;
[L3838]        COND TRUE   gas >= 0
[L3840]                    assume msgvalue_MSG == 0;
[L3841]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3841]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND FALSE  !(choice == 1)
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:50:55,142 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:50:55,142 INFO  L82        PathProgramCache]: Analyzing trace with hash -453613354, now seen corresponding path program 1 times
[2020-05-30 20:50:55,143 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:50:55,162 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:50:55,587 INFO  L134       CoverageAnalysis]: Checked inductivity of 294 backedges. 49 proven. 47 refuted. 0 times theorem prover too weak. 198 trivial. 0 not checked.
[2020-05-30 20:50:55,588 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:50:55,588 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [47] total 47
[2020-05-30 20:50:55,588 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:50:55,588 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 48 interpolants.
[2020-05-30 20:50:55,589 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=156, Invalid=2100, Unknown=0, NotChecked=0, Total=2256
[2020-05-30 20:50:55,589 INFO  L87              Difference]: Start difference. First operand 9323 states and 10424 transitions. cyclomatic complexity: 1129 Second operand 48 states.
[2020-05-30 20:51:25,489 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:51:25,489 INFO  L93              Difference]: Finished difference Result 10570 states and 12103 transitions.
[2020-05-30 20:51:25,489 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 77 states. 
[2020-05-30 20:51:25,490 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 10570 states and 12103 transitions.
[2020-05-30 20:51:25,516 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 16
[2020-05-30 20:51:25,545 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 10570 states to 10570 states and 12103 transitions.
[2020-05-30 20:51:25,545 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1844
[2020-05-30 20:51:25,546 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1844
[2020-05-30 20:51:25,546 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 10570 states and 12103 transitions.
[2020-05-30 20:51:25,553 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:51:25,553 INFO  L728         BuchiCegarLoop]: Abstraction has 10570 states and 12103 transitions.
[2020-05-30 20:51:25,557 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 10570 states and 12103 transitions.
[2020-05-30 20:51:25,613 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 10570 to 10319.
[2020-05-30 20:51:25,613 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 10319 states.
[2020-05-30 20:51:25,625 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 10319 states to 10319 states and 11631 transitions.
[2020-05-30 20:51:25,625 INFO  L751         BuchiCegarLoop]: Abstraction has 10319 states and 11631 transitions.
[2020-05-30 20:51:25,625 INFO  L631         BuchiCegarLoop]: Abstraction has 10319 states and 11631 transitions.
[2020-05-30 20:51:25,625 INFO  L445         BuchiCegarLoop]: ======== Iteration 24============
[2020-05-30 20:51:25,625 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 10319 states and 11631 transitions.
[2020-05-30 20:51:25,635 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 8
[2020-05-30 20:51:25,635 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:51:25,635 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:51:25,637 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:51:25,637 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND TRUE   choice == 3
[L3819]                    gas := gas - 21000;
[L3820]        COND TRUE   gas >= 0
[L3822]                    assume msgvalue_MSG == 0;
[L3823]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3823]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND FALSE  !(choice == 2)
[L3835]        COND TRUE   choice == 1
[L3837]                    gas := gas - 21000;
[L3838]        COND TRUE   gas >= 0
[L3840]                    assume msgvalue_MSG == 0;
[L3841]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3841]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND TRUE   choice == 1
[L3837]              gas := gas - 21000;
[L3838]  COND TRUE   gas >= 0
[L3840]              assume msgvalue_MSG == 0;
[L3841]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND TRUE   gas > 2300
[L2352]              gas := 2300;
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]              havoc __exception;
[L3289]  COND FALSE  !(__exception)
[L3314]  COND TRUE   Balance[from] >= amount
[L3316]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND TRUE   DType[to] == RefundEscrow
[L2426]              assume amount == 0;
[L3316]  RET         call FallbackDispatch__success(from, to, amount);
[L3317]              success := true;
[L3324]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3841]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:51:25,641 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:51:25,641 INFO  L82        PathProgramCache]: Analyzing trace with hash -198317597, now seen corresponding path program 2 times
[2020-05-30 20:51:25,641 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:51:25,655 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:51:25,774 INFO  L134       CoverageAnalysis]: Checked inductivity of 244 backedges. 4 proven. 72 refuted. 0 times theorem prover too weak. 168 trivial. 0 not checked.
[2020-05-30 20:51:25,774 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:51:25,774 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [13] total 13
[2020-05-30 20:51:25,774 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:51:25,774 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 13 interpolants.
[2020-05-30 20:51:25,774 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=26, Invalid=130, Unknown=0, NotChecked=0, Total=156
[2020-05-30 20:51:25,775 INFO  L87              Difference]: Start difference. First operand 10319 states and 11631 transitions. cyclomatic complexity: 1357 Second operand 13 states.
[2020-05-30 20:51:29,249 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:51:29,250 INFO  L93              Difference]: Finished difference Result 5923 states and 6645 transitions.
[2020-05-30 20:51:29,250 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 12 states. 
[2020-05-30 20:51:29,250 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 5923 states and 6645 transitions.
[2020-05-30 20:51:29,265 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:51:29,278 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 5923 states to 5606 states and 6298 transitions.
[2020-05-30 20:51:29,278 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 906
[2020-05-30 20:51:29,279 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 906
[2020-05-30 20:51:29,279 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 5606 states and 6298 transitions.
[2020-05-30 20:51:29,282 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:51:29,282 INFO  L728         BuchiCegarLoop]: Abstraction has 5606 states and 6298 transitions.
[2020-05-30 20:51:29,285 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 5606 states and 6298 transitions.
[2020-05-30 20:51:29,310 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 5606 to 5606.
[2020-05-30 20:51:29,310 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 5606 states.
[2020-05-30 20:51:29,316 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 5606 states to 5606 states and 6298 transitions.
[2020-05-30 20:51:29,316 INFO  L751         BuchiCegarLoop]: Abstraction has 5606 states and 6298 transitions.
[2020-05-30 20:51:29,316 INFO  L631         BuchiCegarLoop]: Abstraction has 5606 states and 6298 transitions.
[2020-05-30 20:51:29,316 INFO  L445         BuchiCegarLoop]: ======== Iteration 25============
[2020-05-30 20:51:29,316 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 5606 states and 6298 transitions.
[2020-05-30 20:51:29,321 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:51:29,321 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:51:29,321 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:51:29,323 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:51:29,323 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND TRUE   choice == 10
[L3756]                    gas := gas - 21000;
[L3757]        COND TRUE   gas >= 0
[L3759]                    assume msgvalue_MSG == 0;
[L3760]        CALL        call transferPrimary_Secondary(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L230]                     havoc __exception;
[L231]                     revert := false;
[L232]         COND FALSE  !(__exception)
[L251]         CALL        call transferPrimary_Secondary__success(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L1423]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1423]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1424]        COND FALSE  !(revert)
[L1429]                    gas := gas - 88;
[L1430]                    __var_1 := null;
[L1431]        COND FALSE  !(!(recipient_s113 != null))
[L1437]                    gas := gas - 40534;
[L1438]                    _primary_Secondary[this] := recipient_s113;
[L1439]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L251]         RET         call transferPrimary_Secondary__success(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L252]                     assume !revert && gas >= 0;
[L3760]        RET         call transferPrimary_Secondary(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND TRUE   choice == 3
[L3819]                    gas := gas - 21000;
[L3820]        COND TRUE   gas >= 0
[L3822]                    assume msgvalue_MSG == 0;
[L3823]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3823]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND FALSE  !(choice == 2)
[L3835]        COND TRUE   choice == 1
[L3837]                    gas := gas - 21000;
[L3838]        COND TRUE   gas >= 0
[L3840]                    assume msgvalue_MSG == 0;
[L3841]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3841]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND FALSE  !(choice == 1)
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:51:29,326 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:51:29,326 INFO  L82        PathProgramCache]: Analyzing trace with hash -139236692, now seen corresponding path program 1 times
[2020-05-30 20:51:29,327 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:51:29,358 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:51:29,740 INFO  L134       CoverageAnalysis]: Checked inductivity of 294 backedges. 48 proven. 32 refuted. 0 times theorem prover too weak. 214 trivial. 0 not checked.
[2020-05-30 20:51:29,741 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:51:29,741 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [43] total 43
[2020-05-30 20:51:29,741 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:51:29,741 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 44 interpolants.
[2020-05-30 20:51:29,742 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=146, Invalid=1746, Unknown=0, NotChecked=0, Total=1892
[2020-05-30 20:51:29,742 INFO  L87              Difference]: Start difference. First operand 5606 states and 6298 transitions. cyclomatic complexity: 725 Second operand 44 states.
[2020-05-30 20:51:41,472 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:51:41,472 INFO  L93              Difference]: Finished difference Result 5701 states and 6476 transitions.
[2020-05-30 20:51:41,473 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 59 states. 
[2020-05-30 20:51:41,473 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 5701 states and 6476 transitions.
[2020-05-30 20:51:41,486 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:51:41,495 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 5701 states to 5389 states and 5953 transitions.
[2020-05-30 20:51:41,495 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 914
[2020-05-30 20:51:41,496 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 914
[2020-05-30 20:51:41,496 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 5389 states and 5953 transitions.
[2020-05-30 20:51:41,498 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:51:41,498 INFO  L728         BuchiCegarLoop]: Abstraction has 5389 states and 5953 transitions.
[2020-05-30 20:51:41,500 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 5389 states and 5953 transitions.
[2020-05-30 20:51:41,518 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 5389 to 5253.
[2020-05-30 20:51:41,518 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 5253 states.
[2020-05-30 20:51:41,523 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 5253 states to 5253 states and 5791 transitions.
[2020-05-30 20:51:41,523 INFO  L751         BuchiCegarLoop]: Abstraction has 5253 states and 5791 transitions.
[2020-05-30 20:51:41,523 INFO  L631         BuchiCegarLoop]: Abstraction has 5253 states and 5791 transitions.
[2020-05-30 20:51:41,523 INFO  L445         BuchiCegarLoop]: ======== Iteration 26============
[2020-05-30 20:51:41,523 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 5253 states and 5791 transitions.
[2020-05-30 20:51:41,527 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:51:41,527 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:51:41,527 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:51:41,529 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:51:41,529 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND TRUE   choice == 3
[L3819]                    gas := gas - 21000;
[L3820]        COND TRUE   gas >= 0
[L3822]                    assume msgvalue_MSG == 0;
[L3823]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3823]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND FALSE  !(choice == 2)
[L3835]        COND TRUE   choice == 1
[L3837]                    gas := gas - 21000;
[L3838]        COND TRUE   gas >= 0
[L3840]                    assume msgvalue_MSG == 0;
[L3841]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3841]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND TRUE   choice == 1
[L3837]              gas := gas - 21000;
[L3838]  COND TRUE   gas >= 0
[L3840]              assume msgvalue_MSG == 0;
[L3841]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND TRUE   gas > 2300
[L2352]              gas := 2300;
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]              havoc __exception;
[L3289]  COND FALSE  !(__exception)
[L3314]  COND TRUE   Balance[from] >= amount
[L3316]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND TRUE   DType[to] == RefundEscrow
[L2426]              assume amount == 0;
[L3316]  RET         call FallbackDispatch__success(from, to, amount);
[L3317]              success := true;
[L3324]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3841]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:51:41,533 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:51:41,533 INFO  L82        PathProgramCache]: Analyzing trace with hash -1783412387, now seen corresponding path program 1 times
[2020-05-30 20:51:41,533 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:51:41,548 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:51:41,661 INFO  L134       CoverageAnalysis]: Checked inductivity of 199 backedges. 1 proven. 32 refuted. 0 times theorem prover too weak. 166 trivial. 0 not checked.
[2020-05-30 20:51:41,661 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:51:41,661 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [13] total 13
[2020-05-30 20:51:41,662 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:51:41,662 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 13 interpolants.
[2020-05-30 20:51:41,662 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=26, Invalid=130, Unknown=0, NotChecked=0, Total=156
[2020-05-30 20:51:41,662 INFO  L87              Difference]: Start difference. First operand 5253 states and 5791 transitions. cyclomatic complexity: 550 Second operand 13 states.
[2020-05-30 20:51:42,366 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:51:42,366 INFO  L93              Difference]: Finished difference Result 1013 states and 1081 transitions.
[2020-05-30 20:51:42,366 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 12 states. 
[2020-05-30 20:51:42,367 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 1013 states and 1081 transitions.
[2020-05-30 20:51:42,369 INFO  L131   ngComponentsAnalysis]: Automaton has 0 accepting balls. 0
[2020-05-30 20:51:42,369 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 1013 states to 0 states and 0 transitions.
[2020-05-30 20:51:42,369 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 0
[2020-05-30 20:51:42,369 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 0
[2020-05-30 20:51:42,369 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 0 states and 0 transitions.
[2020-05-30 20:51:42,369 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:51:42,369 INFO  L728         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-05-30 20:51:42,369 INFO  L751         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-05-30 20:51:42,369 INFO  L631         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-05-30 20:51:42,369 INFO  L445         BuchiCegarLoop]: ======== Iteration 27============
[2020-05-30 20:51:42,369 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 0 states and 0 transitions.
[2020-05-30 20:51:42,370 INFO  L131   ngComponentsAnalysis]: Automaton has 0 accepting balls. 0
[2020-05-30 20:51:42,370 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is true
[2020-05-30 20:51:42,374 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer CFG 30.05 08:51:42 BasicIcfg
[2020-05-30 20:51:42,374 INFO  L132        PluginConnector]: ------------------------ END BuchiAutomizer----------------------------
[2020-05-30 20:51:42,374 INFO  L168              Benchmark]: Toolchain (without parser) took 319707.82 ms. Allocated memory was 514.9 MB in the beginning and 4.8 GB in the end (delta: 4.3 GB). Free memory was 457.5 MB in the beginning and 2.0 GB in the end (delta: -1.5 GB). Peak memory consumption was 2.8 GB. Max. memory is 15.3 GB.
[2020-05-30 20:51:42,375 INFO  L168              Benchmark]: Boogie PL CUP Parser took 0.11 ms. Allocated memory is still 514.9 MB. Free memory is still 468.3 MB. There was no memory consumed. Max. memory is 15.3 GB.
[2020-05-30 20:51:42,376 INFO  L168              Benchmark]: Boogie Preprocessor took 70.65 ms. Allocated memory is still 514.9 MB. Free memory was 457.5 MB in the beginning and 449.4 MB in the end (delta: 8.1 MB). Peak memory consumption was 8.1 MB. Max. memory is 15.3 GB.
[2020-05-30 20:51:42,376 INFO  L168              Benchmark]: UtopiaSpecLang took 43.96 ms. Allocated memory is still 514.9 MB. Free memory was 449.4 MB in the beginning and 444.0 MB in the end (delta: 5.4 MB). Peak memory consumption was 5.4 MB. Max. memory is 15.3 GB.
[2020-05-30 20:51:42,377 INFO  L168              Benchmark]: Boogie Printer took 11.68 ms. Allocated memory is still 514.9 MB. Free memory was 444.0 MB in the beginning and 442.7 MB in the end (delta: 1.4 MB). Peak memory consumption was 1.4 MB. Max. memory is 15.3 GB.
[2020-05-30 20:51:42,377 INFO  L168              Benchmark]: RCFGBuilder took 532.85 ms. Allocated memory was 514.9 MB in the beginning and 552.6 MB in the end (delta: 37.7 MB). Free memory was 442.7 MB in the beginning and 505.5 MB in the end (delta: -62.9 MB). Peak memory consumption was 100.4 MB. Max. memory is 15.3 GB.
[2020-05-30 20:51:42,378 INFO  L168              Benchmark]: UtopiaLTL2Aut took 43.05 ms. Allocated memory is still 552.6 MB. Free memory was 505.5 MB in the beginning and 500.3 MB in the end (delta: 5.2 MB). Peak memory consumption was 5.2 MB. Max. memory is 15.3 GB.
[2020-05-30 20:51:42,378 INFO  L168              Benchmark]: BÃ¼chi Program Product took 5592.56 ms. Allocated memory was 552.6 MB in the beginning and 1.5 GB in the end (delta: 917.5 MB). Free memory was 500.3 MB in the beginning and 360.1 MB in the end (delta: 140.2 MB). Peak memory consumption was 1.1 GB. Max. memory is 15.3 GB.
[2020-05-30 20:51:42,378 INFO  L168              Benchmark]: BlockEncodingV2 took 756.45 ms. Allocated memory was 1.5 GB in the beginning and 1.5 GB in the end (delta: 3.1 MB). Free memory was 360.1 MB in the beginning and 870.4 MB in the end (delta: -510.2 MB). Peak memory consumption was 276.8 MB. Max. memory is 15.3 GB.
[2020-05-30 20:51:42,379 INFO  L168              Benchmark]: BuchiAutomizer took 312653.23 ms. Allocated memory was 1.5 GB in the beginning and 4.8 GB in the end (delta: 3.3 GB). Free memory was 870.4 MB in the beginning and 2.0 GB in the end (delta: -1.1 GB). Peak memory consumption was 2.2 GB. Max. memory is 15.3 GB.
[2020-05-30 20:51:42,383 INFO  L337   ainManager$Toolchain]: #######################  End [Toolchain 1] #######################
 --- Results ---
 * Results from de.uni_freiburg.informatik.ultimate.plugins.blockencoding:
  - StatisticsResult: Initial Icfg
    15695 locations, 65221 edges
  - StatisticsResult: Encoded RCFG
    15471 locations, 63891 edges
 * Results from de.uni_freiburg.informatik.ultimate.core:
  - StatisticsResult: Toolchain Benchmarks
    Benchmark results are:
 * Boogie PL CUP Parser took 0.11 ms. Allocated memory is still 514.9 MB. Free memory is still 468.3 MB. There was no memory consumed. Max. memory is 15.3 GB.
 * Boogie Preprocessor took 70.65 ms. Allocated memory is still 514.9 MB. Free memory was 457.5 MB in the beginning and 449.4 MB in the end (delta: 8.1 MB). Peak memory consumption was 8.1 MB. Max. memory is 15.3 GB.
 * UtopiaSpecLang took 43.96 ms. Allocated memory is still 514.9 MB. Free memory was 449.4 MB in the beginning and 444.0 MB in the end (delta: 5.4 MB). Peak memory consumption was 5.4 MB. Max. memory is 15.3 GB.
 * Boogie Printer took 11.68 ms. Allocated memory is still 514.9 MB. Free memory was 444.0 MB in the beginning and 442.7 MB in the end (delta: 1.4 MB). Peak memory consumption was 1.4 MB. Max. memory is 15.3 GB.
 * RCFGBuilder took 532.85 ms. Allocated memory was 514.9 MB in the beginning and 552.6 MB in the end (delta: 37.7 MB). Free memory was 442.7 MB in the beginning and 505.5 MB in the end (delta: -62.9 MB). Peak memory consumption was 100.4 MB. Max. memory is 15.3 GB.
 * UtopiaLTL2Aut took 43.05 ms. Allocated memory is still 552.6 MB. Free memory was 505.5 MB in the beginning and 500.3 MB in the end (delta: 5.2 MB). Peak memory consumption was 5.2 MB. Max. memory is 15.3 GB.
 * BÃ¼chi Program Product took 5592.56 ms. Allocated memory was 552.6 MB in the beginning and 1.5 GB in the end (delta: 917.5 MB). Free memory was 500.3 MB in the beginning and 360.1 MB in the end (delta: 140.2 MB). Peak memory consumption was 1.1 GB. Max. memory is 15.3 GB.
 * BlockEncodingV2 took 756.45 ms. Allocated memory was 1.5 GB in the beginning and 1.5 GB in the end (delta: 3.1 MB). Free memory was 360.1 MB in the beginning and 870.4 MB in the end (delta: -510.2 MB). Peak memory consumption was 276.8 MB. Max. memory is 15.3 GB.
 * BuchiAutomizer took 312653.23 ms. Allocated memory was 1.5 GB in the beginning and 4.8 GB in the end (delta: 3.3 GB). Free memory was 870.4 MB in the beginning and 2.0 GB in the end (delta: -1.1 GB). Peak memory consumption was 2.2 GB. Max. memory is 15.3 GB.
 * Results from de.uni_freiburg.informatik.ultimate.buchiprogramproduct:
  - StatisticsResult: Initial property automaton
    8 locations, 27 edges
  - StatisticsResult: Initial RCFG
    1608 locations, 2227 edges
  - StatisticsResult: BuchiProgram size
    15695 locations, 65221 edges
 * Results from de.uni_freiburg.informatik.ultimate.plugins.generator.traceabstraction:
  - StatisticsResult: Constructed decomposition of program
    Your program was decomposed into 26 terminating modules (26 trivial, 0 deterministic, 0 nondeterministic). 26 modules have a trivial ranking function, the largest among these consists of 48 locations.
  - StatisticsResult: Timing statistics
    BÃ¼chiAutomizer plugin needed 312.6s and 27 iterations.  TraceHistogramMax:4. Analysis of lassos took 5.6s. Construction of modules took 256.2s. BÃ¼chi inclusion checks took 41.8s. Highest rank in rank-based complementation 0. Minimization of det autom 26. Minimization of nondet autom 0. Automata minimization 4.4s AutomataMinimizationTime, 25 MinimizatonAttempts, 18619 StatesRemovedByMinimization, 19 NontrivialMinimizations. Non-live state removal took 3.0s Buchi closure took 0.0s. Biggest automaton had 44754 states and ocurred in iteration 12.	Nontrivial modules had stage [0, 0, 0, 0, 0].	InterpolantCoveringCapabilityFinite: 0/0	InterpolantCoveringCapabilityBuchi: 0/0	HoareTripleCheckerStatistics: 259303 SDtfs, 340081 SDslu, 588941 SDs, 0 SdLazy, 1604116 SolverSat, 77695 SolverUnsat, 0 SolverUnknown, 0 SolverNotchecked, 256.2s Time	LassoAnalysisResults: nont0 unkn0 SFLI0 SFLT0 conc0 concLT0 SILN0 SILU26 SILI0 SILT0 lasso0 LassoPreprocessingBenchmarks: LassoTerminationAnalysisBenchmarks: not availableLassoTerminationAnalysisBenchmarks: LassoNonterminationAnalysisSatFixpoint: 0	LassoNonterminationAnalysisSatUnbounded: 0	LassoNonterminationAnalysisUnsat: 0	LassoNonterminationAnalysisUnknown: 0	LassoNonterminationAnalysisTime: 0.0s	
  - AllSpecificationsHoldResult: All specifications hold
    Buchi Automizer proved that the LTL property ( ( <>(success_deposit_RefundEscrow0) ) && ( <>(success_beneficiaryWithdraw_RefundEscrow0) ) )&& ! ( ( []( (success_close_RefundEscrow0) ==> ( <>(success_send__success0) ) ) )) holds
RESULT: Ultimate proved your program to be correct!
Received shutdown request...
